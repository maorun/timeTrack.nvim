==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/animate/init.lua
==============================================================================
     8 local M = {}

     8 M.spring = require("notify.animate.spring")

     8 return M

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/animate/spring.lua
==============================================================================
       -- Adapted from https://gist.github.com/Fraktality/1033625223e13c01aa7144abe4aaf54d
       -- Explanation found here https://www.ryanjuckett.com/damped-springs/
     8 local pi = math.pi
     8 local exp = math.exp
     8 local sin = math.sin
     8 local cos = math.cos
     8 local sqrt = math.sqrt

       ---@class SpringState
       ---@field position number
       ---@field velocity number | nil

       ---@param dt number @Step in time
       ---@param state SpringState
       return function(dt, goal, state, frequency, damping)
*****0   local angular_freq = frequency * 2 * pi

*****0   local cur_vel = state.velocity or 0

*****0   local offset = state.position - goal
*****0   local decay = exp(-dt * damping * angular_freq)

         local new_pos
         local new_vel

*****0   if damping == 1 then -- critically damped
*****0     new_pos = (cur_vel * dt + offset * (angular_freq * dt + 1)) * decay + goal
*****0     new_vel = (cur_vel - angular_freq * dt * (offset * angular_freq + cur_vel)) * decay
*****0   elseif damping < 1 then -- underdamped
*****0     local c = sqrt(1 - damping * damping)

*****0     local i = cos(angular_freq * c * dt)
*****0     local j = sin(angular_freq * c * dt)

*****0     new_pos = (i * offset + j * (cur_vel + damping * angular_freq * offset) / (angular_freq * c))
*****0         * decay
*****0       + goal
*****0     new_vel = (i * c * cur_vel - j * (cur_vel * damping + angular_freq * offset)) * decay / c
         else -- overdamped
*****0     local c = sqrt(damping * damping - 1)

*****0     local r1 = -angular_freq * (damping - c)
*****0     local r2 = -angular_freq * (damping + c)

*****0     local co2 = (cur_vel - r1 * offset) / (2 * angular_freq * c)
*****0     local co1 = offset - co2

*****0     local e1 = co1 * exp(r1 * dt)
*****0     local e2 = co2 * exp(r2 * dt)

*****0     new_pos = e1 + e2 + goal
*****0     new_pos = r1 * e1 + r2 * e2
         end
*****0   state.position = new_pos
*****0   state.velocity = new_vel
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/config/highlights.lua
==============================================================================
     8 local M = {}

     8 function M.setup()
    16   vim.cmd([[
           hi default link NotifyBackground Normal
           hi default NotifyERRORBorder guifg=#8A1F1F
           hi default NotifyWARNBorder guifg=#79491D
           hi default NotifyINFOBorder guifg=#4F6752
           hi default NotifyDEBUGBorder guifg=#8B8B8B
           hi default NotifyTRACEBorder guifg=#4F3552
           hi default NotifyERRORIcon guifg=#F70067
           hi default NotifyWARNIcon guifg=#F79000
           hi default NotifyINFOIcon guifg=#A9FF68
           hi default NotifyDEBUGIcon guifg=#8B8B8B
           hi default NotifyTRACEIcon guifg=#D484FF
           hi default NotifyERRORTitle  guifg=#F70067
           hi default NotifyWARNTitle guifg=#F79000
           hi default NotifyINFOTitle guifg=#A9FF68
           hi default NotifyDEBUGTitle  guifg=#8B8B8B
           hi default NotifyTRACETitle  guifg=#D484FF
           hi default link NotifyERRORBody Normal
           hi default link NotifyWARNBody Normal
           hi default link NotifyINFOBody Normal
           hi default link NotifyDEBUGBody Normal
           hi default link NotifyTRACEBody Normal

           hi default link NotifyLogTime Comment
           hi default link NotifyLogTitle Special
     8   ]])
       end

     8 M.setup()

    16 vim.cmd([[
         augroup NvimNotifyRefreshHighlights
           autocmd!
           autocmd ColorScheme * lua require('notify.config.highlights').setup()
         augroup END
     8 ]])

     8 return M

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/config/init.lua
==============================================================================
       ---@tag notify.config

     8 local Config = {}
     8 local util = require("notify.util")

     8 require("notify.config.highlights")

     8 local BUILTIN_RENDERERS = {
         DEFAULT = "default",
         MINIMAL = "minimal",
       }

     8 local BUILTIN_STAGES = {
         FADE = "fade",
         SLIDE = "slide",
         SLIDE_OUT = "slide_out",
         FADE_IN_SLIDE_OUT = "fade_in_slide_out",
         STATIC = "static",
       }

     8 local default_config = {
     8   level = vim.log.levels.INFO,
         timeout = 5000,
         max_width = nil,
         max_height = nil,
     8   stages = BUILTIN_STAGES.FADE_IN_SLIDE_OUT,
     8   render = BUILTIN_RENDERERS.DEFAULT,
         background_colour = "NotifyBackground",
         on_open = nil,
         on_close = nil,
         minimum_width = 50,
         fps = 30,
         top_down = true,
         merge_duplicates = true,
     8   time_formats = {
           notification_history = "%FT%T",
           notification = "%T",
     8   },
     8   icons = {
           ERROR = "",
           WARN = "",
           INFO = "",
           DEBUG = "",
           TRACE = "✎",
     8   },
       }

       ---@class notify.Config
       ---@field level string|integer|nil Minimum log level to display. See vim.log.levels.
       ---@field timeout number? Default timeout for notification
       ---@field max_width number|function|nil Max number of columns for messages
       ---@field max_height number|function|nil Max number of lines for a message
       ---@field stages string|function[]|nil Animation stages
       ---@field background_colour string? For stages that change opacity this is treated as the highlight behind the window. Set this to either a highlight group, an RGB hex value e.g. "#000000" or a function returning an RGB code for dynamic values
       ---@field icons table? Icons for each level (upper case names)
       ---@field time_formats table? Time formats for different kind of notifications
       ---@field on_open function? Function called when a new window is opened, use for changing win settings/config
       ---@field on_close function? Function called when a window is closed
       ---@field render function|string|nil Function to render a notification buffer or a built-in renderer name
       ---@field minimum_width integer? Minimum width for notification windows
       ---@field fps integer? Frames per second for animation stages, higher value means smoother animations but more CPU usage
       ---@field top_down boolean? whether or not to position the notifications at the top or not
       ---@field merge_duplicates boolean|integer whether to replace visible notification if new one is the same, can be an integer for min duplicate count

     8 local opacity_warned = false

       local function validate_highlight(colour_or_group, needs_opacity)
*****0   if type(colour_or_group) == "function" then
*****0     return colour_or_group
         end
*****0   if colour_or_group:sub(1, 1) == "#" then
           return function()
*****0       return colour_or_group
           end
         end
         return function()
*****0     local group = vim.api.nvim_get_hl(0, { name = colour_or_group, create = false, link = false })
*****0     if not group or not group.bg then
*****0       if needs_opacity and not opacity_warned then
*****0         opacity_warned = true
*****0         vim.schedule(function()
*****0           vim.notify("Highlight group '" .. colour_or_group .. [[' has no background highlight
       Please provide an RGB hex value or highlight group with a background value for 'background_colour' option.
       This is the colour that will be used for 100% transparency.
       ```lua
       require("notify").setup({
         background_colour = "#000000",
       })
       ```
*****0 Defaulting to #000000]], "warn", {
                   title = "nvim-notify",
                   on_open = function(win)
*****0               local buf = vim.api.nvim_win_get_buf(win)
*****0               vim.api.nvim_set_option_value("filetype", "markdown", { buf = buf })
                   end,
                 })
               end)
             end
*****0       return "#000000"
           end
*****0     return string.format("#%x", group.bg)
         end
       end

     8 function Config._format_default()
*****0   local lines = { "Default values:", ">lua" }
*****0   for line in vim.gsplit(vim.inspect(default_config), "\n", true) do
*****0     table.insert(lines, "  " .. line)
         end
*****0   table.insert(lines, "<")
*****0   return lines
       end

     8 function Config.setup(custom_config)
*****0   local user_config = vim.tbl_deep_extend("keep", custom_config or {}, default_config)
*****0   local config = {}

*****0   function config.merged()
*****0     return user_config
         end

*****0   function config.level()
*****0     local level = user_config.level
*****0     if type(level) == "number" then
*****0       return level
           end
*****0     return vim.log.levels[vim.fn.toupper(level)] or vim.log.levels.INFO
         end

*****0   function config.fps()
*****0     return user_config.fps
         end

*****0   function config.background_colour()
*****0     return tonumber(user_config.background_colour():gsub("#", "0x"), 16)
         end

*****0   function config.time_formats()
*****0     return user_config.time_formats
         end

*****0   function config.icons()
*****0     return user_config.icons
         end

*****0   function config.stages()
*****0     return user_config.stages
         end

*****0   function config.default_timeout()
*****0     return user_config.timeout
         end

*****0   function config.on_open()
*****0     return user_config.on_open
         end

*****0   function config.top_down()
*****0     return user_config.top_down
         end

*****0   function config.merge_duplicates()
*****0     return user_config.merge_duplicates
         end

*****0   function config.on_close()
*****0     return user_config.on_close
         end

*****0   function config.render()
*****0     return user_config.render
         end

*****0   function config.minimum_width()
*****0     return user_config.minimum_width
         end

*****0   function config.max_width()
*****0     return util.is_callable(user_config.max_width) and user_config.max_width()
*****0       or user_config.max_width
         end

*****0   function config.max_height()
*****0     return util.is_callable(user_config.max_height) and user_config.max_height()
*****0       or user_config.max_height
         end

*****0   local stages = config.stages()

         local needs_opacity =
*****0     vim.tbl_contains({ BUILTIN_STAGES.FADE_IN_SLIDE_OUT, BUILTIN_STAGES.FADE }, stages)

*****0   if needs_opacity and not vim.opt.termguicolors:get() and vim.fn.has("nvim-0.10") == 0 then
*****0     user_config.stages = BUILTIN_STAGES.STATIC
*****0     vim.schedule(function()
*****0       vim.notify(
               "Opacity changes require termguicolors to be set.\nChange to different animation stages or set termguicolors to disable this warning",
               "warn",
*****0         { title = "nvim-notify" }
             )
           end)
         end

*****0   user_config.background_colour = validate_highlight(user_config.background_colour, needs_opacity)

*****0   return config
       end

     8 return Config

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/init.lua
==============================================================================
       ---@text
       --- A fancy, configurable notification manager for NeoVim

     8 local config = require("notify.config")
     8 local instance = require("notify.instance")

       ---@class notify
     8 local notify = {}

       local global_instance, global_config

       --- Configure nvim-notify
       ---    See: ~
       ---        |notify.Config|
       ---        |notify-render|
       ---
       ---@param user_config notify.Config|nil
       ---@eval return require('notify.config')._format_default()
     8 function notify.setup(user_config)
*****0   global_instance, global_config = notify.instance(user_config)
*****0   local has_telescope = (vim.fn.exists("g:loaded_telescope") == 1)
*****0   if has_telescope then
*****0     require("telescope").load_extension("notify")
         end
*****0   vim.cmd([[command! Notifications :lua require("notify")._print_history()<CR>]])
*****0   vim.cmd([[command! NotificationsClear :lua require("notify").clear_history()<CR>]])
       end

     8 function notify._config()
*****0   return config.setup(global_config)
       end

       ---@class notify.Options
       --- Options for an individual notification
       ---@field title string
       ---@field icon string
       ---@field timeout number|boolean Time to show notification in milliseconds, set to false to disable timeout.
       ---@field on_open function Callback for when window opens, receives window as argument.
       ---@field on_close function Callback for when window closes, receives window as argument.
       ---@field keep function Function to keep the notification window open after timeout, should return boolean.
       ---@field render function|string Function to render a notification buffer.
       ---@field replace integer|notify.Record Notification record or the record `id` field. Replace an existing notification if still open. All arguments not given are inherited from the replaced notification including message and level.
       ---@field hide_from_history boolean Hide this notification from the history
       ---@field animate boolean If false, the window will jump to the timed stage. Intended for use in blocking events (e.g. vim.fn.input)

       ---@class notify.Events
       --- Async events for a notification
       ---@field open function Resolves when notification is opened
       ---@field close function Resolved when notification is closed

       ---@class notify.Record
       --- Record of a previously sent notification
       ---@field id integer
       ---@field message string[] Lines of the message
       ---@field level string|integer Log level. See vim.log.levels
       ---@field title string[] Left and right sections of the title
       ---@field icon string Icon used for notification
       ---@field time number Time of message, as returned by `vim.fn.localtime()`
       ---@field render function Function to render notification buffer

       ---@class notify.AsyncRecord : notify.Record
       ---@field events notify.Events

       --- Display a notification.
       ---
       --- You can call the module directly rather than using this:
       --- >lua
       ---  require("notify")(message, level, opts)
       --- <
       ---@param message string|string[] Notification message
       ---@param level string|number Log level. See vim.log.levels
       ---@param opts notify.Options Notification options
       ---@return notify.Record
     8 function notify.notify(message, level, opts)
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.notify(message, level, opts)
       end

       --- Display a notification asynchronously
       ---
       --- This uses plenary's async library, allowing a cleaner interface for
       --- open/close events. You must call this function within an async context.
       ---
       --- The `on_close` and `on_open` options are not used.
       ---
       ---@param message string|string[] Notification message
       ---@param level string|number Log level. See vim.log.levels
       ---@param opts notify.Options Notification options
       ---@return notify.AsyncRecord
     8 function notify.async(message, level, opts)
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.async(message, level, opts)
       end

       --- Get records of all previous notifications
       ---
       --- You can use the `:Notifications` command to display a log of previous notifications
       ---@param opts? notify.HistoryOpts
       ---@return notify.Record[]
     8 function notify.history(opts)
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.history(opts)
       end

       ---@class notify.HistoryOpts
       ---@field include_hidden boolean Include notifications hidden from history

       --- Clear records of all previous notifications
       ---
       --- You can use the `:NotificationsClear` command to clear the log of previous notifications
     8 function notify.clear_history()
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.clear_history()
       end

       --- Dismiss all notification windows currently displayed
       ---@param opts notify.DismissOpts
     8 function notify.dismiss(opts)
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.dismiss(opts)
       end

       ---@class notify.DismissOpts
       ---@field pending boolean Clear pending notifications
       ---@field silent boolean Suppress notification that pending notifications were dismissed.

       --- Open a notification in a new buffer
       ---@param notif_id integer|notify.Record
       ---@param opts notify.OpenOpts
       ---@return notify.OpenedBuffer
     8 function notify.open(notif_id, opts)
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.open(notif_id, opts)
       end

       ---@class notify.OpenOpts
       ---@field buffer integer Use this buffer, instead of creating a new one
       ---@field max_width integer Render message to this width (used to limit window decoration sizes)

       ---@class notify.OpenedBuffer
       ---@field buffer integer Created buffer number
       ---@field height integer Height of the buffer content including extmarks
       ---@field width integer width of the buffer content including extmarks
       ---@field highlights table<string, string> Highlights used for the buffer contents

       --- Number of notifications currently waiting to be displayed
       ---@return integer[]
     8 function notify.pending()
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   return global_instance.pending()
       end

     8 function notify._print_history()
*****0   if not global_instance then
*****0     notify.setup()
         end
*****0   for _, notif in ipairs(global_instance.history()) do
*****0     vim.api.nvim_echo({
             {
*****0         vim.fn.strftime(notify._config().time_formats().notification_history, notif.time),
               "NotifyLogTime",
             },
*****0       { " ", "MsgArea" },
*****0       { notif.title[1], "NotifyLogTitle" },
*****0       { #notif.title[1] > 0 and " " or "", "MsgArea" },
*****0       { notif.icon, "Notify" .. notif.level .. "Title" },
*****0       { " ", "MsgArea" },
*****0       { notif.level, "Notify" .. notif.level .. "Title" },
*****0       { " ", "MsgArea" },
*****0       { table.concat(notif.message, "\n"), "MsgArea" },
*****0     }, false, {})
         end
       end

       --- Configure an instance of nvim-notify.
       --- You can use this to manage a separate instance of nvim-notify with completely different configuration.
       --- The returned instance will have the same functions as the notify module.
       ---@param user_config notify.Config
       ---@param inherit? boolean Inherit the global configuration, default true
     8 function notify.instance(user_config, inherit)
*****0   return instance(user_config, inherit, global_config)
       end

    16 setmetatable(notify, {
         __call = function(_, m, l, o)
   132     if vim.in_fast_event() or vim.fn.has("vim_starting") == 1 then
   132       vim.schedule(function()
*****0         notify.notify(m, l, o)
             end)
           else
*****0       return notify.notify(m, l, o)
           end
         end,
       })

     8 return notify

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/instance.lua
==============================================================================
     8 local stages = require("notify.stages")
     8 local config = require("notify.config")
     8 local Notification = require("notify.service.notification")
     8 local WindowAnimator = require("notify.windows")
     8 local NotificationService = require("notify.service")
     8 local NotificationBuf = require("notify.service.buffer")
     8 local stage_util = require("notify.stages.util")

     8 local notif_cmp_keys = {
         "level",
         "message",
         "title",
         "icon",
       }

       ---@param n1 notify.Notification
       ---@param n2 notify.Notification
       ---@return boolean
       local function notifications_equal(n1, n2)
*****0   for _, key in ipairs(notif_cmp_keys) do
*****0     local v1 = n1[key]
*****0     local v2 = n2[key]
           -- NOTE: Notification:new adds time string which causes not-equality, so compare only left title (1st element)
*****0     if key == "title" then
*****0       v1 = v1[1]
*****0       v2 = v2[1]
           end
*****0     if not vim.deep_equal(v1, v2) then
*****0       return false
           end
         end
*****0   return true
       end

       ---@param user_config notify.Config
       ---@param inherit? boolean Inherit the global configuration, default true
       ---@param global_config notify.Config
       return function(user_config, inherit, global_config)
         ---@type notify.Notification[]
*****0   local notifications = {}

*****0   user_config = user_config or {}
*****0   if inherit ~= false and global_config then
*****0     user_config = vim.tbl_deep_extend("force", global_config, user_config)
         end

*****0   local instance_config = config.setup(user_config)

*****0   local animator_stages = instance_config.stages()
*****0   local direction = instance_config.top_down() and stage_util.DIRECTION.TOP_DOWN
*****0     or stage_util.DIRECTION.BOTTOM_UP

*****0   animator_stages = type(animator_stages) == "string" and stages[animator_stages](direction)
*****0     or animator_stages
*****0   local animator = WindowAnimator(animator_stages, instance_config)
*****0   local service = NotificationService(instance_config, animator)

*****0   local instance = {}

         local function get_render(render)
*****0     if type(render) == "function" then
*****0       return render
           end
*****0     return require("notify.render")[render]
         end

         ---@param notif notify.Notification
         ---@return notify.Notification?
         local function find_duplicate(notif)
*****0     for _, buf in pairs(animator.notif_bufs) do
*****0       if notifications_equal(buf._notif, notif) then
*****0         return buf._notif
             end
           end
         end

*****0   function instance.notify(message, level, opts)
*****0     opts = opts or {}

*****0     if opts.replace then
*****0       if type(opts.replace) == "table" then
*****0         opts.replace = opts.replace.id
             end
*****0       local existing = notifications[opts.replace]
*****0       if not existing then
*****0         vim.notify("Invalid notification to replace", "error", { title = "nvim-notify" })
*****0         return
             end
*****0       local notif_keys = {
               "title",
               "icon",
               "timeout",
               "keep",
               "on_open",
               "on_close",
               "render",
               "hide_from_history",
               "animate",
             }
*****0       message = message or existing.message
*****0       level = level or existing.level
*****0       for _, key in ipairs(notif_keys) do
*****0         if opts[key] == nil then
*****0           opts[key] = existing[key]
               end
             end
           end

*****0     opts.render = get_render(opts.render or instance_config.render())
*****0     local id = #notifications + 1
*****0     local notification = Notification(id, message, level, opts, instance_config)
*****0     table.insert(notifications, notification)
*****0     local level_num = vim.log.levels[notification.level]

*****0     if not opts.replace and instance_config.merge_duplicates() then
*****0       local dup = find_duplicate(notification)
*****0       if dup then
*****0         dup.duplicates = dup.duplicates or { dup.id }
*****0         table.insert(dup.duplicates, notification.id)
*****0         notification.duplicates = dup.duplicates

*****0         local min_dups = instance_config.merge_duplicates()
*****0         if min_dups == true or #notification.duplicates >= min_dups + 1 then
*****0           opts.replace = dup.id
               end
             end
           end

*****0     if opts.replace then
*****0       service:replace(opts.replace, notification)
*****0     elseif not level_num or level_num >= instance_config.level() then
*****0       service:push(notification)
           end
*****0     return {
             id = id,
           }
         end

         ---@param notif_id integer|notify.Record
         ---@param opts table
*****0   function instance.open(notif_id, opts)
*****0     opts = opts or {}
*****0     if type(notif_id) == "table" then
*****0       notif_id = notif_id.id
           end
*****0     local notif = notifications[notif_id]
*****0     if not notif then
*****0       vim.notify(
*****0         "Invalid notification id: " .. notif_id,
*****0         vim.log.levels.WARN,
*****0         { title = "nvim-notify" }
             )
*****0       return
           end
*****0     local buf = opts.buffer or vim.api.nvim_create_buf(false, true)
           local notif_buf =
*****0       NotificationBuf(buf, notif, vim.tbl_extend("keep", opts, { config = instance_config }))
*****0     notif_buf:render()
*****0     return {
             buffer = buf,
             height = notif_buf:height(),
             width = notif_buf:width(),
*****0       highlights = {
               body = notif_buf.highlights.body,
               border = notif_buf.highlights.border,
               title = notif_buf.highlights.title,
               icon = notif_buf.highlights.icon,
             },
           }
         end

*****0   function instance.async(message, level, opts)
*****0     opts = opts or {}
*****0     local async = require("plenary.async")
*****0     local send_close, wait_close = async.control.channel.oneshot()
*****0     opts.on_close = send_close

*****0     local send_open, wait_open = async.control.channel.oneshot()
*****0     opts.on_open = send_open

*****0     async.util.scheduler()
*****0     local record = instance.notify(message, level, opts)
*****0     return vim.tbl_extend("error", record, {
*****0       events = {
               open = wait_open,
               close = wait_close,
             },
           })
         end

*****0   function instance.history(args)
*****0     args = args or {}
*****0     local records = {}
*****0     for _, notif in ipairs(notifications) do
*****0       if not notif.hide_from_history or args.include_hidden then
*****0         records[#records + 1] = notif:record()
             end
           end
*****0     return records
         end

*****0   function instance.dismiss(opts)
*****0     if service then
*****0       service:dismiss(opts or {})
           end
         end

*****0   function instance.pending()
*****0     return service and service:pending() or {}
         end

*****0   function instance.clear_history()
*****0     notifications = {}
         end

*****0   setmetatable(instance, {
           __call = function(_, m, l, o)
*****0       if vim.in_fast_event() then
*****0         vim.schedule(function()
*****0           instance.notify(m, l, o)
               end)
             else
*****0         return instance.notify(m, l, o)
             end
           end,
         })
*****0   return instance, instance_config.merged()
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/service/buffer/highlights.lua
==============================================================================
     8 local util = require("notify.util")

       ---@class NotifyBufHighlights
       ---@field groups table
       ---@field opacity number
       ---@field title string
       ---@field border string
       ---@field icon string
       ---@field body string
       ---@field buffer number
       ---@field _config table
     8 local NotifyBufHighlights = {}

     8 function NotifyBufHighlights:new(level, buffer, config)
         local function linked_group(section)
*****0     local orig = "Notify" .. level .. section
*****0     if vim.fn.hlID(orig) == 0 then
*****0       orig = "NotifyINFO" .. section
           end
*****0     local new = orig .. buffer

*****0     vim.api.nvim_set_hl(0, new, { link = orig })
*****0     local hl = vim.api.nvim_get_hl(0, { name = orig, create = false, link = false })
           -- Removes the unwanted 'default' key, as we will copy the table for updating the highlight later.
*****0     hl.default = nil

*****0     return new, hl
         end

*****0   local title, title_def = linked_group("Title")
*****0   local border, border_def = linked_group("Border")
*****0   local body, body_def = linked_group("Body")
*****0   local icon, icon_def = linked_group("Icon")

*****0   local groups = {
           [title] = title_def,
           [border] = border_def,
           [body] = body_def,
           [icon] = icon_def,
         }
*****0   local buf_highlights = {
           groups = groups,
           opacity = 100,
           border = border,
           body = body,
           title = title,
           icon = icon,
           buffer = buffer,
           _config = config,
         }
*****0   self.__index = self
*****0   setmetatable(buf_highlights, self)
*****0   return buf_highlights
       end

     8 function NotifyBufHighlights:_redefine_treesitter()
*****0   local buf_highlighter = require("vim.treesitter.highlighter").active[self.buffer]

*****0   if not buf_highlighter then
*****0     return
         end
*****0   local render_namespace = vim.api.nvim_create_namespace("notify-treesitter-override")
*****0   vim.api.nvim_buf_clear_namespace(self.buffer, render_namespace, 0, -1)

         local function link(orig)
*****0     local new = orig .. self.buffer
*****0     if self.groups[new] then
*****0       return new
           end
*****0     vim.api.nvim_set_hl(0, new, { link = orig })
*****0     self.groups[new] = vim.api.nvim_get_hl(0, { name = new, link = false })
*****0     return new
         end

*****0   local matches = {}

*****0   local i = 0
*****0   buf_highlighter.tree:for_each_tree(function(tstree, tree)
*****0     if not tstree then
*****0       return
           end

*****0     local root = tstree:root()

*****0     local query = buf_highlighter:get_query(tree:lang())

           -- Some injected languages may not have highlight queries.
*****0     if not query:query() then
*****0       return
           end

*****0     local iter = query:query():iter_captures(root, buf_highlighter.bufnr)

*****0     for capture, node, metadata in iter do
             -- Wait until we get at least a single capture as we don't know when parsing is complete.
*****0       self._treesitter_redefined = true
*****0       local hl = query.hl_cache[capture]

*****0       if hl then
*****0         i = i + 1
*****0         local c = query._query.captures[capture] -- name of the capture in the query
*****0         if c ~= nil then
                 local capture_hl
                 -- Removed in nightly with change of highlight names to @...
                 -- https://github.com/neovim/neovim/pull/19931
*****0           if query._get_hl_from_capture then
*****0             local general_hl, is_vim_hl = query:_get_hl_from_capture(capture)
*****0             capture_hl = is_vim_hl and general_hl or (tree:lang() .. general_hl)
                 else
*****0             capture_hl = query._query.captures[capture]
*****0             if not vim.startswith(capture_hl, "_") then
*****0               capture_hl = "@" .. capture_hl .. "." .. tree:lang()
                   end
                 end

*****0           local start_row, start_col, end_row, end_col = node:range()
*****0           local custom_hl = link(capture_hl)

*****0           vim.api.nvim_buf_set_extmark(self.buffer, render_namespace, start_row, start_col, {
                   end_row = end_row,
                   end_col = end_col,
                   hl_group = custom_hl,
                   -- TODO: Not sure how neovim's highlighter doesn't have issues with overriding highlights
                   -- Three marks on same region always show the second for some reason AFAICT
                   priority = tonumber(metadata.priority) or i + 200,
                   conceal = metadata.conceal,
                 })
               end
             end
           end
*****0   end, true)
*****0   return matches
       end

     8 function NotifyBufHighlights:set_opacity(alpha)
         if
*****0     not self._treesitter_redefined
*****0     and vim.api.nvim_get_option_value("filetype", { buf = self.buffer }) ~= "notify"
         then
*****0     self:_redefine_treesitter()
         end
*****0   self.opacity = alpha
*****0   local background = self._config.background_colour()
*****0   local updated = false
*****0   for group, fields in pairs(self.groups) do
*****0     local fg = fields.fg
*****0     if fg then
*****0       fg = util.blend(fg, background, alpha / 100)
           end
*****0     local bg = fields.bg
*****0     if bg then
*****0       bg = util.blend(bg, background, alpha / 100)
           end

*****0     if fg ~= fields.fg or bg ~= fields.bg then
*****0       local hl = vim.tbl_extend("force", fields, { fg = fg, bg = bg })
*****0       vim.api.nvim_set_hl(0, group, hl)
*****0       updated = true
           end
         end
*****0   return updated
       end

     8 function NotifyBufHighlights:get_opacity()
*****0   return self.opacity
       end

       ---@return NotifyBufHighlights
       return function(level, buffer, config)
*****0   return NotifyBufHighlights:new(level, buffer, config)
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/service/buffer/init.lua
==============================================================================
     8 local api = vim.api

     8 local NotifyBufHighlights = require("notify.service.buffer.highlights")

       ---@class NotificationBuf
       ---@field highlights NotifyBufHighlights
       ---@field _config table
       ---@field _notif notify.Notification
       ---@field _state "open" | "closed"
       ---@field _buffer number
       ---@field _height number
       ---@field _width number
       ---@field _max_width number | nil
     8 local NotificationBuf = {}

     8 local BufState = {
         OPEN = "open",
         CLOSED = "close",
       }

     8 function NotificationBuf:new(kwargs)
*****0   local notif_buf = {
           _config = kwargs.config,
           _max_width = kwargs.max_width,
           _buffer = kwargs.buffer,
           _state = BufState.CLOSED,
           _width = 0,
           _height = 0,
         }
*****0   setmetatable(notif_buf, self)
*****0   self.__index = self
*****0   notif_buf:set_notification(kwargs.notif)
*****0   return notif_buf
       end

     8 function NotificationBuf:set_notification(notif)
*****0   self._notif = notif
*****0   self:_create_highlights()
       end

     8 function NotificationBuf:_create_highlights()
*****0   local existing_opacity = self.highlights and self.highlights.opacity or 100
*****0   self.highlights = NotifyBufHighlights(self._notif.level, self._buffer, self._config)
*****0   if existing_opacity < 100 then
*****0     self.highlights:set_opacity(existing_opacity)
         end
       end

     8 function NotificationBuf:open(win)
*****0   if self._state ~= BufState.CLOSED then
*****0     return
         end
*****0   self._state = BufState.OPEN
*****0   local record = self._notif:record()
*****0   if self._notif.on_open then
*****0     self._notif.on_open(win, record)
         end
*****0   if self._config.on_open() then
*****0     self._config.on_open()(win, record)
         end
       end

     8 function NotificationBuf:should_animate()
*****0   return self._notif.animate
       end

     8 function NotificationBuf:close(win)
*****0   if self._state ~= BufState.OPEN then
*****0     return
         end
*****0   self._state = BufState.CLOSED
*****0   vim.schedule(function()
*****0     if self._notif.on_close then
*****0       self._notif.on_close(win)
           end
*****0     if self._config.on_close() then
*****0       self._config.on_close()(win)
           end
*****0     pcall(api.nvim_buf_delete, self._buffer, { force = true })
         end)
       end

     8 function NotificationBuf:height()
*****0   return self._height
       end

     8 function NotificationBuf:width()
*****0   return self._width
       end

     8 function NotificationBuf:should_stay()
*****0   if self._notif.keep then
*****0     return self._notif.keep()
         end
*****0   return false
       end

     8 function NotificationBuf:render()
*****0   local notif = self._notif
*****0   local buf = self._buffer

*****0   local render_namespace = require("notify.render.base").namespace()
*****0   api.nvim_buf_set_option(buf, "filetype", "notify")
*****0   api.nvim_buf_set_option(buf, "modifiable", true)
*****0   api.nvim_buf_clear_namespace(buf, render_namespace, 0, -1)

*****0   notif.render(buf, notif, self.highlights, self._config)

*****0   api.nvim_buf_set_option(buf, "modifiable", false)

*****0   local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
*****0   local width = self._config.minimum_width()
*****0   for _, line in pairs(lines) do
*****0     width = math.max(width, vim.api.nvim_strwidth(line))
         end
         local success, extmarks =
*****0     pcall(api.nvim_buf_get_extmarks, buf, render_namespace, 0, #lines, { details = true })
*****0   if not success then
*****0     extmarks = {}
         end
*****0   local virt_texts = {}
*****0   for _, mark in ipairs(extmarks) do
*****0     local details = mark[4]
*****0     for _, virt_text in ipairs(details.virt_text or {}) do
*****0       virt_texts[mark[2]] = (virt_texts[mark[2]] or "") .. virt_text[1]
           end
         end
*****0   for _, text in pairs(virt_texts) do
*****0     width = math.max(width, vim.api.nvim_strwidth(text))
         end

*****0   self._width = width
*****0   self._height = #lines
       end

     8 function NotificationBuf:timeout()
*****0   return self._notif.timeout
       end

     8 function NotificationBuf:buffer()
*****0   return self._buffer
       end

     8 function NotificationBuf:is_valid()
*****0   return self._buffer and vim.api.nvim_buf_is_valid(self._buffer)
       end

     8 function NotificationBuf:level()
*****0   return self._notif.level
       end

       ---@param buf number
       ---@param notification notify.Notification;q
       ---@return NotificationBuf
       return function(buf, notification, opts)
*****0   return NotificationBuf:new(
*****0     vim.tbl_extend("keep", { buffer = buf, notif = notification }, opts or {})
         )
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/service/init.lua
==============================================================================
     8 local util = require("notify.util")
     8 local NotificationBuf = require("notify.service.buffer")

       ---@class NotificationService
       ---@field private _running boolean
       ---@field private _pending FIFOQueue
       ---@field private _animator WindowAnimator
       ---@field private _buffers table<integer, NotificationBuf>
       ---@field private _fps integer
     8 local NotificationService = {}

       ---@class notify.ServiceConfig
       ---@field fps integer

       ---@param config notify.ServiceConfig
     8 function NotificationService:new(config, animator)
*****0   local service = {
           _config = config,
           _fps = config.fps(),
           _animator = animator,
           _pending = util.FIFOQueue(),
           _running = false,
           _buffers = {},
         }
*****0   self.__index = self
*****0   setmetatable(service, self)
*****0   return service
       end

     8 function NotificationService:_run()
*****0   self._running = true
         local succees, updated =
*****0     pcall(self._animator.render, self._animator, self._pending, 1 / self._fps)
*****0   if not succees then
*****0     print("Error running notification service: " .. updated)
*****0     self._running = false
*****0     return
         end
*****0   if not updated then
*****0     self._running = false
*****0     return
         end
*****0   vim.defer_fn(function()
*****0     self:_run()
*****0   end, 1000 / self._fps)
       end

       ---@param notif notify.Notification;q
       ---@return integer
     8 function NotificationService:push(notif)
*****0   local buf = vim.api.nvim_create_buf(false, true)
*****0   local notif_buf = NotificationBuf(buf, notif, { config = self._config })
*****0   notif_buf:render()
*****0   self._buffers[notif.id] = notif_buf
*****0   self._pending:push(notif_buf)
*****0   if not self._running then
*****0     self:_run()
         end
*****0   return buf
       end

     8 function NotificationService:replace(id, notif)
*****0   local existing = self._buffers[id]
*****0   if not (existing and existing:is_valid()) then
*****0     vim.notify("No matching notification found to replace")
*****0     return
         end
*****0   existing:set_notification(notif)
*****0   self._buffers[id] = nil
*****0   self._buffers[notif.id] = existing
*****0   pcall(existing.render, existing)
*****0   local win = vim.fn.bufwinid(existing:buffer())
*****0   if win ~= -1 then
           -- Highlights can change name if level changed so we have to re-link
           -- vim.wo does not behave like setlocal, thus we use setwinvar to set a
           -- local option. Otherwise our changes would affect subsequently opened
           -- windows.
           -- see e.g. neovim#14595
*****0     vim.fn.setwinvar(
             win,
             "&winhl",
*****0       "Normal:" .. existing.highlights.body .. ",FloatBorder:" .. existing.highlights.border
           )

*****0     vim.api.nvim_win_set_width(win, existing:width())
*****0     vim.api.nvim_win_set_height(win, existing:height())

*****0     self._animator:on_refresh(win)
         end
       end

     8 function NotificationService:dismiss(opts)
*****0   local notif_wins = vim.tbl_keys(self._animator.win_stages)
*****0   for _, win in pairs(notif_wins) do
*****0     pcall(vim.api.nvim_win_close, win, true)
         end
*****0   if opts.pending then
*****0     local cleared = 0
*****0     while self._pending:pop() do
*****0       cleared = cleared + 1
           end
*****0     if not opts.silent then
*****0       vim.notify("Cleared " .. cleared .. " pending notifications")
           end
         end
       end

     8 function NotificationService:pending()
*****0   return self._pending:length()
       end

       ---@return NotificationService
       return function(config, animator)
*****0   return NotificationService:new(config, animator)
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/service/notification.lua
==============================================================================
       ---@class notify.Notification
       ---@field id integer
       ---@field level string
       ---@field message string[]
       ---@field timeout number | nil
       ---@field title string[]
       ---@field icon string
       ---@field time number
       ---@field width number
       ---@field animate boolean
       ---@field hide_from_history boolean
       ---@field keep fun(): boolean
       ---@field on_open fun(win: number, record: notify.Record) | nil
       ---@field on_close fun(win: number, record: notify.Record) | nil
       ---@field render fun(buf: integer, notification: notify.Notification, highlights: table<string, string>)
       ---@field duplicates? integer[] shared list of duplicate notifications by id
     8 local Notification = {}

     8 local level_maps = vim.tbl_extend("keep", {}, vim.log.levels)
    56 for k, v in pairs(vim.log.levels) do
    48   level_maps[v] = k
       end

     8 function Notification:new(id, message, level, opts, config)
*****0   if type(level) == "number" then
*****0     level = level_maps[level]
         end
*****0   if type(message) == "string" then
*****0     message = vim.split(message, "\n")
         end
*****0   level = vim.fn.toupper(level or "info")
*****0   local time = vim.fn.localtime()
*****0   local title = opts.title or ""
*****0   if type(title) == "string" then
*****0     title = { title, vim.fn.strftime(config.time_formats().notification, time) }
         end
*****0   vim.validate({
           message = { message, "table" },
           level = { level, "string" },
           title = { title, "table" },
         })
*****0   local notif = {
           id = id,
           message = message,
           title = title,
           icon = opts.icon or config.icons()[level] or config.icons().INFO,
           time = time,
           timeout = opts.timeout,
           level = level,
           keep = opts.keep,
           on_open = opts.on_open,
           on_close = opts.on_close,
           animate = opts.animate ~= false,
           render = opts.render,
           hide_from_history = opts.hide_from_history,
           duplicates = opts.duplicates,
         }
*****0   self.__index = self
*****0   setmetatable(notif, self)
*****0   return notif
       end

     8 function Notification:record()
*****0   return {
           id = self.id,
           message = self.message,
           level = self.level,
           time = self.time,
           title = self.title,
           icon = self.icon,
           render = self.render,
         }
       end

       ---@param message string | string[]
       ---@param level string | number
       ---@param opts notify.Options
       return function(id, message, level, opts, config)
*****0   return Notification:new(id, message, level, opts, config)
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/stages/init.lua
==============================================================================
     8 local M = {}

       ---@class MessageState
       ---@field width number
       ---@field height number

       ---@alias InitStage fun(open_windows: number[], message_state: MessageState): table | nil
       ---@alias AnimationStage fun(win: number, message_state: MessageState): table

       ---@alias Stage InitStage | AnimationStage
       ---@alias Stages Stage[]

    16 setmetatable(M, {
         ---@return Stages
         __index = function(_, key)
*****0     return require("notify.stages." .. key)
         end,
       })

     8 return M

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/stages/util.lua
==============================================================================
     8 local max, min = math.max, math.min
     8 local util = require("notify.util")

     8 local M = {}

     8 M.DIRECTION = {
         TOP_DOWN = "top_down",
         BOTTOM_UP = "bottom_up",
         LEFT_RIGHT = "left_right",
         RIGHT_LEFT = "right_left",
     8 }

       local function is_increasing(direction)
*****0   return (direction == M.DIRECTION.TOP_DOWN or direction == M.DIRECTION.LEFT_RIGHT)
       end

       local function moves_vertically(direction)
*****0   return (direction == M.DIRECTION.TOP_DOWN or direction == M.DIRECTION.BOTTOM_UP)
       end

     8 function M.slot_name(direction)
*****0   if moves_vertically(direction) then
*****0     return "height"
         end
*****0   return "width"
       end

       local function less(a, b)
*****0   return a < b
       end

       local function greater(a, b)
*****0   return a > b
       end

       local function overlaps(a, b)
*****0   return a.min <= b.max and b.min <= a.max
       end

       local move_slot = function(direction, slot, delta)
*****0   if is_increasing(direction) then
*****0     return slot + delta
         end
*****0   return slot - delta
       end

       local function slot_key(direction)
*****0   return moves_vertically(direction) and "row" or "col"
       end

       local function space_key(direction)
*****0   return moves_vertically(direction) and "height" or "width"
       end

       -- TODO: Use direction to check border lists
       local function border_padding(direction, win_conf)
*****0   if not win_conf.border or win_conf.border == "none" then
*****0     return 0
         end
*****0   return 2
       end

       ---@param windows number[]
       ---@param direction string
       ---@return { max: integer, min: integer}[]
       local function window_intervals(windows, direction, cmp)
*****0   local win_intervals = {}
*****0   for _, w in ipairs(windows) do
*****0     local exists, existing_conf = util.get_win_config(w)
*****0     if exists then
*****0       local border_space = border_padding(direction, existing_conf)
*****0       win_intervals[#win_intervals + 1] = {
               min = existing_conf[slot_key(direction)],
*****0         max = existing_conf[slot_key(direction)]
*****0           + existing_conf[space_key(direction)]
*****0           + border_space
*****0           - 1,
             }
           end
         end
*****0   table.sort(win_intervals, function(a, b)
*****0     return cmp(a.min, b.min)
         end)
*****0   return win_intervals
       end

     8 function M.get_slot_range(direction)
*****0   local top = 0
*****0   if vim.o.showtabline == 2 or (vim.o.showtabline == 1 and vim.fn.tabpagenr("$") > 1) then
*****0     top = 1
         end
*****0   if vim.wo.winbar ~= '' then
*****0     top = top + 1
         end

*****0   local bottom = vim.opt.lines:get()
*****0     - (vim.opt.cmdheight:get() + (vim.opt.laststatus:get() > 0 and 1 or 0) + 1)
*****0   local left = 1
*****0   local right = vim.opt.columns:get()
*****0   if M.DIRECTION.TOP_DOWN == direction then
*****0     return top, bottom
*****0   elseif M.DIRECTION.BOTTOM_UP == direction then
*****0     return bottom, top
*****0   elseif M.DIRECTION.LEFT_RIGHT == direction then
*****0     return left, right
*****0   elseif M.DIRECTION.RIGHT_LEFT == direction then
*****0     return right, left
         end
*****0   error(string.format("Invalid direction: %s", direction))
       end

       ---@param existing_wins number[] Windows to avoid overlapping
       ---@param required_space number Window height or width including borders
       ---@param direction string Direction to stack windows, one of M.DIRECTION
       ---@return number | nil Slot to place window at or nil if no slot available
     8 function M.available_slot(existing_wins, required_space, direction)
*****0   local increasing = is_increasing(direction)
*****0   local cmp = increasing and less or greater
*****0   local first_slot, last_slot = M.get_slot_range(direction)

         local function create_interval(start_slot)
*****0     local end_slot = move_slot(direction, start_slot, required_space - 1)
*****0     return { min = min(start_slot, end_slot), max = max(start_slot, end_slot) }
         end

*****0   local interval = create_interval(first_slot)

*****0   local intervals = window_intervals(existing_wins, direction, cmp)

*****0   for _, next_interval in ipairs(intervals) do
*****0     if overlaps(next_interval, interval) then
*****0       interval = create_interval(
*****0         move_slot(direction, increasing and next_interval.max or next_interval.min, 1)
             )
           end
         end

*****0   if #intervals > 0 and not cmp(is_increasing and interval.max or interval.min, last_slot) then
*****0     return nil
         end

*****0   return interval.min
       end

       ---Gets the next slot available for the given window while maintaining its position using the given list.
       ---@param win number
       ---@param open_windows number[]
       ---@param direction string
     8 function M.slot_after_previous(win, open_windows, direction)
*****0   local key = slot_key(direction)
*****0   local cmp = is_increasing(direction) and less or greater
*****0   local exists, cur_win_conf = util.get_win_config(win)
*****0   if not exists then
*****0     return 0
         end

*****0   local cur_slot = cur_win_conf[key]
*****0   local win_confs = {}
*****0   for _, w in ipairs(open_windows) do
*****0     local success, conf = util.get_win_config(w)
*****0     if success then
*****0       win_confs[w] = conf
           end
         end

*****0   local preceding_wins = vim.tbl_filter(function(open_win)
*****0     return win_confs[open_win] and cmp(win_confs[open_win][key], cur_slot)
*****0   end, open_windows)

*****0   if #preceding_wins == 0 then
*****0     local start = M.get_slot_range(direction)
*****0     if is_increasing(direction) then
*****0       return start
           end
*****0     return move_slot(
             direction,
             start,
*****0       cur_win_conf[space_key(direction)] + border_padding(direction, cur_win_conf) / 2
           )
         end

*****0   table.sort(preceding_wins, function(a, b)
*****0     return cmp(win_confs[a][key], win_confs[b][key])
         end)

*****0   local last_win = preceding_wins[#preceding_wins]
*****0   local last_win_conf = win_confs[last_win]

*****0   if is_increasing(direction) then
*****0     return move_slot(
             direction,
*****0       last_win_conf[key],
*****0       last_win_conf[space_key(direction)] + border_padding(direction, last_win_conf)
           )
         else
*****0     return move_slot(
             direction,
*****0       last_win_conf[key],
*****0       cur_win_conf[space_key(direction)] + border_padding(direction, cur_win_conf)
           )
         end
       end

     8 return M

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/util/init.lua
==============================================================================
     8 local M = {}

     8 local min, max, floor = math.min, math.max, math.floor
     8 local rshift, lshift, band, bor = bit.rshift, bit.lshift, bit.band, bit.bor
     8 local strwidth = vim.api.nvim_strwidth or vim.fn.strchars

     8 function M.is_callable(obj)
*****0   return type(obj) == "function" or (type(obj) == "table" and obj.__call)
       end

     8 function M.lazy_require(require_path)
*****0   return setmetatable({}, {
           __call = function(_, ...)
*****0       return require(require_path)(...)
           end,
           __index = function(_, key)
*****0       return require(require_path)[key]
           end,
           __newindex = function(_, key, value)
*****0       require(require_path)[key] = value
           end,
         })
       end

     8 function M.pop(tbl, key, default)
*****0   local val = default
*****0   if tbl[key] then
*****0     val = tbl[key]
*****0     tbl[key] = nil
         end
*****0   return val
       end

     8 function M.blend(fg_hex, bg_hex, alpha)
*****0   local segment = 0xFF0000
*****0   local result = 0
*****0   for i = 2, 0, -1 do
*****0     local blended = alpha * rshift(band(fg_hex, segment), i * 8)
*****0       + (1 - alpha) * rshift(band(bg_hex, segment), i * 8)

*****0     result = bor(lshift(result, 8), floor((min(max(blended, 0), 255)) + 0.5))
*****0     segment = rshift(segment, 8)
         end

*****0   return result
       end

     8 function M.round(num, decimals)
*****0   if decimals then
*****0     return tonumber(string.format("%." .. decimals .. "f", num))
         end
*****0   return math.floor(num + 0.5)
       end

     8 function M.partial(func, ...)
*****0   local args = { ... }
         return function(...)
*****0     local final = {}
*****0     vim.list_extend(final, args)
*****0     vim.list_extend(final, { ... })
*****0     return func(unpack(final))
         end
       end

     8 function M.get_win_config(win)
*****0   local success, conf = pcall(vim.api.nvim_win_get_config, win)
*****0   if not success or not conf.row then
*****0     return false, conf
         end
*****0   if type(conf.row) == "table" then
*****0     conf.row = conf.row[false]
         end
*****0   if type(conf.col) == "table" then
*****0     conf.col = conf.col[false]
         end
*****0   return success, conf
       end

     8 function M.open_win(notif_buf, enter, opts)
*****0   local win = vim.api.nvim_open_win(notif_buf:buffer(), enter, opts)
         -- vim.wo does not behave like setlocal, thus we use setwinvar to set local
         -- only options. Otherwise our changes would affect subsequently opened
         -- windows.
         -- see e.g. neovim#14595
*****0   vim.fn.setwinvar(
           win,
           "&winhl",
*****0     "Normal:" .. notif_buf.highlights.body .. ",FloatBorder:" .. notif_buf.highlights.border
         )
*****0   vim.fn.setwinvar(win, "&wrap", 0)
*****0   return win
       end

     8 M.FIFOQueue = require("notify.util.queue")

     8 function M.rgb_to_numbers(s)
*****0   local colours = {}
*****0   for a in string.gmatch(s, "[A-Fa-f0-9][A-Fa-f0-9]") do
*****0     colours[#colours + 1] = tonumber(a, 16)
         end
*****0   return colours
       end

     8 function M.numbers_to_rgb(colours)
*****0   local colour = "#"
*****0   for _, num in pairs(colours) do
*****0     colour = colour .. string.format("%X", num)
         end
*****0   return colour
       end

     8 function M.highlight(name, fields)
*****0   local fields_string = ""
*****0   for field, value in pairs(fields) do
*****0     fields_string = fields_string .. " " .. field .. "=" .. value
         end
*****0   if fields_string ~= "" then
*****0     vim.cmd("hi " .. name .. fields_string)
         end
       end

       --- Calculate the max render width of a message
       ---@param msg string[]|nil
       ---@return integer
     8 function M.max_line_width(msg)
*****0   local width = 0

*****0   if msg then
*****0     for i = 1, #msg do
*****0       width = max(width, strwidth(msg[i]))
           end
         end

*****0   return width
       end

     8 return M

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/util/queue.lua
==============================================================================
       ---@class FIFOQueue
     8 local FIFOQueue = {}

     8 function FIFOQueue:pop()
*****0   if self:is_empty() then
*****0     return nil
         end
*****0   local r = self[self.pop_from]
*****0   self[self.pop_from] = nil
*****0   self.pop_from = self.pop_from - 1
*****0   return r
       end

     8 function FIFOQueue:peek()
*****0   return self[self.pop_from]
       end

     8 function FIFOQueue:push(val)
*****0   self[self.push_to] = val
*****0   self.push_to = self.push_to - 1
       end

     8 function FIFOQueue:is_empty()
*****0   return self:length() == 0
       end

     8 function FIFOQueue:length()
*****0   return self.pop_from - self.push_to
       end

     8 function FIFOQueue:iter()
*****0   local i = self.pop_from + 1
         return function()
*****0     if i > self.push_to + 1 then
*****0       i = i - 1
*****0       return self[i]
           end
         end
       end

     8 function FIFOQueue:new()
*****0   local queue = {
           pop_from = 1,
           push_to = 1,
         }
*****0   self.__index = self
*****0   setmetatable(queue, self)
*****0   return queue
       end

       ---@return FIFOQueue
       return function()
*****0   return FIFOQueue:new()
       end

==============================================================================
/home/runner/.local/share/nvim/test/notify/lua/notify/windows/init.lua
==============================================================================
     8 local api = vim.api
     8 local animate = require("notify.animate")
     8 local util = require("notify.util")
     8 local round = util.round
     8 local max = math.max

       ---@class WindowAnimator
       ---@field config table
       ---@field win_states table<number, table<string, SpringState>>
       ---@field win_stages table<number, integer>
       ---@field notif_bufs table<number, NotificationBuf>
       ---@field timers table
       ---@field stages table
     8 local WindowAnimator = {}

     8 function WindowAnimator:new(stages, config)
*****0   local animator = {
           config = config,
           win_stages = {},
           win_states = {},
           notif_bufs = {},
           timers = {},
           stages = stages,
         }
*****0   self.__index = self
*****0   setmetatable(animator, self)
*****0   return animator
       end

     8 function WindowAnimator:render(queue, time)
*****0   self:push_pending(queue)
*****0   if vim.tbl_isempty(self.win_stages) then
*****0     return false
         end
*****0   local open_windows = vim.tbl_keys(self.win_stages)
*****0   for win, _ in pairs(self.win_stages) do
*****0     self:_update_window(time, win, open_windows)
         end
*****0   return true
       end

     8 function WindowAnimator:push_pending(queue)
*****0   if queue:is_empty() then
*****0     return
         end
*****0   while not queue:is_empty() do
           ---@type NotificationBuf
*****0     local notif_buf = queue:peek()
*****0     if not notif_buf:is_valid() then
*****0       queue:pop()
           else
*****0       local windows = vim.tbl_keys(self.win_stages)
*****0       local win_opts = self.stages[1]({
               message = self:_get_dimensions(notif_buf),
               open_windows = windows,
             })
*****0       if not win_opts then
*****0         return
             end
*****0       local opacity = util.pop(win_opts, "opacity")
*****0       if opacity then
*****0         notif_buf.highlights:set_opacity(opacity)
             end
*****0       win_opts.noautocmd = true
*****0       local win = util.open_win(notif_buf, false, win_opts)
*****0       vim.fn.setwinvar(
               win,
               "&winhl",
*****0         "Normal:" .. notif_buf.highlights.body .. ",FloatBorder:" .. notif_buf.highlights.border
             )
*****0       self.win_stages[win] = 2
*****0       self.win_states[win] = {}
*****0       self.notif_bufs[win] = notif_buf
*****0       queue:pop()
*****0       notif_buf:open(win)
           end
         end
       end

     8 function WindowAnimator:_advance_win_stage(win)
*****0   local cur_stage = self.win_stages[win]
*****0   if not cur_stage then
*****0     return
         end
*****0   if cur_stage < #self.stages then
*****0     if api.nvim_get_current_win() == win then
*****0       return
           end
*****0     self.win_stages[win] = cur_stage + 1
*****0     return
         end

*****0   self.win_stages[win] = nil

         local function close()
*****0     if api.nvim_get_current_win() == win then
*****0       return vim.defer_fn(close, 1000)
           end
*****0     self:_remove_win(win)
         end

*****0   close()
       end

     8 function WindowAnimator:_remove_win(win)
*****0   pcall(api.nvim_win_close, win, true)
*****0   self.win_stages[win] = nil
*****0   self.win_states[win] = nil
*****0   local notif_buf = self.notif_bufs[win]
*****0   self.notif_bufs[win] = nil
*****0   notif_buf:close(win)
       end

     8 function WindowAnimator:on_refresh(win)
*****0   local notif_buf = self.notif_bufs[win]
*****0   if not notif_buf then
*****0     return
         end
*****0   if self.timers[win] then
*****0     self.timers[win]:set_repeat(notif_buf:timeout() or self.config.default_timeout())
*****0     self.timers[win]:again()
         end
       end

     8 function WindowAnimator:_start_timer(win)
*****0   local buf_time = self.notif_bufs[win]:timeout() == nil and self.config.default_timeout()
*****0     or self.notif_bufs[win]:timeout()
*****0   if buf_time ~= false then
*****0     if buf_time == true then
*****0       buf_time = nil
           end
*****0     local timer = vim.loop.new_timer()
*****0     self.timers[win] = timer
*****0     timer:start(
             buf_time,
             buf_time,
*****0       vim.schedule_wrap(function()
*****0         timer:stop()
*****0         self.timers[win] = nil
*****0         local notif_buf = self.notif_bufs[win]
*****0         if notif_buf and notif_buf:should_stay() then
*****0           return
               end
*****0         self:_advance_win_stage(win)
             end)
           )
         end
       end

     8 function WindowAnimator:_update_window(time, win, open_windows)
*****0   local stage = self.win_stages[win]
*****0   local notif_buf = self.notif_bufs[win]
*****0   local win_goals = self:_get_win_goals(win, stage, open_windows)

*****0   if not win_goals then
*****0     self:_remove_win(win)
         end

         -- If we don't animate, then we move to all goals instantly.
         -- Can't just jump to the end, because we need to the intermediate changes
*****0   while
*****0     not notif_buf:should_animate()
*****0     and win_goals.time == nil
*****0     and self.win_stages[win] < #self.stages
         do
*****0     for field, goal in pairs(win_goals) do
*****0       if type(goal) == "table" then
*****0         win_goals[field] = goal[1]
             end
           end
*****0     self:_advance_win_state(win, win_goals, time)
*****0     self:_advance_win_stage(win)
*****0     stage = self.win_stages[win]
*****0     win_goals = self:_get_win_goals(win, stage, open_windows)
         end

*****0   if win_goals.time and not self.timers[win] then
*****0     self:_start_timer(win)
         end

*****0   self:_advance_win_state(win, win_goals, time)

*****0   if self:_is_complete(win, win_goals) and not win_goals.time then
*****0     self:_advance_win_stage(win)
         end
       end

     8 function WindowAnimator:_is_complete(win, goals)
*****0   local complete = true
*****0   local win_state = self.win_states[win]
*****0   if not win_state then
*****0     return true
         end
*****0   for field, goal in pairs(goals) do
*****0     if field ~= "time" then
*****0       if type(goal) == "table" then
*****0         if goal.complete then
*****0           complete = goal.complete(win_state[field].position)
               else
*****0           complete = goal[1] == round(win_state[field].position, 2)
               end
             end
*****0       if not complete then
               break
             end
           end
         end
*****0   return complete
       end

     8 function WindowAnimator:_advance_win_state(win, goals, time)
*****0   local win_state = self.win_states[win]

*****0   local win_configs = {}

         local function win_conf(win_)
*****0     if win_configs[win_] then
*****0       return win_configs[win_]
           end
*****0     local exists, conf = util.get_win_config(win_)
*****0     if not exists then
*****0       self:_remove_win(win_)
*****0       return
           end
*****0     win_configs[win_] = conf
*****0     return conf
         end

*****0   for field, goal in pairs(goals) do
*****0     if field ~= "time" then
*****0       local goal_type = type(goal)
             -- Handle spring goal
*****0       if goal_type == "table" and goal[1] then
*****0         if not win_state[field] then
*****0           if field == "opacity" then
*****0             win_state[field] = { position = self.notif_bufs[win].highlights:get_opacity() }
                 else
*****0             local conf = win_conf(win)
*****0             if not conf then
*****0               return true
                   end
*****0             win_state[field] = { position = conf[field] }
                 end
               end
*****0         animate.spring(time, goal[1], win_state[field], goal.frequency or 1, goal.damping or 1)
               --- Directly move goal
*****0       elseif goal_type ~= "table" then
*****0         win_state[field] = { position = goal }
             else
*****0         error("nvim-notify: Invalid stage goal: " .. vim.inspect(goal))
             end
           end
         end

*****0   return self:_apply_win_state(win, win_state)
       end

     8 function WindowAnimator:_get_win_goals(win, win_stage, open_windows)
*****0   local notif_buf = self.notif_bufs[win]
*****0   local win_goals = self.stages[win_stage]({
           buffer = notif_buf:buffer(),
           message = self:_get_dimensions(notif_buf),
           open_windows = open_windows,
*****0   }, win)
*****0   return win_goals
       end

     8 function WindowAnimator:_get_dimensions(notif_buf)
*****0   return {
           height = math.min(self.config.max_height() or 1000, notif_buf:height()),
           width = math.min(self.config.max_width() or 1000, notif_buf:width()),
         }
       end

     8 function WindowAnimator:_apply_win_state(win, win_state)
*****0   local hl_updated = false
*****0   if win_state.opacity then
*****0     local notif_buf = self.notif_bufs[win]
*****0     if notif_buf:is_valid() then
*****0       hl_updated = notif_buf.highlights:set_opacity(win_state.opacity.position)
*****0       vim.fn.setwinvar(
               win,
               "&winhl",
*****0         "Normal:" .. notif_buf.highlights.body .. ",FloatBorder:" .. notif_buf.highlights.border
             )
           end
         end
*****0   local exists, conf = util.get_win_config(win)
*****0   local new_conf = {}
*****0   local win_updated = false
*****0   if not exists then
*****0     self:_remove_win(win)
         else
           local function set_field(field, min, round_to)
*****0       if not win_state[field] then
*****0         return
             end
*****0       local new_value = max(round(win_state[field].position, round_to), min)
*****0       if new_value == conf[field] then
*****0         return
             end
*****0       win_updated = true
*****0       new_conf[field] = new_value
           end

*****0     set_field("row", 0, 1)
*****0     set_field("col", 0, 1)
*****0     set_field("width", 1)
*****0     set_field("height", 1)

*****0     if win_updated then
*****0       if new_conf.row or new_conf.col then
*****0         new_conf.relative = conf.relative
*****0         new_conf.row = new_conf.row or conf.row
*****0         new_conf.col = new_conf.col or conf.col
             end
*****0       api.nvim_win_set_config(win, new_conf)
           end
         end
         -- The 'flush' key is set to enforce redrawing during blocking event.
*****0   pcall(vim.api.nvim__redraw, { win = win, valid = false, flush = true })
*****0   return hl_updated or win_updated
       end

       ---@return WindowAnimator
       return function(stages, config)
*****0   return WindowAnimator:new(stages, config)
       end

==============================================================================
/home/runner/.local/share/nvim/test/plenary/lua/plenary/bit.lua
==============================================================================
       -- Shortcircuit to returning bit if it already exists
     8 if bit then return bit end

       --[[

       Credit: https://github.com/davidm/lua-bit-numberlua/blob/master/lmod/bit/numberlua.lua

       LUA MODULE

         bit.numberlua - Bitwise operations implemented in pure Lua as numbers,
           with Lua 5.2 'bit32' and (LuaJIT) LuaBitOp 'bit' compatibility interfaces.

       SYNOPSIS

         local bit = require 'bit.numberlua'
         print(bit.band(0xff00ff00, 0x00ff00ff)) --> 0xffffffff

         -- Interface providing strong (LuaJIT) LuaBitOp 'bit' compatibility
         local bit = require 'plenary.bit'
         assert(bit.tobit(0xffffffff) == -1)

         REMOVED!
         -- Interface providing strong Lua 5.2 'bit32' compatibility
         local bit32 = require 'bit.numberlua'.bit32
         assert(bit32.band(-1) == 0xffffffff)


       DESCRIPTION

         This library implements bitwise operations entirely in Lua.
         This module is typically intended if for some reasons you don't want
         to or cannot  install a popular C based bit library like BitOp 'bit' [1]
         (which comes pre-installed with LuaJIT) or 'bit32' (which comes
         pre-installed with Lua 5.2) but want a similar interface.

         This modules represents bit arrays as non-negative Lua numbers. [1]
         It can represent 32-bit bit arrays when Lua is compiled
         with lua_Number as double-precision IEEE 754 floating point.

         The module is nearly the most efficient it can be but may be a few times
         slower than the C based bit libraries and is orders or magnitude
         slower than LuaJIT bit operations, which compile to native code.  Therefore,
         this library is inferior in performane to the other modules.

         The `xor` function in this module is based partly on Roberto Ierusalimschy's
         post in http://lua-users.org/lists/lua-l/2002-09/msg00134.html .

         The included BIT.bit32 and BIT.bit sublibraries aims to provide 100%
         compatibility with the Lua 5.2 "bit32" and (LuaJIT) LuaBitOp "bit" library.
         This compatbility is at the cost of some efficiency since inputted
         numbers are normalized and more general forms (e.g. multi-argument
         bitwise operators) are supported.

       STATUS

         WARNING: Not all corner cases have been tested and documented.
         Some attempt was made to make these similar to the Lua 5.2 [2]
         and LuaJit BitOp [3] libraries, but this is not fully tested and there
         are currently some differences.  Addressing these differences may
         be improved in the future but it is not yet fully determined how to
         resolve these differences.

         The BIT.bit32 library passes the Lua 5.2 test suite (bitwise.lua)
         http://www.lua.org/tests/5.2/ .  The BIT.bit library passes the LuaBitOp
         test suite (bittest.lua).  However, these have not been tested on
         platforms with Lua compiled with 32-bit integer numbers.

       API

         Module's return

           This table contains functions that aim to provide 100% compatibility
           with the LuaBitOp "bit" library (from LuaJIT).

           bit.tobit(x) --> y
           bit.tohex(x [,n]) --> y
           bit.bnot(x) --> y
           bit.bor(x1 [,x2...]) --> y
           bit.band(x1 [,x2...]) --> y
           bit.bxor(x1 [,x2...]) --> y
           bit.lshift(x, n) --> y
           bit.rshift(x, n) --> y
           bit.arshift(x, n) --> y
           bit.rol(x, n) --> y
           bit.ror(x, n) --> y
           bit.bswap(x) --> y

       DEPENDENCIES

         None (other than Lua 5.1 or 5.2).

       REFERENCES

         [1] http://lua-users.org/wiki/FloatingPoint
         [2] http://www.lua.org/manual/5.2/
         [3] http://bitop.luajit.org/

       LICENSE

         (c) 2008-2011 David Manura.  Licensed under the same terms as Lua (MIT).

         Permission is hereby granted, free of charge, to any person obtaining a copy
         of this software and associated documentation files (the "Software"), to deal
         in the Software without restriction, including without limitation the rights
         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         copies of the Software, and to permit persons to whom the Software is
         furnished to do so, subject to the following conditions:

         The above copyright notice and this permission notice shall be included in
         all copies or substantial portions of the Software.

         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
         THE SOFTWARE.
         (end license)

         Some modifications by plenary team.

       --]]

*****0 local M = {_TYPE='module', _NAME='bit.numberlua', _VERSION='0.3.1.20120131'}

*****0 local floor = math.floor

*****0 local MOD = 2^32
*****0 local MODM = MOD-1

       local function memoize(f)
*****0   local mt = {}
*****0   local t = setmetatable({}, mt)
*****0   function mt:__index(k)
*****0     local v = f(k); t[k] = v
*****0     return v
         end
*****0   return t
       end

       local function make_bitop_uncached(t, m)
         local function bitop(a, b)
*****0     local res,p = 0,1
*****0     while a ~= 0 and b ~= 0 do
*****0       local am, bm = a%m, b%m
*****0       res = res + t[am][bm]*p
*****0       a = (a - am) / m
*****0       b = (b - bm) / m
*****0       p = p*m
           end
*****0     res = res + (a+b)*p
*****0     return res
         end
*****0   return bitop
       end

       local function make_bitop(t)
*****0   local op1 = make_bitop_uncached(t,2^1)
*****0   local op2 = memoize(function(a)
*****0     return memoize(function(b)
*****0       return op1(a, b)
           end)
         end)
*****0   return make_bitop_uncached(op2, 2^(t.n or 1))
       end

       -- ok?  probably not if running on a 32-bit int Lua number type platform
*****0 function M.tobit(x)
*****0   return x % 2^32
       end

*****0 M.bxor = make_bitop {[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0}, n=4}
*****0 local bxor = M.bxor

*****0 function M.bnot(a)   return MODM - a end
*****0 local bnot = M.bnot

*****0 function M.band(a,b) return ((a+b) - bxor(a,b))/2 end
*****0 local band = M.band

*****0 function M.bor(a,b)  return MODM - band(MODM - a, MODM - b) end
*****0 local bor = M.bor

       local lshift, rshift -- forward declare

*****0 function M.rshift(a,disp) -- Lua5.2 insipred
*****0   if disp < 0 then return lshift(a,-disp) end
*****0   return floor(a % 2^32 / 2^disp)
       end
*****0 rshift = M.rshift

*****0 function M.lshift(a,disp) -- Lua5.2 inspired
*****0   if disp < 0 then return rshift(a,-disp) end
*****0   return (a * 2^disp) % 2^32
       end
*****0 lshift = M.lshift

*****0 function M.tohex(x, n) -- BitOp style
*****0   n = n or 8
         local up
*****0   if n <= 0 then
*****0     if n == 0 then return '' end
*****0     up = true
*****0     n = - n
         end
*****0   x = band(x, 16^n-1)
*****0   return ('%0'..n..(up and 'X' or 'x')):format(x)
       end
*****0 local tohex = M.tohex

*****0 function M.extract(n, field, width) -- Lua5.2 inspired
*****0   width = width or 1
*****0   return band(rshift(n, field), 2^width-1)
       end

*****0 function M.replace(n, v, field, width) -- Lua5.2 inspired
*****0   width = width or 1
*****0   local mask1 = 2^width-1
*****0   v = band(v, mask1) -- required by spec?
*****0   local mask = bnot(lshift(mask1, field))
*****0   return band(n, mask) + lshift(v, field)
       end

*****0 function M.bswap(x)  -- BitOp style
*****0   local a = band(x, 0xff); x = rshift(x, 8)
*****0   local b = band(x, 0xff); x = rshift(x, 8)
*****0   local c = band(x, 0xff); x = rshift(x, 8)
*****0   local d = band(x, 0xff)
*****0   return lshift(lshift(lshift(a, 8) + b, 8) + c, 8) + d
       end
*****0 local bswap = M.bswap

*****0 function M.rrotate(x, disp)  -- Lua5.2 inspired
*****0   disp = disp % 32
*****0   local low = band(x, 2^disp-1)
*****0   return rshift(x, disp) + lshift(low, 32-disp)
       end
*****0 local rrotate = M.rrotate

*****0 function M.lrotate(x, disp)  -- Lua5.2 inspired
*****0   return rrotate(x, -disp)
       end
*****0 local lrotate = M.lrotate

*****0 M.rol = M.lrotate  -- LuaOp inspired
*****0 M.ror = M.rrotate  -- LuaOp insipred


*****0 function M.arshift(x, disp) -- Lua5.2 inspired
*****0   local z = rshift(x, disp)
*****0   if x >= 0x80000000 then z = z + lshift(2^disp-1, 32-disp) end
*****0   return z
       end
*****0 local arshift = M.arshift

*****0 function M.btest(x, y) -- Lua5.2 inspired
*****0   return band(x, y) ~= 0
       end

       --
       -- Start LuaBitOp "bit" compat section.
       --

*****0 M.bit = {} -- LuaBitOp "bit" compatibility

*****0 function M.bit.tobit(x)
*****0   x = x % MOD
*****0   if x >= 0x80000000 then x = x - MOD end
*****0   return x
       end
*****0 local bit_tobit = M.bit.tobit

*****0 function M.bit.tohex(x, ...)
*****0   return tohex(x % MOD, ...)
       end

*****0 function M.bit.bnot(x)
*****0   return bit_tobit(bnot(x % MOD))
       end

       local function bit_bor(a, b, c, ...)
*****0   if c then
*****0     return bit_bor(bit_bor(a, b), c, ...)
*****0   elseif b then
*****0     return bit_tobit(bor(a % MOD, b % MOD))
         else
*****0     return bit_tobit(a)
         end
       end
*****0 M.bit.bor = bit_bor

       local function bit_band(a, b, c, ...)
*****0   if c then
*****0     return bit_band(bit_band(a, b), c, ...)
*****0   elseif b then
*****0     return bit_tobit(band(a % MOD, b % MOD))
         else
*****0     return bit_tobit(a)
         end
       end
*****0 M.bit.band = bit_band

       local function bit_bxor(a, b, c, ...)
*****0   if c then
*****0     return bit_bxor(bit_bxor(a, b), c, ...)
*****0   elseif b then
*****0     return bit_tobit(bxor(a % MOD, b % MOD))
         else
*****0     return bit_tobit(a)
         end
       end
*****0 M.bit.bxor = bit_bxor

*****0 function M.bit.lshift(x, n)
*****0   return bit_tobit(lshift(x % MOD, n % 32))
       end

*****0 function M.bit.rshift(x, n)
*****0   return bit_tobit(rshift(x % MOD, n % 32))
       end

*****0 function M.bit.arshift(x, n)
*****0   return bit_tobit(arshift(x % MOD, n % 32))
       end

*****0 function M.bit.rol(x, n)
*****0   return bit_tobit(lrotate(x % MOD, n % 32))
       end

*****0 function M.bit.ror(x, n)
*****0   return bit_tobit(rrotate(x % MOD, n % 32))
       end

*****0 function M.bit.bswap(x)
*****0   return bit_tobit(bswap(x % MOD))
       end

*****0 return M.bit

==============================================================================
/home/runner/.local/share/nvim/test/plenary/lua/plenary/functional.lua
==============================================================================
     8 local f = {}

     8 function f.kv_pairs(t)
*****0   local results = {}
*****0   for k, v in pairs(t) do
*****0     table.insert(results, { k, v })
         end
*****0   return results
       end

     8 function f.kv_map(fun, t)
*****0   return vim.tbl_map(fun, f.kv_pairs(t))
       end

     8 function f.join(array, sep)
*****0   return table.concat(vim.tbl_map(tostring, array), sep)
       end

       local function bind_n(fn, n, a, ...)
*****0   if n == 0 then
*****0     return fn
         end
*****0   return bind_n(function(...)
*****0     return fn(a, ...)
*****0   end, n - 1, ...)
       end

     8 function f.partial(fun, ...)
*****0   return bind_n(fun, select("#", ...), ...)
       end

     8 function f.any(fun, iterable)
*****0   for k, v in pairs(iterable) do
*****0     if fun(k, v) then
*****0       return true
           end
         end

*****0   return false
       end

     8 function f.all(fun, iterable)
*****0   for k, v in pairs(iterable) do
*****0     if not fun(k, v) then
*****0       return false
           end
         end

*****0   return true
       end

     8 function f.if_nil(val, was_nil, was_not_nil)
    21   if val == nil then
     7     return was_nil
         else
    14     return was_not_nil
         end
       end

     8 function f.select_only(n)
         return function(...)
*****0     local x = select(n, ...)
*****0     return x
         end
       end

    16 f.first = f.select_only(1)
    16 f.second = f.select_only(2)
    16 f.third = f.select_only(3)

     8 function f.last(...)
*****0   local length = select("#", ...)
*****0   local x = select(length, ...)
*****0   return x
       end

     8 return f

==============================================================================
/home/runner/.local/share/nvim/test/plenary/lua/plenary/path.lua
==============================================================================
       --- Path.lua
       ---
       --- Goal: Create objects that are extremely similar to Python's `Path` Objects.
       --- Reference: https://docs.python.org/3/library/pathlib.html

     8 local bit = require "plenary.bit"
     8 local uv = vim.loop

     8 local F = require "plenary.functional"

     8 local S_IF = {
         -- S_IFDIR  = 0o040000  # directory
         DIR = 0x4000,
         -- S_IFREG  = 0o100000  # regular file
         REG = 0x8000,
       }

     8 local path = {}
     8 path.home = vim.loop.os_homedir()

*****0 path.sep = (function()
     8   if jit then
     8     local os = string.lower(jit.os)
     8     if os ~= "windows" then
     8       return "/"
           else
*****0       return "\\"
           end
         else
*****0     return package.config:sub(1, 1)
         end
    16 end)()

*****0 path.root = (function()
     8   if path.sep == "/" then
           return function()
*****0       return "/"
           end
         else
           return function(base)
*****0       base = base or vim.loop.cwd()
*****0       return base:sub(1, 1) .. ":\\"
           end
         end
    16 end)()

     8 path.S_IF = S_IF

       local band = function(reg, value)
*****0   return bit.band(reg, value) == reg
       end

       local concat_paths = function(...)
*****0   return table.concat({ ... }, path.sep)
       end

       local function is_root(pathname)
*****0   if path.sep == "\\" then
*****0     return string.match(pathname, "^[A-Z]:\\?$")
         end
*****0   return pathname == "/"
       end

*****0 local _split_by_separator = (function()
     8   local formatted = string.format("([^%s]+)", path.sep)
         return function(filepath)
*****0     local t = {}
*****0     for str in string.gmatch(filepath, formatted) do
*****0       table.insert(t, str)
           end
*****0     return t
         end
     8 end)()

       local is_uri = function(filename)
   686   return string.match(filename, "^%a[%w+-.]*://") ~= nil
       end

       local is_absolute = function(filename, sep)
   678   if sep == "\\" then
*****0     return string.match(filename, "^[%a]:[\\/].*$") ~= nil
         end
  1356   return string.sub(filename, 1, 1) == sep
       end

       local function _normalize_path(filename, cwd)
  1356   if is_uri(filename) then
*****0     return filename
         end

         -- handles redundant `./` in the middle
   678   local redundant = path.sep .. "%." .. path.sep
   678   if filename:match(redundant) then
*****0     filename = filename:gsub(redundant, path.sep)
         end

   678   local out_file = filename

   678   local has = string.find(filename, path.sep .. "..", 1, true) or string.find(filename, ".." .. path.sep, 1, true)

   678   if has then
*****0     local is_abs = is_absolute(filename, path.sep)
           local split_without_disk_name = function(filename_local)
*****0       local parts = _split_by_separator(filename_local)
             -- Remove disk name part on Windows
*****0       if path.sep == "\\" and is_abs then
*****0         table.remove(parts, 1)
             end
*****0       return parts
           end

*****0     local parts = split_without_disk_name(filename)
*****0     local idx = 1
*****0     local initial_up_count = 0

           repeat
*****0       if parts[idx] == ".." then
*****0         if idx == 1 then
*****0           initial_up_count = initial_up_count + 1
               end
*****0         table.remove(parts, idx)
*****0         table.remove(parts, idx - 1)
*****0         if idx > 1 then
*****0           idx = idx - 2
               else
*****0           idx = idx - 1
               end
             end
*****0       idx = idx + 1
*****0     until idx > #parts

*****0     local prefix = ""
*****0     if is_abs or #split_without_disk_name(cwd) == initial_up_count then
*****0       prefix = path.root(filename)
           end

*****0     out_file = prefix .. table.concat(parts, path.sep)
         end

   678   return out_file
       end

       local clean = function(pathname)
*****0   if is_uri(pathname) then
*****0     return pathname
         end

         -- Remove double path seps, it's annoying
*****0   pathname = pathname:gsub(path.sep .. path.sep, path.sep)

         -- Remove trailing path sep if not root
*****0   if not is_root(pathname) and pathname:sub(-1) == path.sep then
*****0     return pathname:sub(1, -2)
         end
*****0   return pathname
       end

       -- S_IFCHR  = 0o020000  # character device
       -- S_IFBLK  = 0o060000  # block device
       -- S_IFIFO  = 0o010000  # fifo (named pipe)
       -- S_IFLNK  = 0o120000  # symbolic link
       -- S_IFSOCK = 0o140000  # socket file

       ---@class Path
     8 local Path = {
     8   path = path,
       }

       local check_self = function(self)
   259   if type(self) == "string" then
*****0     return Path:new(self)
         end

   259   return self
       end

       Path.__index = function(t, k)
  3886   local raw = rawget(Path, k)
  3886   if raw then
  3236     return raw
         end

   650   if k == "_cwd" then
   650     local cwd = uv.fs_realpath "."
   650     t._cwd = cwd
   650     return cwd
         end

*****0   if k == "_absolute" then
*****0     local absolute = uv.fs_realpath(t.filename)
*****0     t._absolute = absolute
*****0     return absolute
         end
       end

       -- TODO: Could use this to not have to call new... not sure
       -- Path.__call = Path:new

       Path.__div = function(self, other)
*****0   assert(Path.is_path(self))
*****0   assert(Path.is_path(other) or type(other) == "string")

*****0   return self:joinpath(other)
       end

       Path.__tostring = function(self)
*****0   return clean(self.filename)
       end

       -- TODO: See where we concat the table, and maybe we could make this work.
       Path.__concat = function(self, other)
*****0   return self.filename .. other
       end

       Path.is_path = function(a)
   657   return getmetatable(a) == Path
       end

     8 function Path:new(...)
   657   local args = { ... }

   657   if type(self) == "string" then
*****0     table.insert(args, 1, self)
*****0     self = Path -- luacheck: ignore
         end

         local path_input
   657   if #args == 1 then
   657     path_input = args[1]
         else
*****0     path_input = args
         end

         -- If we already have a Path, it's fine.
         --   Just return it
  1314   if Path.is_path(path_input) then
     7     return path_input
         end

         -- TODO: Should probably remove and dumb stuff like double seps, periods in the middle, etc.
   650   local sep = path.sep
   650   if type(path_input) == "table" then
*****0     sep = path_input.sep or path.sep
*****0     path_input.sep = nil
         end

         local path_string
   650   if type(path_input) == "table" then
           -- TODO: It's possible this could be done more elegantly with __concat
           --       But I'm unsure of what we'd do to make that happen
*****0     local path_objs = {}
*****0     for _, v in ipairs(path_input) do
*****0       if Path.is_path(v) then
*****0         table.insert(path_objs, v.filename)
             else
*****0         assert(type(v) == "string")
*****0         table.insert(path_objs, v)
             end
           end

*****0     path_string = table.concat(path_objs, sep)
         else
  1300     assert(type(path_input) == "string", vim.inspect(path_input))
   650     path_string = path_input
         end

   650   local obj = {
   650     filename = path_string,

   650     _sep = sep,
         }

   650   setmetatable(obj, Path)

   650   return obj
       end

     8 function Path:_fs_filename()
  2013   return self:absolute() or self.filename
       end

     8 function Path:_stat()
   816   return uv.fs_stat(self:_fs_filename()) or {}
         -- local stat = uv.fs_stat(self:absolute())
         -- if not self._absolute then return {} end

         -- if not self._stat_result then
         --   self._stat_result =
         -- end

         -- return self._stat_result
       end

     8 function Path:_st_mode()
*****0   return self:_stat().mode or 0
       end

     8 function Path:joinpath(...)
*****0   return Path:new(self.filename, ...)
       end

     8 function Path:absolute()
  2034   if self:is_absolute() then
  1328     return _normalize_path(self.filename, self._cwd)
         else
*****0     return _normalize_path(self._absolute or table.concat({ self._cwd, self.filename }, self._sep), self._cwd)
         end
       end

     8 function Path:exists()
  1088   return not vim.tbl_isempty(self:_stat())
       end

     8 function Path:expand()
*****0   if is_uri(self.filename) then
*****0     return self.filename
         end

         -- TODO support windows
         local expanded
*****0   if string.find(self.filename, "~") then
*****0     expanded = string.gsub(self.filename, "^~", vim.loop.os_homedir())
*****0   elseif string.find(self.filename, "^%.") then
*****0     expanded = vim.loop.fs_realpath(self.filename)
*****0     if expanded == nil then
*****0       expanded = vim.fn.fnamemodify(self.filename, ":p")
           end
*****0   elseif string.find(self.filename, "%$") then
*****0     local rep = string.match(self.filename, "([^%$][^/]*)")
*****0     local val = os.getenv(rep)
*****0     if val then
*****0       expanded = string.gsub(string.gsub(self.filename, rep, val), "%$", "")
           else
*****0       expanded = nil
           end
         else
*****0     expanded = self.filename
         end
*****0   return expanded and expanded or error "Path not valid"
       end

     8 function Path:make_relative(cwd)
*****0   if is_uri(self.filename) then
*****0     return self.filename
         end

*****0   self.filename = clean(self.filename)
*****0   cwd = clean(F.if_nil(cwd, self._cwd, cwd))
*****0   if self.filename == cwd then
*****0     self.filename = "."
         else
*****0     if cwd:sub(#cwd, #cwd) ~= path.sep then
*****0       cwd = cwd .. path.sep
           end

*****0     if self.filename:sub(1, #cwd) == cwd then
*****0       self.filename = self.filename:sub(#cwd + 1, -1)
           end
         end

*****0   return self.filename
       end

     8 function Path:normalize(cwd)
*****0   if is_uri(self.filename) then
*****0     return self.filename
         end

*****0   self:make_relative(cwd)

         -- Substitute home directory w/ "~"
         -- string.gsub is not useful here because usernames with dashes at the end
         -- will be seen as a regexp pattern rather than a raw string
*****0   local home = path.home
*****0   if string.sub(path.home, -1) ~= path.sep then
*****0     home = home .. path.sep
         end
*****0   local start, finish = string.find(self.filename, home, 1, true)
*****0   if start == 1 then
*****0     self.filename = "~" .. path.sep .. string.sub(self.filename, (finish + 1), -1)
         end

*****0   return _normalize_path(clean(self.filename), self._cwd)
       end

       local function shorten_len(filename, len, exclude)
*****0   len = len or 1
*****0   exclude = exclude or { -1 }
*****0   local exc = {}

         -- get parts in a table
*****0   local parts = {}
*****0   local empty_pos = {}
*****0   for m in (filename .. path.sep):gmatch("(.-)" .. path.sep) do
*****0     if m ~= "" then
*****0       parts[#parts + 1] = m
           else
*****0       table.insert(empty_pos, #parts + 1)
           end
         end

*****0   for _, v in pairs(exclude) do
*****0     if v < 0 then
*****0       exc[v + #parts + 1] = true
           else
*****0       exc[v] = true
           end
         end

*****0   local final_path_components = {}
*****0   local count = 1
*****0   for _, match in ipairs(parts) do
*****0     if not exc[count] and #match > len then
*****0       table.insert(final_path_components, string.sub(match, 1, len))
           else
*****0       table.insert(final_path_components, match)
           end
*****0     table.insert(final_path_components, path.sep)
*****0     count = count + 1
         end

*****0   local l = #final_path_components -- so that we don't need to keep calculating length
*****0   table.remove(final_path_components, l) -- remove final slash

         -- add back empty positions
*****0   for i = #empty_pos, 1, -1 do
*****0     table.insert(final_path_components, empty_pos[i], path.sep)
         end

*****0   return table.concat(final_path_components)
       end

*****0 local shorten = (function()
         local fallback = function(filename)
*****0     return shorten_len(filename, 1)
         end

     8   if jit and path.sep ~= "\\" then
     8     local ffi = require "ffi"
     8     ffi.cdef [[
           typedef unsigned char char_u;
           void shorten_dir(char_u *str);
     8     ]]
           local ffi_func = function(filename)
    16       if not filename or is_uri(filename) then
*****0         return filename
             end

     8       local c_str = ffi.new("char[?]", #filename + 1)
     8       ffi.copy(c_str, filename)
     8       ffi.C.shorten_dir(c_str)
     8       return ffi.string(c_str)
           end
     8     local ok = pcall(ffi_func, "/tmp/path/file.lua")
     8     if ok then
     8       return ffi_func
           else
*****0       return fallback
           end
         end
*****0   return fallback
     8 end)()

     8 function Path:shorten(len, exclude)
*****0   assert(len ~= 0, "len must be at least 1")
*****0   if (len and len > 1) or exclude ~= nil then
*****0     return shorten_len(self.filename, len, exclude)
         end
*****0   return shorten(self.filename)
       end

     8 function Path:mkdir(opts)
     7   opts = opts or {}

     7   local mode = opts.mode or 448 -- 0700 -> decimal
     7   local parents = F.if_nil(opts.parents, false, opts.parents)
     7   local exists_ok = F.if_nil(opts.exists_ok, true, opts.exists_ok)

    14   local exists = self:exists()
     7   if not exists_ok and exists then
*****0     error("FileExistsError:" .. self:absolute())
         end

         -- fs_mkdir returns nil if folder exists
    21   if not uv.fs_mkdir(self:_fs_filename(), mode) and not exists then
*****0     if parents then
*****0       local dirs = self:_split()
*****0       local processed = ""
*****0       for _, dir in ipairs(dirs) do
*****0         if dir ~= "" then
*****0           local joined = concat_paths(processed, dir)
*****0           if processed == "" and self._sep == "\\" then
*****0             joined = dir
                 end
*****0           local stat = uv.fs_stat(joined) or {}
*****0           local file_mode = stat.mode or 0
*****0           if band(S_IF.REG, file_mode) then
*****0             error(string.format("%s is a regular file so we can't mkdir it", joined))
*****0           elseif band(S_IF.DIR, file_mode) then
*****0             processed = joined
                 else
*****0             if uv.fs_mkdir(joined, mode) then
*****0               processed = joined
                   else
*****0               error("We couldn't mkdir: " .. joined)
                   end
                 end
               end
             end
           else
             error "FileNotFoundError"
           end
         end

     7   return true
       end

     8 function Path:rmdir()
*****0   if not self:exists() then
*****0     return
         end

*****0   uv.fs_rmdir(self:absolute())
       end

     8 function Path:rename(opts)
*****0   opts = opts or {}
*****0   if not opts.new_name or opts.new_name == "" then
           error "Please provide the new name!"
         end

         -- handles `.`, `..`, `./`, and `../`
*****0   if opts.new_name:match "^%.%.?/?\\?.+" then
*****0     opts.new_name = {
*****0       uv.fs_realpath(opts.new_name:sub(1, 3)),
*****0       opts.new_name:sub(4, #opts.new_name),
           }
         end

*****0   local new_path = Path:new(opts.new_name)

*****0   if new_path:exists() then
           error "File or directory already exists!"
         end

*****0   local status = uv.fs_rename(self:absolute(), new_path:absolute())
*****0   self.filename = new_path.filename

*****0   return status
       end

       --- Copy files or folders with defaults akin to GNU's `cp`.
       ---@param opts table: options to pass to toggling registered actions
       ---@field destination string|Path: target file path to copy to
       ---@field recursive bool: whether to copy folders recursively (default: false)
       ---@field override bool: whether to override files (default: true)
       ---@field interactive bool: confirm if copy would override; precedes `override` (default: false)
       ---@field respect_gitignore bool: skip folders ignored by all detected `gitignore`s (default: false)
       ---@field hidden bool: whether to add hidden files in recursively copying folders (default: true)
       ---@field parents bool: whether to create possibly non-existing parent dirs of `opts.destination` (default: false)
       ---@field exists_ok bool: whether ok if `opts.destination` exists, if so folders are merged (default: true)
       ---@return table {[Path of destination]: bool} indicating success of copy; nested tables constitute sub dirs
     8 function Path:copy(opts)
*****0   opts = opts or {}
*****0   opts.recursive = F.if_nil(opts.recursive, false, opts.recursive)
*****0   opts.override = F.if_nil(opts.override, true, opts.override)

*****0   local dest = opts.destination
         -- handles `.`, `..`, `./`, and `../`
*****0   if not Path.is_path(dest) then
*****0     if type(dest) == "string" and dest:match "^%.%.?/?\\?.+" then
*****0       dest = {
*****0         uv.fs_realpath(dest:sub(1, 3)),
*****0         dest:sub(4, #dest),
             }
           end
*****0     dest = Path:new(dest)
         end
         -- success is true in case file is copied, false otherwise
*****0   local success = {}
*****0   if not self:is_dir() then
*****0     if opts.interactive and dest:exists() then
*****0       vim.ui.select(
*****0         { "Yes", "No" },
*****0         { prompt = string.format("Overwrite existing %s?", dest:absolute()) },
               function(_, idx)
*****0           success[dest] = uv.fs_copyfile(self:absolute(), dest:absolute(), { excl = idx ~= 1 }) or false
               end
             )
           else
             -- nil: not overriden if `override = false`
*****0       success[dest] = uv.fs_copyfile(self:absolute(), dest:absolute(), { excl = not opts.override }) or false
           end
*****0     return success
         end
         -- dir
*****0   if opts.recursive then
*****0     dest:mkdir {
             parents = F.if_nil(opts.parents, false, opts.parents),
             exists_ok = F.if_nil(opts.exists_ok, true, opts.exists_ok),
           }
*****0     local scan = require "plenary.scandir"
*****0     local data = scan.scan_dir(self.filename, {
             respect_gitignore = F.if_nil(opts.respect_gitignore, false, opts.respect_gitignore),
             hidden = F.if_nil(opts.hidden, true, opts.hidden),
             depth = 1,
             add_dirs = true,
           })
*****0     for _, entry in ipairs(data) do
*****0       local entry_path = Path:new(entry)
*****0       local suffix = table.remove(entry_path:_split())
*****0       local new_dest = dest:joinpath(suffix)
             -- clear destination as it might be Path table otherwise failing w/ extend
*****0       opts.destination = nil
*****0       local new_opts = vim.tbl_deep_extend("force", opts, { destination = new_dest })
             -- nil: not overriden if `override = false`
*****0       success[new_dest] = entry_path:copy(new_opts) or false
           end
*****0     return success
         else
*****0     error(string.format("Warning: %s was not copied as `recursive=false`", self:absolute()))
         end
       end

     8 function Path:touch(opts)
     7   opts = opts or {}

     7   local mode = opts.mode or 420
     7   local parents = F.if_nil(opts.parents, false, opts.parents)

    21   if self:exists() then
*****0     local new_time = os.time()
*****0     uv.fs_utime(self:_fs_filename(), new_time, new_time)
*****0     return
         end

     7   if parents then
    35     Path:new(self:parent()):mkdir { parents = true }
         end

    21   local fd = uv.fs_open(self:_fs_filename(), "w", mode)
     7   if not fd then
*****0     error("Could not create file: " .. self:_fs_filename())
         end
     7   uv.fs_close(fd)

     7   return true
       end

     8 function Path:rm(opts)
*****0   opts = opts or {}

*****0   local recursive = F.if_nil(opts.recursive, false, opts.recursive)
*****0   if recursive then
*****0     local scan = require "plenary.scandir"
*****0     local abs = self:absolute()

           -- first unlink all files
*****0     scan.scan_dir(abs, {
             hidden = true,
             on_insert = function(file)
*****0         uv.fs_unlink(file)
             end,
           })

*****0     local dirs = scan.scan_dir(abs, { add_dirs = true, hidden = true })
           -- iterate backwards to clean up remaining dirs
*****0     for i = #dirs, 1, -1 do
*****0       uv.fs_rmdir(dirs[i])
           end

           -- now only abs is missing
*****0     uv.fs_rmdir(abs)
         else
*****0     uv.fs_unlink(self:absolute())
         end
       end

       -- Path:is_* {{{
     8 function Path:is_dir()
         -- TODO: I wonder when this would be better, if ever.
         -- return self:_stat().type == 'directory'

*****0   return band(S_IF.DIR, self:_st_mode())
       end

     8 function Path:is_absolute()
   678   return is_absolute(self.filename, self._sep)
       end
       -- }}}

     8 function Path:_split()
*****0   return vim.split(self:absolute(), self._sep)
       end

*****0 local _get_parent = (function()
     8   local formatted = string.format("^(.+)%s[^%s]+", path.sep, path.sep)
         return function(abs_path)
     7     local parent = abs_path:match(formatted)
     7     if parent ~= nil and not parent:find(path.sep) then
*****0       return parent .. path.sep
           end
     7     return parent
         end
     8 end)()

     8 function Path:parent()
    28   return Path:new(_get_parent(self:absolute()) or path.root(self:absolute()))
       end

     8 function Path:parents()
*****0   local results = {}
*****0   local cur = self:absolute()
         repeat
*****0     cur = _get_parent(cur)
*****0     table.insert(results, cur)
*****0   until not cur
*****0   table.insert(results, path.root(self:absolute()))
*****0   return results
       end

     8 function Path:is_file()
*****0   return self:_stat().type == "file" and true or nil
       end

       -- TODO:
       --  Maybe I can use libuv for this?
     8 function Path:open() end

     8 function Path:close() end

     8 function Path:write(txt, flag, mode)
   126   assert(flag, [[Path:write_text requires a flag! For example: 'w' or 'a']])

   126   mode = mode or 438

   378   local fd = assert(uv.fs_open(self:_fs_filename(), flag, mode))
   126   assert(uv.fs_write(fd, txt, -1))
   126   assert(uv.fs_close(fd))
       end

       -- TODO: Asyncify this and use vim.wait in the meantime.
       --  This will allow other events to happen while we're waiting!
     8 function Path:_read()
   518   self = check_self(self)

   777   local fd = assert(uv.fs_open(self:_fs_filename(), "r", 438)) -- for some reason test won't pass with absolute
   259   local stat = assert(uv.fs_fstat(fd))
   259   local data = assert(uv.fs_read(fd, stat.size, 0))
   259   assert(uv.fs_close(fd))

   259   return data
       end

     8 function Path:_read_async(callback)
*****0   vim.loop.fs_open(self.filename, "r", 438, function(err_open, fd)
*****0     if err_open then
*****0       print("We tried to open this file but couldn't. We failed with following error message: " .. err_open)
*****0       return
           end
*****0     vim.loop.fs_fstat(fd, function(err_fstat, stat)
*****0       assert(not err_fstat, err_fstat)
*****0       if stat.type ~= "file" then
*****0         return callback ""
             end
*****0       vim.loop.fs_read(fd, stat.size, 0, function(err_read, data)
*****0         assert(not err_read, err_read)
*****0         vim.loop.fs_close(fd, function(err_close)
*****0           assert(not err_close, err_close)
*****0           return callback(data)
               end)
             end)
           end)
         end)
       end

     8 function Path:read(callback)
   259   if callback then
*****0     return self:_read_async(callback)
         end
   518   return self:_read()
       end

     8 function Path:head(lines)
*****0   lines = lines or 10
*****0   self = check_self(self)
*****0   local chunk_size = 256

*****0   local fd = uv.fs_open(self:_fs_filename(), "r", 438)
*****0   if not fd then
*****0     return
         end
*****0   local stat = assert(uv.fs_fstat(fd))
*****0   if stat.type ~= "file" then
*****0     uv.fs_close(fd)
*****0     return nil
         end

*****0   local data = ""
*****0   local index, count = 0, 0
*****0   while count < lines and index < stat.size do
*****0     local read_chunk = assert(uv.fs_read(fd, chunk_size, index))

*****0     local i = 0
*****0     for char in read_chunk:gmatch "." do
*****0       if char == "\n" then
*****0         count = count + 1
*****0         if count >= lines then
                 break
               end
             end
*****0       index = index + 1
*****0       i = i + 1
           end
*****0     data = data .. read_chunk:sub(1, i)
         end
*****0   assert(uv.fs_close(fd))

         -- Remove potential newline at end of file
*****0   if data:sub(-1) == "\n" then
*****0     data = data:sub(1, -2)
         end

*****0   return data
       end

     8 function Path:tail(lines)
*****0   lines = lines or 10
*****0   self = check_self(self)
*****0   local chunk_size = 256

*****0   local fd = uv.fs_open(self:_fs_filename(), "r", 438)
*****0   if not fd then
*****0     return
         end
*****0   local stat = assert(uv.fs_fstat(fd))
*****0   if stat.type ~= "file" then
*****0     uv.fs_close(fd)
*****0     return nil
         end

*****0   local data = ""
*****0   local index, count = stat.size - 1, 0
*****0   while count < lines and index > 0 do
*****0     local real_index = index - chunk_size
*****0     if real_index < 0 then
*****0       chunk_size = chunk_size + real_index
*****0       real_index = 0
           end

*****0     local read_chunk = assert(uv.fs_read(fd, chunk_size, real_index))

*****0     local i = #read_chunk
*****0     while i > 0 do
*****0       local char = read_chunk:sub(i, i)
*****0       if char == "\n" then
*****0         count = count + 1
*****0         if count >= lines then
                 break
               end
             end
*****0       index = index - 1
*****0       i = i - 1
           end
*****0     data = read_chunk:sub(i + 1, #read_chunk) .. data
         end
*****0   assert(uv.fs_close(fd))

*****0   return data
       end

     8 function Path:readlines()
*****0   self = check_self(self)

*****0   local data = self:read()

*****0   data = data:gsub("\r", "")
*****0   return vim.split(data, "\n")
       end

     8 function Path:iter()
*****0   local data = self:readlines()
*****0   local i = 0
*****0   local n = #data
         return function()
*****0     i = i + 1
*****0     if i <= n then
*****0       return data[i]
           end
         end
       end

     8 function Path:readbyterange(offset, length)
*****0   self = check_self(self)

*****0   local fd = uv.fs_open(self:_fs_filename(), "r", 438)
*****0   if not fd then
*****0     return
         end
*****0   local stat = assert(uv.fs_fstat(fd))
*****0   if stat.type ~= "file" then
*****0     uv.fs_close(fd)
*****0     return nil
         end

*****0   if offset < 0 then
*****0     offset = stat.size + offset
           -- Windows fails if offset is < 0 even though offset is defined as signed
           -- http://docs.libuv.org/en/v1.x/fs.html#c.uv_fs_read
*****0     if offset < 0 then
*****0       offset = 0
           end
         end

*****0   local data = ""
*****0   while #data < length do
*****0     local read_chunk = assert(uv.fs_read(fd, length - #data, offset))
*****0     if #read_chunk == 0 then
             break
           end
*****0     data = data .. read_chunk
*****0     offset = offset + #read_chunk
         end

*****0   assert(uv.fs_close(fd))

*****0   return data
       end

     8 function Path:find_upwards(filename)
*****0   local folder = Path:new(self)
*****0   local root = path.root(folder:absolute())

         while true do
*****0     local p = folder:joinpath(filename)
*****0     if p:exists() then
*****0       return p
           end
*****0     if folder:absolute() == root then
             break
           end
*****0     folder = folder:parent()
         end
*****0   return nil
       end

     8 return Path

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/block.lua
==============================================================================
*****0 local getfenv = require 'busted.compatibility'.getfenv
*****0 local unpack = require 'busted.compatibility'.unpack
*****0 local shuffle = require 'busted.utils'.shuffle

       local function sort(elements)
*****0   table.sort(elements, function(t1, t2)
*****0     if t1.name and t2.name then
*****0       return t1.name < t2.name
           end
*****0     return t2.name ~= nil
         end)
*****0   return elements
       end

       return function(busted)
     1   local block = {}
     1   local root = busted.context.get()

     1   function block.reject(descriptor, element)
  2516     element.env[descriptor] = function(...)
*****0       error("'" .. descriptor .. "' not supported inside current context block", 2)
           end
         end

     1   function block.rejectAll(element)
   148     local env = getfenv(element.run)
   148     block.reject('randomize', element)
  2664     for descriptor, _ in pairs(busted.executors) do
  4884       if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then
  2368         block.reject(descriptor, element)
             end
           end
         end

         local function exec(descriptor, element)
    95     if not element.env then element.env = {} end
    95     block.rejectAll(element)
   190     local ret = { busted.safe(descriptor, element.run, element) }
    95     return unpack(ret)
         end

     1   function block.execAllOnce(descriptor, current, err)
   170     local parent = busted.context.parent(current)

   170     if parent then
   117       local success = block.execAllOnce(descriptor, parent)
   117       if not success then
*****0         return success
             end
           end

   170     if not current[descriptor] then
    28       current[descriptor] = {}
           end
   170     local list = current[descriptor]
   170     if list.success ~= nil then
   142       return list.success
           end

    28     local success = true
    28     for _, v in ipairs(list) do
*****0       if not exec(descriptor, v):success() then
*****0         if err then err(descriptor) end
*****0         success = false
             end
           end

    28     list.success = success

    28     return success
         end

     1   function block.execAll(descriptor, current, propagate, err)
   198     local parent = busted.context.parent(current)

   198     if propagate and parent then
   117       local success, ancestor = block.execAll(descriptor, parent, propagate)
   117       if not success then
*****0         return success, ancestor
             end
           end

   198     local list = current[descriptor] or {}

   198     local success = true
   252     for _, v in ipairs(list) do
   162       if not exec(descriptor, v):success() then
*****0         if err then err(descriptor) end
*****0         success = nil
             end
           end
   198     return success, current
         end

     1   function block.dexecAll(descriptor, current, propagate, err)
   226     local parent = busted.context.parent(current)
   226     local list = current[descriptor] or {}

   226     local success = true
   267     for _, v in ipairs(list) do
   123       if not exec(descriptor, v):success() then
*****0         if err then err(descriptor) end
*****0         success = nil
             end
           end

   226     if propagate and parent then
   234       if not block.dexecAll(descriptor, parent, propagate) then
*****0         success = nil
             end
           end
   226     return success
         end

     1   function block.lazySetup(element, err)
    53     return block.execAllOnce('lazy_setup', element, err)
         end

     1   function block.lazyTeardown(element, err)
    28     if element.lazy_setup and element.lazy_setup.success ~= nil then
    28       block.dexecAll('lazy_teardown', element, nil, err)
    28       element.lazy_setup.success = nil
           end
         end

     1   function block.setup(element, err)
    28       return block.execAll('strict_setup', element, nil, err)
         end

     1   function block.teardown(element, err)
    28       return block.dexecAll('strict_teardown', element, nil, err)
         end

     1   function block.execute(descriptor, element)
    27     if not element.env then element.env = {} end

    27     local randomize = busted.randomize
    27     local randomseed = busted.randomseed
    27     element.env.randomize = function(...)
*****0       randomize = (select('#', ...) == 0 or ...)
*****0       if randomize then
*****0         randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed
             end
           end

    81     if busted.safe(descriptor, element.run, element):success() then
    27       if busted.sort then
*****0         sort(busted.context.children(element))
    27       elseif randomize then
*****0         element.randomseed = randomseed
*****0         shuffle(busted.context.children(element), randomseed)
             end

    54       if block.setup(element) then
    27         busted.execute(element)
             end

    27       block.lazyTeardown(element)
    27       block.teardown(element)
           end
         end

     1   return block
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/context.lua
==============================================================================
*****0 local tablex = require 'pl.tablex'

       local function save()
     8   local g = {}
   376   for k,_ in next, _G, nil do
   368     g[k] = rawget(_G, k)
         end
     8   return {
     8     gmt = debug.getmetatable(_G),
     8     g = g,
    16     loaded = tablex.copy(package.loaded)
     8   }
       end

       local function restore(state)
     8   setmetatable(_G, state.gmt)
   384   for k,_ in next, _G, nil do
   376     rawset(_G, k, state.g[k])
         end
   376   for k, v in next, state.g, nil do
           -- reset globals that were set to nil during the insulation block
   368     if rawget(_G, k) == nil then
*****0       rawset(_G, k, v)
           end
         end
  1056   for k,_ in pairs(package.loaded) do
  1048     package.loaded[k] = state.loaded[k]
         end
       end

       return function()
*****0   local context = {}

*****0   local data = { descriptor = 'suite', attributes = {} }
*****0   local parents = {}
*****0   local children = {}
*****0   local stack = {}
*****0   local states = {}

*****0   function context.ref()
*****0     local ref = {}
*****0     local ctx = data

           local function unwrap(element, levels)
    95       local levels = levels or 1
    95       local parent = element
   190       for i = 1, levels do
   190         parent = ref.parent(parent)
    95         if not parent then break end
             end
    95       if not element.env then element.env = {} end
   190       setmetatable(element.env, {
               __newindex = function(self, key, value)
*****0           if not parent then
*****0             _G[key] = value
                 else
*****0             if not parent.env then parent.env = {} end
*****0             parent.env[key] = value
                 end
               end
             })
           end

           local function push_state(current)
   175       local state = false
   175       if current.attributes.envmode == 'insulate' then
    16         state = save()
   167       elseif current.attributes.envmode == 'unwrap' then
   190         unwrap(current)
    72       elseif current.attributes.envmode == 'expose' then
*****0         unwrap(current, 2)
             end
   175       table.insert(states, state)
           end

           local function pop_state(current)
   175       local state = table.remove(states)
   175       if current.attributes.envmode == 'expose' then
*****0         states[#states] = states[#states] and save()
             end
   175       if state then
     8         restore(state)
             end
           end

*****0     function ref.get(key)
  3068       if not key then return ctx end
*****0       return ctx[key]
           end

*****0     function ref.set(key, value)
*****0       ctx[key] = value
           end

*****0     function ref.clear()
*****0       data = { descriptor = 'suite', attributes = {} }
*****0       parents = {}
*****0       children = {}
*****0       stack = {}
*****0       states = {}
*****0       ctx = data
           end

*****0     function ref.attach(child)
    96       if not children[ctx] then children[ctx] = {} end
    96       parents[child] = ctx
    96       table.insert(children[ctx], child)
           end

*****0     function ref.children(parent)
    29       return children[parent] or {}
           end

*****0     function ref.parent(child)
  5391       return parents[child]
           end

*****0     function ref.push(current)
   417       if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
   417       if ctx ~= current then push_state(current) end
   417       table.insert(stack, ctx)
   417       ctx = current
           end

*****0     function ref.pop()
   417       local current = ctx
   834       ctx = table.remove(stack)
   417       if ctx ~= current then pop_state(current) end
   417       if not ctx then error('Context stack empty. Cannot pop.') end
           end

*****0     return ref
         end

*****0   return context
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/core.lua
==============================================================================
*****0 local getfenv = require 'busted.compatibility'.getfenv
*****0 local setfenv = require 'busted.compatibility'.setfenv
*****0 local unpack = require 'busted.compatibility'.unpack
*****0 local path = require 'pl.path'
*****0 local pretty = require 'pl.pretty'
*****0 local system = require 'system'
*****0 local throw = error

*****0 local failureMt = {
         __index = {},
         __tostring = function(e) return tostring(e.message) end,
*****0   __type = 'failure'
       }

*****0 local failureMtNoString = {
         __index = {},
*****0   __type = 'failure'
       }

*****0 local pendingMt = {
         __index = {},
         __tostring = function(p) return p.message end,
*****0   __type = 'pending'
       }

       local function errortype(obj)
*****0   local mt = debug.getmetatable(obj)
*****0   if mt == failureMt or mt == failureMtNoString then
*****0     return 'failure'
*****0   elseif mt == pendingMt then
*****0     return 'pending'
         end
*****0   return 'error'
       end

       local function hasToString(obj)
*****0   return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
       end

       local function isCallable(obj)
     8   return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
       end

       return function()
*****0   local mediator = require 'mediator'()

*****0   local busted = {}
*****0   busted.version = '2.2.0'

*****0   local root = require 'busted.context'()
*****0   busted.context = root.ref()

*****0   local environment = require 'busted.environment'(busted.context)

*****0   busted.api = {}
*****0   busted.executors = {}
*****0   local executors = {}
*****0   local eattributes = {}

*****0   busted.gettime = system.gettime
*****0   busted.monotime = system.monotime
*****0   busted.sleep = system.sleep
*****0   busted.status = require 'busted.status'

*****0   function busted.getTrace(element, level, msg)
           local function trimTrace(info)
*****0       local index = info.traceback:find('\n%s*%[C]')
*****0       info.traceback = info.traceback:sub(1, index)
*****0       return info
           end
    88     level = level or  3

    88     local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
    88     local info = debug.getinfo(level, 'Sl')
    88     while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
   264           (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
*****0       level = level + 1
*****0       info = debug.getinfo(level, 'Sl')
           end

    88     info.traceback = debug.traceback('', level)
    88     info.message = tostring(msg)

    88     local file = busted.getFile(element)
   176     return file and file.getTrace(file.name, info) or trimTrace(info)
         end

*****0   function busted.rewriteMessage(element, message, trace)
*****0     local file = busted.getFile(element)
*****0     local msg = hasToString(message) and tostring(message)
*****0     msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
*****0     msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)

*****0     local hasFileLine = msg:match('^[^\n]-:%d+: .*')
*****0     if not hasFileLine then
*****0       local trace = trace or busted.getTrace(element, 3, message)
*****0       local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
*****0       msg = fileline .. msg
           end

*****0     return msg
         end

*****0   function busted.publish(...)
   259     return mediator:publish(...)
         end

*****0   function busted.subscribe(...)
    34     return mediator:subscribe(...)
         end

*****0   function busted.unsubscribe(...)
*****0     return mediator:removeSubscriber(...)
         end

*****0   function busted.getFile(element)
    88     local parent = busted.context.parent(element)

   101     while parent do
   101       if parent.file then
    25         local file = parent.file[1]
    25         return {
    25           name = file.name,
    25           getTrace = file.run.getTrace,
    25           rewriteMessage = file.run.rewriteMessage
    25         }
             end

    76       if parent.descriptor == 'file' then
    63         return {
    63           name = parent.name,
    63           getTrace = parent.run.getTrace,
    63           rewriteMessage = parent.run.rewriteMessage
    63         }
             end

    26       parent = busted.context.parent(parent)
           end

*****0     return parent
         end

*****0   function busted.fail(msg, level)
*****0     local rawlevel = (type(level) ~= 'number' or level <= 0) and level
*****0     local level = level or 1
*****0     local _, emsg = pcall(throw, msg, rawlevel or level+2)
*****0     local e = { message = emsg }
*****0     setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
*****0     throw(e, rawlevel or level+1)
         end

*****0   function busted.pending(msg)
*****0     local p = { message = msg }
*****0     setmetatable(p, pendingMt)
*****0     throw(p)
         end

*****0   function busted.bindfenv(callable, var, value)
*****0     local env = {}
*****0     local f = (debug.getmetatable(callable) or {}).__call or callable
*****0     setmetatable(env, { __index = getfenv(f) })
*****0     env[var] = value
*****0     setfenv(f, env)
         end

*****0   function busted.wrap(callable)
    16     if isCallable(callable) then
             -- prioritize __call if it exists, like in files
     8       environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
           end
         end

*****0   function busted.safe(descriptor, run, element)
   417     busted.context.push(element)
           local trace, message
   417     local status = 'success'

   834     local ret = { xpcall(run, function(msg)
*****0       status = errortype(msg)
*****0       trace = busted.getTrace(element, 3, msg)
*****0       message = busted.rewriteMessage(element, msg, trace)
   834     end) }

   417     if not ret[1] then
*****0       if status == 'success' then
*****0         status = 'error'
*****0         trace = busted.getTrace(element, 3, ret[2])
*****0         message = busted.rewriteMessage(element, ret[2], trace)
*****0       elseif status == 'failure' and descriptor ~= 'it' then
               -- Only 'it' blocks can generate test failures. Failures in all
               -- other blocks are errors outside the test.
*****0         status = 'error'
             end
             -- Note: descriptor may be different from element.descriptor when
             -- safe_publish is used (i.e. for test start/end). The safe_publish
             -- descriptor needs to be different for 'it' blocks so that we can
             -- detect that a 'failure' in a test start/end handler is not really
             -- a test failure, but rather an error outside the test, much like a
             -- failure in a support function (i.e. before_each/after_each or
             -- setup/teardown).
*****0       busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)
           end
   834     ret[1] = busted.status(status)

   417     busted.context.pop()
   417     return unpack(ret)
         end

*****0   function busted.safe_publish(descriptor, channel, element, ...)
   162     local args = {...}
   162     local n = select('#', ...)
   162     if channel[2] == 'start' then
    81       element.starttick = busted.monotime()
    81       element.starttime = busted.gettime()
    81     elseif channel[2] == 'end' then
    81       element.endtime = busted.gettime()
    81       element.endtick = busted.monotime()
    81       element.duration = element.starttick and (element.endtick - element.starttick)
           end
   324     local status = busted.safe(descriptor, function()
   162       busted.publish(channel, element, unpack(args, 1, n))
   324     end, element)
   162     return status:success()
         end

*****0   function busted.exportApi(key, value)
*****0     busted.api[key] = value
         end

*****0   function busted.export(key, value)
*****0     busted.exportApi(key, value)
*****0     environment.set(key, value)
         end

*****0   function busted.hide(key, value)
*****0     busted.api[key] = nil
*****0     environment.set(key, nil)
         end

*****0   function busted.register(descriptor, executor, attributes)
           local alias = nil
*****0     if type(executor) == 'string' then
*****0       alias = descriptor
*****0       descriptor = executor
*****0       executor = executors[descriptor]
*****0       attributes = attributes or eattributes[descriptor]
*****0       executors[alias] = executor
*****0       eattributes[alias] = attributes
           else
*****0       if executor ~= nil and not isCallable(executor) then
*****0         attributes = executor
*****0         executor = nil
             end
*****0       executors[descriptor] = executor
*****0       eattributes[descriptor] = attributes
           end

           local publisher = function(name, fn)
    96       if not fn and type(name) == 'function' then
    16         fn = name
    16         name = alias
    80       elseif not fn then
*****0         fn = attributes and attributes.default_fn
             end

             local trace

    96       local ctx = busted.context.get()
   192       if busted.context.parent(ctx) then
   176         trace = busted.getTrace(ctx, 3, name)
             end

             local publish = function(f)
    96         busted.publish({ 'register', descriptor }, name, f, trace, attributes)
             end

   192       if fn then publish(fn) else return publish end
           end

*****0     local edescriptor = alias or descriptor
*****0     busted.executors[edescriptor] = publisher
*****0     busted.export(edescriptor, publisher)

*****0     busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
    96       local ctx = busted.context.get()
    96       local plugin = {
    96         descriptor = descriptor,
    96         attributes = attributes or {},
    96         name = name,
    96         run = fn,
    96         trace = trace,
               starttick = nil,
               endtick = nil,
               starttime = nil,
               endtime = nil,
               duration = nil,
             }

    96       busted.context.attach(plugin)

    96       if not ctx[descriptor] then
    45         ctx[descriptor] = { plugin }
             else
    51         ctx[descriptor][#ctx[descriptor]+1] = plugin
             end
           end)
         end

*****0   function busted.execute(current)
    29     if not current then current = busted.context.get() end
   152     for _, v in pairs(busted.context.children(current)) do
    96       local executor = executors[v.descriptor]
    96       if executor and not busted.skipAll then
   240         busted.safe(v.descriptor, function() executor(v) end, v)
             end
           end
         end

*****0   return busted
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/environment.lua
==============================================================================
*****0 local setfenv = require 'busted.compatibility'.setfenv

       return function(context)

*****0   local environment = {}

         local function getEnv(self, key)
  7072     if not self then return nil end
*****0     return
  6905       self.env and self.env[key] or
 12756       getEnv(context.parent(self), key) or
  6905       _G[key]
         end

         local function setEnv(self, key, value)
*****0     if not self.env then self.env = {} end
*****0     self.env[key] = value
         end

         local function __index(self, key)
  5640     return getEnv(context.get(), key)
         end

         local function __newindex(self, key, value)
*****0     setEnv(context.get(), key, value)
         end

*****0   local env = setmetatable({}, { __index=__index, __newindex=__newindex })

*****0   function environment.wrap(fn)
     8     return setfenv(fn, env)
         end

*****0   function environment.set(key, value)
*****0     local env = context.get('env')

*****0     if not env then
*****0       env = {}
*****0       context.set('env', env)
           end

*****0     env[key] = value
         end
*****0   return environment
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/execute.lua
==============================================================================
     1 local shuffle = require 'busted.utils'.shuffle
     1 local urandom = require 'busted.utils'.urandom
     1 local tablex = require 'pl.tablex'

       local function sort(elements)
*****0   table.sort(elements, function(t1, t2)
*****0     if t1.name and t2.name then
*****0       return t1.name < t2.name
           end
*****0     return t2.name ~= nil
         end)
*****0   return elements
       end

       return function(busted)
     1   local block = require 'busted.block'(busted)

         local function execute(runs, options)
     1     local root = busted.context.get()
     2     local children = tablex.copy(busted.context.children(root))

           local function suite_reset()
*****0       local oldctx = busted.context.get()

*****0       busted.context.clear()
*****0       local ctx = busted.context.get()
*****0       for k, v in pairs(oldctx) do
*****0         ctx[k] = v
             end

*****0       for _, child in ipairs(children) do
*****0         for descriptor, _ in pairs(busted.executors) do
*****0           child[descriptor] = nil
               end
*****0         busted.context.attach(child)
             end

*****0       busted.randomseed = tonumber(options.seed) or urandom() or os.time()
           end

     2     for i = 1, runs do
     1       if i > 1 then
*****0         suite_reset()
*****0         root = busted.context.get()
*****0         busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)
             end

     1       if options.sort then
*****0         sort(busted.context.children(root))
     1       elseif options.shuffle then
*****0         root.randomseed = busted.randomseed
*****0         shuffle(busted.context.children(root), busted.randomseed)
             end

     1       local seed = (busted.randomize and busted.randomseed or nil)
     2       if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
     2         if block.setup(root) then
     1           busted.execute()
               end
     1         block.lazyTeardown(root)
     1         block.teardown(root)
             end
     1       busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)

     1       if busted.skipAll then
               break
             end
           end
         end

     1   return execute
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/init.lua
==============================================================================
       local function init(busted)
*****0   local block = require 'busted.block'(busted)

         local file = function(file)
     8     busted.wrap(file.run)
    16     if busted.safe_publish('file', { 'file', 'start' }, file) then
     8       block.execute('file', file)
           end
     8     busted.safe_publish('file', { 'file', 'end' }, file)
         end

         local describe = function(describe)
    19     local parent = busted.context.parent(describe)
    38     if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
    19       block.execute('describe', describe)
           end
    19     busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
         end

         local it = function(element)
    53     local parent = busted.context.parent(element)
           local finally

   106     if not block.lazySetup(parent) then
             -- skip test if any setup failed
*****0       return
           end

    53     if not element.env then element.env = {} end

    53     block.rejectAll(element)
    53     element.env.finally = function(fn) finally = fn end
    53     element.env.pending = busted.pending

    53     local pass, ancestor = block.execAll('before_each', parent, true)

    53     if pass then
    53       local status = busted.status('success')
   106       if busted.safe_publish('test', { 'test', 'start' }, element, parent) then
   106         status:update(busted.safe('it', element.run, element))
    53         if finally then
*****0           block.reject('pending', element)
*****0           status:update(busted.safe('finally', finally, element))
               end
             else
*****0         status = busted.status('error')
             end
   106       busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))
           end

    53     block.dexecAll('after_each', ancestor, true)
         end

         local pending = function(element)
*****0     local parent = busted.context.parent(element)
*****0     local status = 'pending'
*****0     if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
*****0       status = 'error'
           end
*****0     busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
         end

*****0   busted.register('file', file, { envmode = 'insulate' })

*****0   busted.register('describe', describe)
*****0   busted.register('insulate', 'describe', { envmode = 'insulate' })
*****0   busted.register('expose', 'describe', { envmode = 'expose' })

*****0   busted.register('it', it)

*****0   busted.register('pending', pending, { default_fn = function() end })

*****0   busted.register('before_each', { envmode = 'unwrap' })
*****0   busted.register('after_each', { envmode = 'unwrap' })

*****0   busted.register('lazy_setup', { envmode = 'unwrap' })
*****0   busted.register('lazy_teardown', { envmode = 'unwrap' })
*****0   busted.register('strict_setup', { envmode = 'unwrap' })
*****0   busted.register('strict_teardown', { envmode = 'unwrap' })

*****0   busted.register('setup', 'strict_setup')
*****0   busted.register('teardown', 'strict_teardown')

*****0   busted.register('context', 'describe')
*****0   busted.register('spec', 'it')
*****0   busted.register('test', 'it')

*****0   busted.hide('file')

*****0   local assert = require 'luassert'
*****0   local spy    = require 'luassert.spy'
*****0   local mock   = require 'luassert.mock'
*****0   local stub   = require 'luassert.stub'
*****0   local match  = require 'luassert.match'

         require 'busted.fixtures'  -- just load into the environment, not exposing it

*****0   busted.export('assert', assert)
*****0   busted.export('spy', spy)
*****0   busted.export('mock', mock)
*****0   busted.export('stub', stub)
*****0   busted.export('match', match)

*****0   busted.exportApi('publish', busted.publish)
*****0   busted.exportApi('subscribe', busted.subscribe)
*****0   busted.exportApi('unsubscribe', busted.unsubscribe)

*****0   busted.exportApi('bindfenv', busted.bindfenv)
*****0   busted.exportApi('fail', busted.fail)
*****0   busted.exportApi('gettime', busted.gettime)
*****0   busted.exportApi('monotime', busted.monotime)
*****0   busted.exportApi('sleep', busted.sleep)
*****0   busted.exportApi('parent', busted.context.parent)
*****0   busted.exportApi('children', busted.context.children)
*****0   busted.exportApi('version', busted.version)

*****0   busted.bindfenv(assert, 'error', busted.fail)
*****0   busted.bindfenv(assert.is_true, 'error', busted.fail)

*****0   return busted
       end

*****0 return setmetatable({}, {
         __call = function(self, busted)
*****0     init(busted)

*****0     return setmetatable(self, {
             __index = function(self, key)
   134         return busted.api[key]
             end,

             __newindex = function(self, key, value)
*****0         error('Attempt to modify busted')
             end
           })
         end
       })

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/languages/en.lua
==============================================================================
     1 local s = require('say')

     1 s:set_namespace('en')

       -- 'Pending: test.lua @ 12 \n description
     1 s:set('output.pending', 'Pending')
     1 s:set('output.failure', 'Failure')
     1 s:set('output.error', 'Error')
     1 s:set('output.success', 'Success')

     1 s:set('output.pending_plural', 'pending')
     1 s:set('output.failure_plural', 'failures')
     1 s:set('output.error_plural', 'errors')
     1 s:set('output.success_plural', 'successes')

     1 s:set('output.pending_zero', 'pending')
     1 s:set('output.failure_zero', 'failures')
     1 s:set('output.error_zero', 'errors')
     1 s:set('output.success_zero', 'successes')

     1 s:set('output.pending_single', 'pending')
     1 s:set('output.failure_single', 'failure')
     1 s:set('output.error_single', 'error')
     1 s:set('output.success_single', 'success')

     1 s:set('output.seconds', 'seconds')

     1 s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
     1 s:set('output.file_not_found', 'Cannot find file or directory: %s')

       -- definitions following are not used within the 'say' namespace
     1 return {
     1   failure_messages = {
           'You have %d busted specs',
           'Your specs are busted',
           'Your code is bad and you should feel bad',
           'Your code is in the Danger Zone',
           'Strange game. The only way to win is not to test',
           'My grandmother wrote better specs on a 3 86',
           'Every time there\'s a failure, drink another beer',
           'Feels bad man'
     1   },
     1   success_messages = {
           'Aww yeah, passing specs',
           'Doesn\'t matter, had specs',
           'Feels good, man',
           'Great success',
           'Tests pass, drink another beer',
     1   }
     1 }

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/luajit.lua
==============================================================================
     1 local isJit = (tostring(assert):match('builtin') ~= nil)

     1 if not isJit then
*****0   return function() end
       end

       -- pre-load the ffi module, such that it becomes part of the environment
       -- and Busted will not try to GC and reload it. The ffi is not suited
       -- for that and will occasionally segfault if done so.
     1 local ffi = require "ffi"


       -- patching assumes;
       --  * first parameter to be a unique key to identify repeated calls
       --  * only a single return value

       local function patch_with_return_value(func_name)
     3   local original = ffi[func_name]
     3   local original_store = {}

     3   ffi[func_name] = function (primary, ...)
*****0     if original_store[primary] then
*****0       return original_store[primary]
           end
*****0     local success, result, err = pcall(original, primary, ...)
*****0     if not success then
             -- hard error was thrown
*****0       error(result, 2)
           end
*****0     if not result then
             -- soft error was returned
*****0       return result, err
           end
           -- it worked, store and return
*****0     original_store[primary] = result
*****0     return result
         end
       end

       local function patch_without_return_value(func_name)
     1   local original = ffi[func_name]
     1   local original_store = {}

     1   ffi[func_name] = function (primary, ...)
     8     if original_store[primary] then
     7       return
           end
     1     local success, result = pcall(original, primary, ...)
     1     if not success then
             -- hard error was thrown
*****0       error(result, 2)
           end
           -- store and return
     1     original_store[primary] = true
     1     return result
         end
       end

       return function()
     1     patch_without_return_value("cdef")
     1     patch_with_return_value("typeof")
     1     patch_with_return_value("metatype")
     1     patch_with_return_value("load")
         end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/files/lua.lua
==============================================================================
     1 local path = require 'pl.path'

     1 local ret = {}

       local getTrace = function(filename, info)
    88   local index = info.traceback:find('\n%s*%[C]')
   176   info.traceback = info.traceback:sub(1, index)
    88   return info
       end

       ret.match = function(busted, filename)
    16   return path.extension(filename) == '.lua'
       end

       ret.load = function(busted, filename)
     8   local file, err = loadfile(filename)
     8   if not file then
*****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
         end
     8   return file, getTrace
       end

     1 return ret

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/files/moonscript.lua
==============================================================================
     1 local path = require 'pl.path'

     2 local ok, moonscript, line_tables, util = pcall(function()
     1   return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
       end)

     1 local _cache = {}

       -- find the line number of `pos` chars into fname
       local lookup_line = function(fname, pos)
*****0   if not _cache[fname] then
*****0     local f = io.open(fname)
*****0     _cache[fname] = f:read('*a')
*****0     f:close()
         end

*****0   return util.pos_to_line(_cache[fname], pos)
       end

       local rewrite_linenumber = function(fname, lineno)
*****0   local tbl = line_tables['@' .. fname]
*****0   if fname and tbl then
*****0     for i = lineno, 0 ,-1 do
*****0       if tbl[i] then
*****0         return lookup_line(fname, tbl[i])
             end
           end
         end

*****0   return lineno
       end

       local rewrite_filename = function(filename)
         -- sometimes moonscript gives files like [string "./filename.moon"], so
         -- we'll chop it up to only get the filename.
*****0   return filename:match('string "(.+)"') or filename
       end

       local rewrite_traceback = function(fname, trace)
         local rewrite_one = function(line, pattern, sub)
*****0     if line == nil then return '' end

*****0     local fname, lineno = line:match(pattern)

*****0     if fname and lineno then
*****0       fname = rewrite_filename(fname)
*****0       local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
*****0       if new_lineno then
*****0         line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
             end
           end

*****0     return line
         end

*****0   local lines = {}
*****0   local j = 0

*****0   for line in trace:gmatch('[^\r\n]+') do
*****0     j = j + 1
*****0     line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
*****0     line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')
*****0     lines[j] = line
         end

*****0   return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
       end

     1 local ret = {}

       local getTrace = function(filename, info)
*****0   local index = info.traceback:find('\n%s*%[C]')
*****0   info.traceback = info.traceback:sub(1, index)

*****0   info.short_src = rewrite_filename(info.short_src)
*****0   info.traceback = rewrite_traceback(filename, info.traceback)
*****0   info.linedefined = rewrite_linenumber(filename, info.linedefined)
*****0   info.currentline = rewrite_linenumber(filename, info.currentline)

*****0   return info
       end

       local rewriteMessage = function(filename, message)
*****0   local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
*****0   if not fname then
*****0     return message
         end

*****0   fname = rewrite_filename(fname)
*****0   line = rewrite_linenumber(fname, tonumber(line))

*****0   return fname .. ':' .. tostring(line) .. ': ' .. msg
       end

       ret.match = function(busted, filename)
*****0   return ok and path.extension(filename) == '.moon'
       end

       ret.load = function(busted, filename)
*****0   local file, err = moonscript.loadfile(filename)
*****0   if not file then
*****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
         end
*****0   return file, getTrace, rewriteMessage
       end

     1 return ret

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/filter_loader.lua
==============================================================================
       return function()
         local function filter(busted, options)
           local getFullName = function(name)
    53       local parent = busted.context.get()
    53       local names = { name }

   117       while parent and (parent.name or parent.descriptor) and
   117             parent.descriptor ~= 'file' do
    64         table.insert(names, 1, parent.name or parent.descriptor)
   128         parent = busted.context.parent(parent)
             end

    53       return table.concat(names, ' ')
           end

           local hasTag = function(name, tag)
*****0       local found = name:find('#' .. tag)
*****0       return (found ~= nil)
           end

           local filterExcludeTags = function(name)
    72       for i, tag in pairs(options.excludeTags) do
*****0         if hasTag(name, tag) then
*****0           return nil, false
               end
             end
    72       return nil, true
           end

           local filterTags = function(name)
    53       local fullname = getFullName(name)
    53       for i, tag in pairs(options.tags) do
*****0         if hasTag(fullname, tag) then
*****0           return nil, true
               end
             end
    53       return nil, (#options.tags == 0)
           end

           local filterOutNames = function(name)
    72       for _, filter in pairs(options.filterOut) do
*****0         if getFullName(name):find(filter) ~= nil then
*****0           return nil, false
               end
             end
    72       return nil, true
           end

     1     local excludeNames = {}
     1     if options.excludeNamesFile then
*****0       for name in io.lines(options.excludeNamesFile) do
*****0         table.insert(excludeNames, name)
             end
           end

           local excludeNamesFile = function(name)
*****0       for _, filter in ipairs(excludeNames) do
*****0         if getFullName(name) == filter then
*****0           return nil, false
               end
             end
*****0       return nil, true
           end

           local name = function(name)
    72       for _, candidate in pairs(options.name) do
*****0         if string.find(candidate, getFullName(name), 1, true) then
*****0           return nil, true
               end
             end
    72       return nil, (#options.name == 0)
           end

           local filterNames = function(name)
    53       for _, filter in pairs(options.filter) do
*****0         if getFullName(name):find(filter) ~= nil then
*****0           return nil, true
               end
             end
    53       return nil, (#options.filter == 0)
           end

           local printTestName = function(element, parent, status)
*****0       if not (options.suppressPending and status == 'pending') then
*****0         local fullname = getFullName()
*****0         local trace = element.trace
*****0         if trace and trace.what == 'Lua' then
*****0           fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname
               end
*****0         print(fullname)
             end
*****0       return nil, false
           end

           local ignoreAll = function()
*****0       return nil, false
           end

     1     local noop = function() end
           local stubOut = function(descriptor, name, fn, ...)
*****0       if fn == noop then
*****0         return nil, true
             end
*****0       busted.publish({ 'register', descriptor }, name, noop, ...)
*****0       return nil, false
           end

           local skipOnError = function()
*****0       return nil, not busted.skipAll
           end

           local applyFilter = function(descriptors, name, fn)
    10       if options[name] and options[name] ~= '' then
    18         for _, descriptor in ipairs(descriptors) do
    13           busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
               end
             end
           end

           local applyDescFilter = function(descriptors, name, fn)
*****0       if options[name] and options[name] ~= '' then
*****0         for _, descriptor in ipairs(descriptors) do
*****0           local f = function(...) return fn(descriptor, ...) end
*****0           busted.subscribe({ 'register', descriptor }, f, { priority = 1 })
               end
             end
           end

     1     if options.list then
*****0       busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })
*****0       busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })
*****0       applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)
*****0       applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)
*****0       applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)
*****0       applyDescFilter({ 'it', 'pending' }, 'list', stubOut)
           end

     1     applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
     1     applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
     1     applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
     1     applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)

           -- The following filters are applied in reverse order
     1     applyFilter({ 'it', 'pending' }            , 'filter'          , filterNames           )
     1     applyFilter({ 'describe', 'it', 'pending' }, 'name'            , name                  )
     1     applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'       , filterOutNames        )
     1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeNamesFile', excludeNamesFile      )
     1     applyFilter({ 'it', 'pending' }            , 'tags'            , filterTags            )
     1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags'     , filterExcludeTags     )
         end

*****0   return filter
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/output_handler_loader.lua
==============================================================================
*****0 local path = require 'pl.path'
*****0 local hasMoon, moonscript = pcall(require, 'moonscript')
*****0 local utils = require 'busted.utils'

       return function()
         local loadOutputHandler = function(busted, output, options)
           local handler

     1     utils.copy_interpreter_args(options.arguments)
     2     local success, err = pcall(function()
     1       if output:match('%.lua$') then
*****0         handler = dofile(path.normpath(output))
     1       elseif hasMoon and output:match('%.moon$') then
*****0         handler = moonscript.dofile(path.normpath(output))
             else
     1         handler = require('busted.outputHandlers.' .. output)
             end
           end)

     1     if not success and err:match("module '.-' not found:") then
*****0       success, err = pcall(function() handler = require(output) end)
           end

     1     if not success then
*****0       busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
*****0       handler = require('busted.outputHandlers.' .. options.defaultOutput)
           end

     1     if options.enableSound then
*****0       require 'busted.outputHandlers.sound'(options)
           end

     2     handler(options):subscribe(options)
         end

*****0   return loadOutputHandler
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/test_file_loader.lua
==============================================================================
     1 local s = require 'say'

       return function(busted, loaders)
     1   local path = require 'pl.path'
     1   local dir = require 'pl.dir'
     1   local tablex = require 'pl.tablex'
     1   local fileLoaders = {}

     3   for _, v in pairs(loaders) do
     2     local loader = require('busted.modules.files.'..v)
     2     fileLoaders[#fileLoaders+1] = loader
         end

         local getTestFiles = function(rootFile, patterns, options)
           local fileList

     2     if path.isfile(rootFile) then
*****0       fileList = { rootFile }
     2     elseif path.isdir(rootFile) then
     1       local getfiles = options.recursive and dir.getallfiles or dir.getfiles
     2       fileList = getfiles(rootFile)

     2       fileList = tablex.filter(fileList, function(filename)
     9         local basename = path.basename(filename)
     9         for _, patt in ipairs(options.excludes) do
*****0           if patt ~= '' and basename:find(patt) then
*****0             return nil
                 end
               end
    10         for _, patt in ipairs(patterns) do
     9           if basename:find(patt) then
     8             return true
                 end
               end
     1         return #patterns == 0
             end)

     2       fileList = tablex.filter(fileList, function(filename)
     8         if path.is_windows then
*****0           return not filename:find('%\\%.%w+.%w+', #rootFile)
               else
     8           return not filename:find('/%.%w+.%w+', #rootFile)
               end
             end)
           else
*****0       busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})
*****0       fileList = {}
           end

     1     table.sort(fileList)
     1     return fileList
         end

         local getAllTestFiles = function(rootFiles, patterns, options)
     1     local fileList = {}
     2     for _, root in ipairs(rootFiles) do
     2       tablex.insertvalues(fileList, getTestFiles(root, patterns, options))
           end
     1     return fileList
         end

         -- runs a testfile, loading its tests
         local loadTestFile = function(busted, filename)
     8     for _, v in pairs(fileLoaders) do
    16       if v.match(busted, filename) then
     8         return v.load(busted, filename)
             end
           end
         end

         local loadTestFiles = function(rootFiles, patterns, options)
     1     local fileList = getAllTestFiles(rootFiles, patterns, options)

     9     for i, fileName in ipairs(fileList) do
     8       local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)

     8       if testFile then
    16         local file = setmetatable({
     8           getTrace = getTrace,
     8           rewriteMessage = rewriteMessage
     8         }, {
     8           __call = testFile
               })

     8         busted.executors.file(fileName, file)
             end
           end

     1     if #fileList == 0 then
*****0       local pattern = patterns[1]
*****0       if #patterns > 1 then
*****0         pattern = '\n\t' .. table.concat(patterns, '\n\t')
             end
*****0       busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
           end

     1     return fileList
         end

     1   return loadTestFiles, loadTestFile, getAllTestFiles
       end


==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/TAP.lua
==============================================================================
     1 local pretty = require 'pl.pretty'
     1 local io = io
     1 local type = type
     1 local string_format = string.format
     1 local string_gsub = string.gsub
     1 local io_write = io.write
     1 local io_flush = io.flush

       local function print(msg)
    54   io_write(msg .. '\n')
       end

       return function(options)
     1   local busted = require 'busted'
     1   local handler = require 'busted.outputHandlers.base'()

     1   local success = 'ok %u - %s'
     1   local failure = 'not ' .. success
     1   local skip = 'ok %u - # SKIP %s'
     1   local counter = 0

         handler.suiteReset = function()
*****0     counter = 0
*****0     return nil, true
         end

         handler.suiteEnd = function()
     1     print('1..' .. counter)
     1     io_flush()
     1     return nil, true
         end

         local function showFailure(t)
*****0     local message = t.message
*****0     local trace = t.trace or {}

*****0     if message == nil then
*****0       message = 'Nil error'
*****0     elseif type(message) ~= 'string' then
*****0       message = pretty.write(message)
           end

*****0     print(string_format(failure, counter, t.name))
*****0     if t.element.trace.short_src then
*****0       print('# ' .. t.element.trace.short_src .. ' @ ' .. t.element.trace.currentline)
           end
*****0     if t.randomseed then
*****0       print('# Random seed: ' .. t.randomseed)
           end
*****0     print('# Failure message: ' .. string_gsub(message, '\n', '\n# '))
*****0     if options.verbose and trace.traceback then
*****0       print('# ' .. string_gsub(string_gsub(trace.traceback, '^\n', '', 1), '\n', '\n# '))
           end
         end

         handler.testStart = function(element, parent)
    53     local trace = element.trace
    53     if options.verbose and trace and trace.short_src then
*****0       local fileline = trace.short_src .. ' @ ' ..  trace.currentline .. ': '
*****0       local testName = fileline .. handler.getFullName(element)
*****0       print('# ' .. testName)
           end
    53     io.flush()

    53     return nil, true
         end

         handler.testEnd = function(element, parent, status, trace)
    53     counter = counter + 1
    53     if status == 'success' then
    53       local t = handler.successes[#handler.successes]
   106       print(string_format(success, counter, t.name))
*****0     elseif status == 'pending' then
*****0       local t = handler.pendings[#handler.pendings]
*****0       print(string_format(skip, counter, (t.message or t.name)))
*****0     elseif status == 'failure' then
*****0       showFailure(handler.failures[#handler.failures])
*****0     elseif status == 'error' then
*****0       showFailure(handler.errors[#handler.errors])
           end
    53     io.flush()

    53     return nil, true
         end

         handler.error = function(element, parent, message, debug)
*****0     if element.descriptor ~= 'it' then
*****0       counter = counter + 1
*****0       showFailure(handler.errors[#handler.errors])
           end
*****0     io.flush()

*****0     return nil, true
         end

     2   busted.subscribe({ 'suite', 'reset' }, handler.suiteReset)
     2   busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
     2   busted.subscribe({ 'test', 'start' }, handler.testStart, { predicate = handler.cancelOnPending })
     2   busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
     2   busted.subscribe({ 'error' }, handler.error)

     1   return handler
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/base.lua
==============================================================================
     1 local table_concat = table.concat
     1 local table_insert = table.insert

       return function()
     1   local busted = require 'busted'
     1   local handler = {
     1     successes = {},
           successesCount = 0,
     1     pendings = {},
           pendingsCount = 0,
     1     failures = {},
           failuresCount = 0,
     1     errors = {},
           errorsCount = 0,
     1     inProgress = {}
         }

         handler.cancelOnPending = function(element, parent, status)
   212     return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
         end

         handler.subscribe = function(handler, options)
     1     require('busted.languages.en')
     1     handler.options = options

     1     if options.language ~= 'en' then
*****0       require('busted.languages.' .. options.language)
           end

     2     busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
     2     busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
     2     busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
     2     busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
     2     busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
     2     busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
     2     busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
     2     busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
     2     busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
     2     busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
         end

         handler.getFullName = function(context)
   106     local parent = busted.parent(context)
    53     local names = { (context.name or context.descriptor) }

   117     while parent and (parent.name or parent.descriptor) and
   117           parent.descriptor ~= 'file' do

    64       table_insert(names, 1, parent.name or parent.descriptor)
   192       parent = busted.parent(parent)
           end

    53     return table_concat(names, ' ')
         end

         handler.format = function(element, parent, message, debug, isError)
           local function copyElement(e)
    53       local copy = {}
   636       for k,v in next, e do
   583         if type(v) ~= 'function' and k ~= 'env' then
   477           copy[k] = v
               end
             end
    53       return copy
           end

    53     local formatted = {
    53       trace = debug or element.trace,
   106       element = copyElement(element),
   106       name = handler.getFullName(element),
    53       message = message,
    53       randomseed = parent and parent.randomseed,
    53       isError = isError
           }
    53     formatted.element.trace = element.trace or debug

    53     return formatted
         end

         handler.getDuration = function()
*****0     if not handler.endTick or not handler.startTick then
*****0       return 0
           end

*****0     return handler.endTick - handler.startTick
         end

         handler.baseSuiteStart = function(suite)
     1     handler.startTick = suite.starttick
     1     handler.startTime = suite.starttime
     1     return nil, true
         end

         handler.baseSuiteReset = function()
*****0     handler.successes = {}
*****0     handler.successesCount = 0
*****0     handler.pendings = {}
*****0     handler.pendingsCount = 0
*****0     handler.failures = {}
*****0     handler.failuresCount = 0
*****0     handler.errors = {}
*****0     handler.errorsCount = 0
*****0     handler.inProgress = {}

*****0     return nil, true
         end

         handler.baseSuiteEnd = function(suite)
     1     handler.endTick = suite.endtick
     1     handler.endTime = suite.endtime
     1     return nil, true
         end

         handler.baseTestStart = function(element, parent)
    53     handler.inProgress[tostring(element)] = {}
    53     return nil, true
         end

         handler.baseTestEnd = function(element, parent, status, debug)
           local insertTable

    53     if status == 'success' then
    53       insertTable = handler.successes
    53       handler.successesCount = handler.successesCount + 1
*****0     elseif status == 'pending' then
*****0       insertTable = handler.pendings
*****0       handler.pendingsCount = handler.pendingsCount + 1
*****0     elseif status == 'failure' then
             -- failure already saved in failure handler
*****0       handler.failuresCount = handler.failuresCount + 1
*****0       return nil, true
*****0     elseif status == 'error' then
             -- error count already incremented and saved in error handler
*****0       return nil, true
           end

    53     local formatted = handler.format(element, parent, element.message, debug)

    53     local id = tostring(element)
    53     if handler.inProgress[id] then
    53       for k, v in pairs(handler.inProgress[id]) do
*****0         formatted[k] = v
             end

    53       handler.inProgress[id] = nil
           end

    53     table_insert(insertTable, formatted)

    53     return nil, true
         end

         handler.basePending = function(element, parent, message, debug)
*****0     local id = tostring(element)
*****0     handler.inProgress[id].message = message
*****0     handler.inProgress[id].trace = debug
*****0     return nil, true
         end

         handler.baseTestFailure = function(element, parent, message, debug)
*****0     table_insert(handler.failures, handler.format(element, parent, message, debug))
*****0     return nil, true
         end

         handler.baseTestError = function(element, parent, message, debug)
*****0     handler.errorsCount = handler.errorsCount + 1
*****0     table_insert(handler.errors, handler.format(element, parent, message, debug, true))
*****0     return nil, true
         end

         handler.baseError = function(element, parent, message, debug)
*****0     if element.descriptor ~= 'it' then
*****0       handler.errorsCount = handler.errorsCount + 1
*****0       table_insert(handler.errors, handler.format(element, parent, message, debug, true))
           end

*****0     return nil, true
         end

     1   return handler
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/vusted/default.lua
==============================================================================
       return function(options)
     1   local busted = require("busted")
     1   local handler = require("busted.outputHandlers.TAP")(options)

         -- avoid using print not to affect message history.
     1   local write = io.write

         local suite_start = function(suite)
     1     if suite.randomseed then
             -- NOTE: can know random seed even if neovim crashes
*****0       write(("# Random seed: %s\n"):format(suite.randomseed))
           end
     1     return nil, true
         end
     2   busted.subscribe({ "suite", "start" }, suite_start)

         local test_path = function(t)
*****0     local trace = t.element.trace
*****0     if not (trace and trace.source) then
*****0       return nil
           end
*****0     local source = trace.source:gsub("^@", "")
*****0     return ("%s:%d : %s"):format(source, trace.currentline, t.name)
         end

         local show_test_paths = function(tests)
*****0     for _, test in ipairs(tests) do
*****0       local path = test_path(test)
*****0       if path then
*****0         write(("#   %s\n"):format(path))
             end
           end
         end

         local show_slows = function(tests)
     1     local env_threshold = os.getenv("VUSTED_SLOW_MS")
     1     if not env_threshold then
     1       return
           end
*****0     local threshold = tonumber(env_threshold)

*****0     local slows = {}
*****0     for _, t in ipairs(tests) do
*****0       local ms = t.element.duration * 1000
*****0       if ms >= threshold then
*****0         table.insert(slows, { duration = ms, path = test_path(t) })
             end
           end
*****0     if #slows == 0 then
*****0       return
           end

*****0     table.sort(slows, function(a, b)
*****0       return a.duration > b.duration
           end)

*****0     write(("# Slow: %d (threshold: %.2f ms)\n"):format(#slows, threshold))
*****0     for _, slow in ipairs(slows) do
*****0       write(("#   %s (%.2f ms)\n"):format(slow.path, slow.duration))
           end
         end

         local suite_end = function()
     1     write("\n\n")

     1     write(("# Success: %d\n"):format(#handler.successes))

     1     if #handler.failures > 0 then
*****0       write(("# Failure: %d\n"):format(#handler.failures))
*****0       show_test_paths(handler.failures)
           end

     1     if #handler.pendings > 0 then
*****0       write(("# Pending: %d\n"):format(#handler.pendings))
*****0       show_test_paths(handler.pendings)
           end

     1     if #handler.errors > 0 then
*****0       write(("# Error: %d\n"):format(#handler.errors))
*****0       show_test_paths(handler.errors)
           end

     1     show_slows(handler.successes)

     1     return nil, true
         end
     2   busted.subscribe({ "suite", "end" }, suite_end)

     1   return handler
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/runner.lua
==============================================================================
       -- Busted command-line runner

*****0 local path = require 'pl.path'
*****0 local tablex = require 'pl.tablex'
*****0 local term = require 'term'
*****0 local utils = require 'busted.utils'
*****0 local exit = require 'busted.compatibility'.exit
*****0 local loadstring = require 'busted.compatibility'.loadstring
*****0 local loaded = false

       return function(options)
*****0   if loaded then return function() end else loaded = true end

*****0   local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)
*****0   options = tablex.update(require 'busted.options', options or {})
*****0   options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')

*****0   local busted = require 'busted.core'()

*****0   local cli = require 'busted.modules.cli'(options)
*****0   local filterLoader = require 'busted.modules.filter_loader'()
*****0   local helperLoader = require 'busted.modules.helper_loader'()
*****0   local outputHandlerLoader = require 'busted.modules.output_handler_loader'()

*****0   local luacov = require 'busted.modules.luacov'()

*****0   require 'busted'(busted)

*****0   local level = 2
*****0   local info = debug.getinfo(level, 'Sf')
*****0   local source = info.source
*****0   local fileName = source:sub(1,1) == '@' and source:sub(2) or nil
*****0   local forceExit = fileName == nil

         -- Parse the cli arguments
*****0   local appName = path.basename(fileName or 'busted')
*****0   cli:set_name(appName)
*****0   local cliArgs, err = cli:parse(arg)
*****0   if not cliArgs then
*****0     io.stderr:write(err .. '\n')
*****0     exit(1, forceExit)
         end

*****0   if cliArgs.version then
           -- Return early if asked for the version
*****0     print(busted.version)
*****0     exit(0, forceExit)
         end

         -- Load current working directory
*****0   local _, err = path.chdir(path.normpath(cliArgs.directory))
*****0   if err then
*****0     io.stderr:write(appName .. ': error: ' .. err .. '\n')
*****0     exit(1, forceExit)
         end

         -- If coverage arg is passed in, load LuaCovsupport
*****0   if cliArgs.coverage then
*****0     local ok, err = luacov(cliArgs['coverage-config-file'])
     1     if not ok then
*****0       io.stderr:write(appName .. ': error: ' .. err .. '\n')
*****0       exit(1, forceExit)
           end
         end

         -- If auto-insulate is disabled, re-register file without insulation
     1   if not cliArgs['auto-insulate'] then
*****0     busted.register('file', 'file', {})
         end

         -- If lazy is enabled, make lazy setup/teardown the default
     1   if cliArgs.lazy then
*****0     busted.register('setup', 'lazy_setup')
*****0     busted.register('teardown', 'lazy_teardown')
         end

         -- Add additional package paths based on lpath and cpath cliArgs
     1   if #cliArgs.lpath > 0 then
     1     package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
         end

     1   if #cliArgs.cpath > 0 then
     1     package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
         end

         -- Load and execute commands given on the command-line
     1   if cliArgs.e then
     1     for k,v in ipairs(cliArgs.e) do
*****0       loadstring(v)()
           end
         end

         -- watch for test errors and failures
     1   local failures = 0
     1   local errors = 0
     1   local quitOnError = not cliArgs['keep-going']

     2   busted.subscribe({ 'error', 'output' }, function(element, parent, message)
*****0     io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
*****0     return nil, true
         end)

     2   busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
*****0     io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
*****0     return nil, true
         end)

     2   busted.subscribe({ 'error' }, function(element, parent, message)
*****0     errors = errors + 1
*****0     busted.skipAll = quitOnError
*****0     return nil, true
         end)

     2   busted.subscribe({ 'failure' }, function(element, parent, message)
*****0     if element.descriptor == 'it' then
*****0       failures = failures + 1
           else
*****0       errors = errors + 1
           end
*****0     busted.skipAll = quitOnError
*****0     return nil, true
         end)

         -- Set up randomization options
     1   busted.sort = cliArgs['sort-tests']
     1   busted.randomize = cliArgs['shuffle-tests']
     2   busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()

         -- Set up output handler to listen to events
     2   outputHandlerLoader(busted, cliArgs.output, {
     1     defaultOutput = options.output,
     1     enableSound = cliArgs['enable-sound'],
     1     verbose = cliArgs.verbose,
     1     suppressPending = cliArgs['suppress-pending'],
     1     language = cliArgs.lang,
     1     deferPrint = cliArgs['defer-print'],
     1     arguments = cliArgs.Xoutput,
         })

         -- Pre-load the LuaJIT 'ffi' module if applicable
     1   require 'busted.luajit'()

         -- Set up helper script, must succeed to even start tests
     1   if cliArgs.helper and cliArgs.helper ~= '' then
*****0     local ok, err = helperLoader(busted, cliArgs.helper, {
             verbose = cliArgs.verbose,
             language = cliArgs.lang,
*****0       arguments = cliArgs.Xhelper
           })
*****0     if not ok then
*****0       io.stderr:write(appName .. ': failed running the specified helper (' ..
*****0                       cliArgs.helper .. '), error: ' .. err .. '\n')
*****0       exit(1, forceExit)
           end
         end

         local getFullName = function(name)
*****0     local parent = busted.context.get()
*****0     local names = { name }

*****0     while parent and (parent.name or parent.descriptor) and
*****0       parent.descriptor ~= 'file' do
*****0       table.insert(names, 1, parent.name or parent.descriptor)
*****0       parent = busted.context.parent(parent)
           end

*****0     return table.concat(names, ' ')
         end

     1   if cliArgs['log-success'] then
*****0     local logFile = assert(io.open(cliArgs['log-success'], 'a'))
*****0     busted.subscribe({ 'test', 'end' }, function (test, parent, status)
*****0       if status == "success" then
*****0         logFile:write(getFullName() .. "\n")
             end
           end)
         end

         -- Load tag and test filters
     2   filterLoader(busted, {
     1     tags = cliArgs.tags,
     1     excludeTags = cliArgs['exclude-tags'],
     1     filter = cliArgs.filter,
     1     name = cliArgs.name,
     1     filterOut = cliArgs['filter-out'],
     1     excludeNamesFile = cliArgs['exclude-names-file'],
     1     list = cliArgs.list,
     1     nokeepgoing = not cliArgs['keep-going'],
     1     suppressPending = cliArgs['suppress-pending'],
         })

     1   if cliArgs.ROOT then
           -- Load test directories/files
     1     local rootFiles = cliArgs.ROOT
     1     local patterns = cliArgs.pattern
     1     local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
     2     testFileLoader(rootFiles, patterns, {
     1       excludes = cliArgs['exclude-pattern'],
     1       verbose = cliArgs.verbose,
     1       recursive = cliArgs['recursive'],
     1     })
         else
           -- Running standalone, use standalone loader
*****0     local testFileLoader = require 'busted.modules.standalone_loader'(busted)
*****0     testFileLoader(info, { verbose = cliArgs.verbose })
         end

     1   local runs = cliArgs['repeat']
     1   local execute = require 'busted.execute'(busted)
     2   execute(runs, {
     1     seed = cliArgs.seed,
     1     shuffle = cliArgs['shuffle-files'],
     1     sort = cliArgs['sort-files'],
         })

     1   busted.publish({ 'exit' })

     1   if options.standalone or failures > 0 or errors > 0 then
*****0     exit(failures + errors, forceExit)
         end
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/status.lua
==============================================================================
       local function get_status(status)
   523   local smap = {
           ['success'] = 'success',
           ['pending'] = 'pending',
           ['failure'] = 'failure',
           ['error'] = 'error',
           ['true'] = 'success',
           ['false'] = 'failure',
           ['nil'] = 'error',
         }
   576   return smap[tostring(status)] or 'error'
       end

       return function(inital_status)
   470   local objstat = get_status(inital_status)
   470   local obj = {
   754     success = function(self) return (objstat == 'success') end,
   470     pending = function(self) return (objstat == 'pending') end,
   470     failure = function(self) return (objstat == 'failure') end,
   470     error   = function(self) return (objstat == 'error') end,

           get = function(self)
*****0       return objstat
           end,

           set = function(self, status)
*****0       objstat = get_status(status)
           end,

           update = function(self, status)
             -- prefer current failure/error status over new status
   106       status = get_status(status)
    53       if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
    53         objstat = status
             end
           end
         }

   470   return setmetatable(obj, {
   470     __index = {},
   576     __tostring = function(self) return objstat end
   470   })
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/utils.lua
==============================================================================
*****0 return {
         copy_interpreter_args = function(arguments)
           -- copy non-positive command-line args auto-inserted by Lua interpreter
     1     if arguments and _G.arg then
     1       local i = 0
     1       while _G.arg[i] do
*****0         arguments[i] = _G.arg[i]
*****0         i = i - 1
             end
           end
         end,

         split = require 'pl.utils'.split,

         shuffle = function(t, seed)
*****0     if seed then math.randomseed(seed) end
*****0     local n = #t
*****0     while n >= 2 do
*****0       local k = math.random(n)
*****0       t[n], t[k] = t[k], t[n]
*****0       n = n - 1
           end
*****0     return t
         end,

         urandom = function()
     1     local f = io.open('/dev/urandom', 'rb')
     1     if not f then return nil end
     1     local s = f:read(4) f:close()
     1     local bytes = {s:byte(1, 4)}
     1     local value = 0
     5     for _, v in ipairs(bytes) do
     4       value = value * 256 + v
           end
     1     return value
         end,
       }

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/inspect.lua
==============================================================================
     1 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local math = _tl_compat and _tl_compat.math or math; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table
     1 local inspect = {Options = {}, }

















     1 inspect._VERSION = 'inspect.lua 3.1.0'
     1 inspect._URL = 'http://github.com/kikito/inspect.lua'
     1 inspect._DESCRIPTION = 'human-readable representations of tables'
       inspect._LICENSE = [[
         MIT LICENSE

         Copyright (c) 2022 Enrique García Cota

         Permission is hereby granted, free of charge, to any person obtaining a
         copy of this software and associated documentation files (the
         "Software"), to deal in the Software without restriction, including
         without limitation the rights to use, copy, modify, merge, publish,
         distribute, sublicense, and/or sell copies of the Software, and to
         permit persons to whom the Software is furnished to do so, subject to
         the following conditions:

         The above copyright notice and this permission notice shall be included
         in all copies or substantial portions of the Software.

         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
         OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
         MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
         IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
         CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
         TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
         SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     1 ]]
     1 inspect.KEY = setmetatable({}, { __tostring = function() return 'inspect.KEY' end })
     1 inspect.METATABLE = setmetatable({}, { __tostring = function() return 'inspect.METATABLE' end })

     1 local tostring = tostring
     1 local rep = string.rep
     1 local match = string.match
     1 local char = string.char
     1 local gsub = string.gsub
     1 local fmt = string.format

       local function rawpairs(t)
*****0    return next, t, nil
       end



       local function smartQuote(str)
*****0    if match(str, '"') and not match(str, "'") then
*****0       return "'" .. str .. "'"
          end
*****0    return '"' .. gsub(str, '"', '\\"') .. '"'
       end


     1 local shortControlCharEscapes = {
          ["\a"] = "\\a", ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
          ["\r"] = "\\r", ["\t"] = "\\t", ["\v"] = "\\v", ["\127"] = "\\127",
       }
     1 local longControlCharEscapes = { ["\127"] = "\127" }
    33 for i = 0, 31 do
    32    local ch = char(i)
    32    if not shortControlCharEscapes[ch] then
    25       shortControlCharEscapes[ch] = "\\" .. i
    25       longControlCharEscapes[ch] = fmt("\\%03d", i)
          end
       end

       local function escape(str)
*****0    return (gsub(gsub(gsub(str, "\\", "\\\\"),
*****0    "(%c)%f[0-9]", longControlCharEscapes),
*****0    "%c", shortControlCharEscapes))
       end

       local function isIdentifier(str)
*****0    return type(str) == "string" and not not str:match("^[_%a][_%a%d]*$")
       end

     1 local flr = math.floor
       local function isSequenceKey(k, sequenceLength)
*****0    return type(k) == "number" and
*****0    flr(k) == k and
*****0    1 <= (k) and
*****0    k <= sequenceLength
       end

     1 local defaultTypeOrders = {
          ['number'] = 1, ['boolean'] = 2, ['string'] = 3, ['table'] = 4,
          ['function'] = 5, ['userdata'] = 6, ['thread'] = 7,
       }

       local function sortKeys(a, b)
*****0    local ta, tb = type(a), type(b)


*****0    if ta == tb and (ta == 'string' or ta == 'number') then
*****0       return (a) < (b)
          end

*****0    local dta = defaultTypeOrders[ta] or 100
*****0    local dtb = defaultTypeOrders[tb] or 100


*****0    return dta == dtb and ta < tb or dta < dtb
       end

       local function getKeys(t)

*****0    local seqLen = 1
*****0    while rawget(t, seqLen) ~= nil do
*****0       seqLen = seqLen + 1
          end
*****0    seqLen = seqLen - 1

*****0    local keys, keysLen = {}, 0
*****0    for k in rawpairs(t) do
*****0       if not isSequenceKey(k, seqLen) then
*****0          keysLen = keysLen + 1
*****0          keys[keysLen] = k
             end
          end
*****0    table.sort(keys, sortKeys)
*****0    return keys, keysLen, seqLen
       end

       local function countCycles(x, cycles)
     1    if type(x) == "table" then
*****0       if cycles[x] then
*****0          cycles[x] = cycles[x] + 1
             else
*****0          cycles[x] = 1
*****0          for k, v in rawpairs(x) do
*****0             countCycles(k, cycles)
*****0             countCycles(v, cycles)
                end
*****0          countCycles(getmetatable(x), cycles)
             end
          end
       end

       local function makePath(path, a, b)
*****0    local newPath = {}
*****0    local len = #path
*****0    for i = 1, len do newPath[i] = path[i] end

*****0    newPath[len + 1] = a
*****0    newPath[len + 2] = b

*****0    return newPath
       end


       local function processRecursive(process,
          item,
          path,
          visited)
*****0    if item == nil then return nil end
*****0    if visited[item] then return visited[item] end

*****0    local processed = process(item, path)
*****0    if type(processed) == "table" then
*****0       local processedCopy = {}
*****0       visited[item] = processedCopy
             local processedKey

*****0       for k, v in rawpairs(processed) do
*****0          processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
*****0          if processedKey ~= nil then
*****0             processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
                end
             end

*****0       local mt = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
*****0       if type(mt) ~= 'table' then mt = nil end
*****0       setmetatable(processedCopy, mt)
*****0       processed = processedCopy
          end
*****0    return processed
       end

       local function puts(buf, str)
     1    buf.n = buf.n + 1
     1    buf[buf.n] = str
       end



     1 local Inspector = {}










     1 local Inspector_mt = { __index = Inspector }

       local function tabify(inspector)
*****0    puts(inspector.buf, inspector.newline .. rep(inspector.indent, inspector.level))
       end

     1 function Inspector:getId(v)
*****0    local id = self.ids[v]
*****0    local ids = self.ids
*****0    if not id then
*****0       local tv = type(v)
*****0       id = (ids[tv] or 0) + 1
*****0       ids[v], ids[tv] = id, id
          end
*****0    return tostring(id)
       end

     1 function Inspector:putValue(v)
     1    local buf = self.buf
     1    local tv = type(v)
     1    if tv == 'string' then
*****0       puts(buf, smartQuote(escape(v)))
     1    elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
*****0       tv == 'cdata' or tv == 'ctype' then
     2       puts(buf, tostring(v))
*****0    elseif tv == 'table' and not self.ids[v] then
*****0       local t = v

*****0       if t == inspect.KEY or t == inspect.METATABLE then
*****0          puts(buf, tostring(t))
*****0       elseif self.level >= self.depth then
*****0          puts(buf, '{...}')
             else
*****0          if self.cycles[t] > 1 then puts(buf, fmt('<%d>', self:getId(t))) end

*****0          local keys, keysLen, seqLen = getKeys(t)

*****0          puts(buf, '{')
*****0          self.level = self.level + 1

*****0          for i = 1, seqLen + keysLen do
*****0             if i > 1 then puts(buf, ',') end
*****0             if i <= seqLen then
*****0                puts(buf, ' ')
*****0                self:putValue(t[i])
                   else
*****0                local k = keys[i - seqLen]
*****0                tabify(self)
*****0                if isIdentifier(k) then
*****0                   puts(buf, k)
                      else
*****0                   puts(buf, "[")
*****0                   self:putValue(k)
*****0                   puts(buf, "]")
                      end
*****0                puts(buf, ' = ')
*****0                self:putValue(t[k])
                   end
                end

*****0          local mt = getmetatable(t)
*****0          if type(mt) == 'table' then
*****0             if seqLen + keysLen > 0 then puts(buf, ',') end
*****0             tabify(self)
*****0             puts(buf, '<metatable> = ')
*****0             self:putValue(mt)
                end

*****0          self.level = self.level - 1

*****0          if keysLen > 0 or type(mt) == 'table' then
*****0             tabify(self)
*****0          elseif seqLen > 0 then
*****0             puts(buf, ' ')
                end

*****0          puts(buf, '}')
             end

          else
*****0       puts(buf, fmt('<%s %d>', tv, self:getId(v)))
          end
       end




     1 function inspect.inspect(root, options)
     1    options = options or {}

     1    local depth = options.depth or (math.huge)
     1    local newline = options.newline or '\n'
     1    local indent = options.indent or '  '
     1    local process = options.process

     1    if process then
*****0       root = processRecursive(process, root, {}, {})
          end

     1    local cycles = {}
     1    countCycles(root, cycles)

     2    local inspector = setmetatable({
     1       buf = { n = 0 },
     1       ids = {},
     1       cycles = cycles,
     1       depth = depth,
             level = 0,
     1       newline = newline,
     1       indent = indent,
     1    }, Inspector_mt)

     1    inspector:putValue(root)

     1    return table.concat(inspector.buf)
       end

     2 setmetatable(inspect, {
          __call = function(_, root, options)
     1       return inspect.inspect(root, options)
          end,
       })

     1 return inspect

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/assert.lua
==============================================================================
*****0 local s = require 'say'
*****0 local astate = require 'luassert.state'
*****0 local util = require 'luassert.util'
*****0 local unpack = util.unpack
       local obj   -- the returned module table
*****0 local level_mt = {}

       -- list of namespaces
*****0 local namespace = require 'luassert.namespaces'

       local function geterror(assertion_message, failure_message, args)
*****0   if util.hastostring(failure_message) then
*****0     failure_message = tostring(failure_message)
*****0   elseif failure_message ~= nil then
*****0     failure_message = astate.format_argument(failure_message)
         end
*****0   local message = s(assertion_message, obj:format(args))
*****0   if message and failure_message then
*****0     message = failure_message .. "\n" .. message
         end
*****0   return message or failure_message
       end

*****0 local __state_meta = {

         __call = function(self, ...)
   173     local keys = util.extract_keys("assertion", self.tokens)

           local assertion

   558     for _, key in ipairs(keys) do
   385       assertion = namespace.assertion[key] or assertion
           end

   173     if assertion then
   558       for _, key in ipairs(keys) do
   385         if namespace.modifier[key] then
   212           namespace.modifier[key].callback(self)
               end
             end

   173       local arguments = util.make_arglist(...)
   346       local val, retargs = assertion.callback(self, arguments, util.errorlevel())

   173       if (not val) == self.mod then
*****0         local message = assertion.positive_message
*****0         if not self.mod then
*****0           message = assertion.negative_message
               end
*****0         local err = geterror(message, rawget(self,"failure_message"), arguments)
*****0         error(err or "assertion failed!", util.errorlevel())
             end

   173       if retargs then
*****0         return unpack(retargs)
             end
   173       return ...
           else
*****0       local arguments = util.make_arglist(...)
*****0       self.tokens = {}

*****0       for _, key in ipairs(keys) do
*****0         if namespace.modifier[key] then
*****0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
               end
             end
           end

*****0     return self
         end,

         __index = function(self, key)
   929     for token in key:lower():gmatch('[^_]+') do
   385       table.insert(self.tokens, token)
           end

   272     return self
         end
       }

*****0 obj = {
   173   state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,

         -- registers a function in namespace
         register = function(self, nspace, name, callback, positive_message, negative_message)
*****0     local lowername = name:lower()
*****0     if not namespace[nspace] then
*****0       namespace[nspace] = {}
           end
*****0     namespace[nspace][lowername] = {
             callback = callback,
             name = lowername,
             positive_message=positive_message,
*****0       negative_message=negative_message
           }
         end,

         -- unregisters a function in a namespace
         unregister = function(self, nspace, name)
*****0     local lowername = name:lower()
*****0     if not namespace[nspace] then
*****0       namespace[nspace] = {}
           end
*****0     namespace[nspace][lowername] = nil
         end,

         -- registers a formatter
         -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
         add_formatter = function(self, callback)
*****0     astate.add_formatter(callback)
         end,

         -- unregisters a formatter
         remove_formatter = function(self, fmtr)
*****0     astate.remove_formatter(fmtr)
         end,

         format = function(self, args)
           -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
*****0     local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
*****0     local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
*****0     for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
*****0       if not nofmt[i] then
*****0         local val = args[i]
*****0         local valfmt = astate.format_argument(val, nil, fmtargs[i])
*****0         if valfmt == nil then valfmt = tostring(val) end -- no formatter found
*****0         args[i] = valfmt
             end
           end
*****0     return args
         end,

         set_parameter = function(self, name, value)
*****0     astate.set_parameter(name, value)
         end,

         get_parameter = function(self, name)
*****0     return astate.get_parameter(name)
         end,

         add_spy = function(self, spy)
*****0     astate.add_spy(spy)
         end,

         snapshot = function(self)
*****0     return astate.snapshot()
         end,

         level = function(self, level)
*****0     return setmetatable({
*****0         level = level
*****0       }, level_mt)
         end,

         -- returns the level if a level-value, otherwise nil
         get_level = function(self, level)
*****0     if getmetatable(level) ~= level_mt then
*****0       return nil -- not a valid error-level
           end
*****0     return level.level
         end,
       }

*****0 local __meta = {

         __call = function(self, bool, message, level, ...)
   180     if not bool then
*****0       local err_level = (self:get_level(level) or 1) + 1
*****0       error(message or "assertion failed!", err_level)
           end
   180     return bool , message , level , ...
         end,

         __index = function(self, key)
   519     return rawget(self, key) or self.state()[key]
         end,

       }

*****0 return setmetatable(obj, __meta)

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/assertions.lua
==============================================================================
       -- module will not return anything, only register assertions with the main assert engine

       -- assertions take 2 parameters;
       -- 1) state
       -- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils
       -- 3) level The level of the error position relative to the called function
       -- returns; boolean; whether assertion passed

*****0 local assert = require('luassert.assert')
*****0 local astate = require ('luassert.state')
*****0 local util = require ('luassert.util')
*****0 local s = require('say')

       local function format(val)
    84   return astate.format_argument(val) or tostring(val)
       end

       local function set_failure_message(state, message)
   173   if message ~= nil then
    77     state.failure_message = message
         end
       end

       local function unique(state, arguments, level)
*****0   local list = arguments[1]
         local deep
*****0   local argcnt = arguments.n
*****0   if type(arguments[2]) == "boolean" or (arguments[2] == nil and argcnt > 2) then
*****0     deep = arguments[2]
*****0     set_failure_message(state, arguments[3])
         else
*****0     if type(arguments[3]) == "boolean" then
*****0       deep = arguments[3]
           end
*****0     set_failure_message(state, arguments[2])
         end
*****0   for k,v in pairs(list) do
*****0     for k2, v2 in pairs(list) do
*****0       if k ~= k2 then
*****0         if deep and util.deepcompare(v, v2, true) then
*****0           return false
               else
*****0           if v == v2 then
*****0             return false
                 end
               end
             end
           end
         end
*****0   return true
       end

       local function near(state, arguments, level)
    14   local level = (level or 1) + 1
    14   local argcnt = arguments.n
    28   assert(argcnt > 2, s("assertion.internal.argtolittle", { "near", 3, tostring(argcnt) }), level)
    14   local expected = tonumber(arguments[1])
    14   local actual = tonumber(arguments[2])
    14   local tolerance = tonumber(arguments[3])
    14   local numbertype = "number or object convertible to a number"
    42   assert(expected, s("assertion.internal.badargtype", { 1, "near", numbertype, format(arguments[1]) }), level)
    42   assert(actual, s("assertion.internal.badargtype", { 2, "near", numbertype, format(arguments[2]) }), level)
    42   assert(tolerance, s("assertion.internal.badargtype", { 3, "near", numbertype, format(arguments[3]) }), level)
         -- switch arguments for proper output message
    28   util.tinsert(arguments, 1, util.tremove(arguments, 2))
    14   arguments[3] = tolerance
    14   arguments.nofmt = arguments.nofmt or {}
    14   arguments.nofmt[3] = true
    14   set_failure_message(state, arguments[4])
    14   return (actual >= expected - tolerance and actual <= expected + tolerance)
       end

       local function matches(state, arguments, level)
*****0   local level = (level or 1) + 1
*****0   local argcnt = arguments.n
*****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "matches", 2, tostring(argcnt) }), level)
*****0   local pattern = arguments[1]
         local actual = nil
*****0   if util.hastostring(arguments[2]) or type(arguments[2]) == "number" then
*****0     actual = tostring(arguments[2])
         end
         local err_message
*****0   local init_arg_num = 3
*****0   for i=3,argcnt,1 do
*****0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
*****0       if i == 3 then init_arg_num = init_arg_num + 1 end
*****0       err_message = util.tremove(arguments, i)
             break
           end
         end
*****0   local init = arguments[3]
*****0   local plain = arguments[4]
*****0   local stringtype = "string or object convertible to a string"
*****0   assert(type(pattern) == "string", s("assertion.internal.badargtype", { 1, "matches", "string", type(arguments[1]) }), level)
*****0   assert(actual, s("assertion.internal.badargtype", { 2, "matches", stringtype, format(arguments[2]) }), level)
*****0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)
         -- switch arguments for proper output message
*****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
*****0   set_failure_message(state, err_message)
         local retargs
         local ok
*****0   if plain then
*****0     ok = (actual:find(pattern, init, plain) ~= nil)
*****0     retargs = ok and { pattern } or {}
         else
*****0     retargs = { actual:match(pattern, init) }
*****0     ok = (retargs[1] ~= nil)
         end
*****0   return ok, retargs
       end

       local function equals(state, arguments, level)
*****0   local level = (level or 1) + 1
*****0   local argcnt = arguments.n
*****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "equals", 2, tostring(argcnt) }), level)
*****0   local result =  arguments[1] == arguments[2]
         -- switch arguments for proper output message
*****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
*****0   set_failure_message(state, arguments[3])
*****0   return result
       end

       local function same(state, arguments, level)
   100   local level = (level or 1) + 1
   100   local argcnt = arguments.n
   200   assert(argcnt > 1, s("assertion.internal.argtolittle", { "same", 2, tostring(argcnt) }), level)
   100   if type(arguments[1]) == 'table' and type(arguments[2]) == 'table' then
     5     local result, crumbs = util.deepcompare(arguments[1], arguments[2], true)
           -- switch arguments for proper output message
    10     util.tinsert(arguments, 1, util.tremove(arguments, 2))
     5     arguments.fmtargs = arguments.fmtargs or {}
     5     arguments.fmtargs[1] = { crumbs = crumbs }
     5     arguments.fmtargs[2] = { crumbs = crumbs }
     5     set_failure_message(state, arguments[3])
     5     return result
         end
    95   local result = arguments[1] == arguments[2]
         -- switch arguments for proper output message
   190   util.tinsert(arguments, 1, util.tremove(arguments, 2))
    95   set_failure_message(state, arguments[3])
    95   return result
       end

       local function truthy(state, arguments, level)
*****0   local argcnt = arguments.n
*****0   assert(argcnt > 0, s("assertion.internal.argtolittle", { "truthy", 1, tostring(argcnt) }), level)
*****0   set_failure_message(state, arguments[2])
*****0   return arguments[1] ~= false and arguments[1] ~= nil
       end

       local function falsy(state, arguments, level)
*****0   local argcnt = arguments.n
*****0   assert(argcnt > 0, s("assertion.internal.argtolittle", { "falsy", 1, tostring(argcnt) }), level)
*****0   return not truthy(state, arguments, level)
       end

       local function has_error(state, arguments, level)
*****0   local level = (level or 1) + 1
*****0   local retargs = util.shallowcopy(arguments)
*****0   local func = arguments[1]
*****0   local err_expected = arguments[2]
*****0   local failure_message = arguments[3]
*****0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error", "function or callable object", type(func) }), level)
*****0   local ok, err_actual = pcall(func)
*****0   if type(err_actual) == 'string' then
           -- remove 'path/to/file:line: ' from string
*****0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
         end
*****0   retargs[1] = err_actual
*****0   arguments.nofmt = {}
*****0   arguments.n = 2
*****0   arguments[1] = (ok and '(no error)' or err_actual)
*****0   arguments[2] = (err_expected == nil and '(error)' or err_expected)
*****0   arguments.nofmt[1] = ok
*****0   arguments.nofmt[2] = (err_expected == nil)
*****0   set_failure_message(state, failure_message)

*****0   if ok or err_expected == nil then
*****0     return not ok, retargs
         end
*****0   if type(err_expected) == 'string' then
           -- err_actual must be (convertible to) a string
*****0     if util.hastostring(err_actual) then
*****0       err_actual = tostring(err_actual)
*****0       retargs[1] = err_actual
           end
*****0     if type(err_actual) == 'string' then
*****0       return err_expected == err_actual, retargs
           end
*****0   elseif type(err_expected) == 'number' then
*****0     if type(err_actual) == 'string' then
*****0       return tostring(err_expected) == tostring(tonumber(err_actual)), retargs
           end
         end
*****0   return same(state, {err_expected, err_actual, ["n"] = 2}), retargs
       end

       local function error_matches(state, arguments, level)
*****0   local level = (level or 1) + 1
*****0   local retargs = util.shallowcopy(arguments)
*****0   local argcnt = arguments.n
*****0   local func = arguments[1]
*****0   local pattern = arguments[2]
*****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "error_matches", 2, tostring(argcnt) }), level)
*****0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error_matches", "function or callable object", type(func) }), level)
*****0   assert(pattern == nil or type(pattern) == "string", s("assertion.internal.badargtype", { 2, "error", "string", type(pattern) }), level)

         local failure_message
*****0   local init_arg_num = 3
*****0   for i=3,argcnt,1 do
*****0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
*****0       if i == 3 then init_arg_num = init_arg_num + 1 end
*****0       failure_message = util.tremove(arguments, i)
             break
           end
         end
*****0   local init = arguments[3]
*****0   local plain = arguments[4]
*****0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)

*****0   local ok, err_actual = pcall(func)
*****0   if type(err_actual) == 'string' then
           -- remove 'path/to/file:line: ' from string
*****0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
         end
*****0   retargs[1] = err_actual
*****0   arguments.nofmt = {}
*****0   arguments.n = 2
*****0   arguments[1] = (ok and '(no error)' or err_actual)
*****0   arguments[2] = pattern
*****0   arguments.nofmt[1] = ok
*****0   arguments.nofmt[2] = false
*****0   set_failure_message(state, failure_message)

*****0   if ok then return not ok, retargs end
*****0   if err_actual == nil and pattern == nil then
*****0     return true, {}
         end

         -- err_actual must be (convertible to) a string
*****0   if util.hastostring(err_actual) or
*****0      type(err_actual) == "number" or
*****0      type(err_actual) == "boolean" then
*****0     err_actual = tostring(err_actual)
*****0     retargs[1] = err_actual
         end
*****0   if type(err_actual) == 'string' then
           local ok
           local retargs_ok
*****0     if plain then
*****0       retargs_ok = { pattern }
*****0       ok = (err_actual:find(pattern, init, plain) ~= nil)
           else
*****0       retargs_ok = { err_actual:match(pattern, init) }
*****0       ok = (retargs_ok[1] ~= nil)
           end
*****0     if ok then retargs = retargs_ok end
*****0     return ok, retargs
         end

*****0   return false, retargs
       end

       local function is_true(state, arguments, level)
     8   util.tinsert(arguments, 2, true)
     8   set_failure_message(state, arguments[3])
     8   return arguments[1] == arguments[2]
       end

       local function is_false(state, arguments, level)
     8   util.tinsert(arguments, 2, false)
     8   set_failure_message(state, arguments[3])
     8   return arguments[1] == arguments[2]
       end

       local function is_type(state, arguments, level, etype)
    43   util.tinsert(arguments, 2, "type " .. etype)
    43   arguments.nofmt = arguments.nofmt or {}
    43   arguments.nofmt[2] = true
    43   set_failure_message(state, arguments[3])
    43   return arguments.n > 1 and type(arguments[1]) == etype
       end

       local function returned_arguments(state, arguments, level)
*****0   arguments[1] = tostring(arguments[1])
*****0   arguments[2] = tostring(arguments.n - 1)
*****0   arguments.nofmt = arguments.nofmt or {}
*****0   arguments.nofmt[1] = true
*****0   arguments.nofmt[2] = true
*****0   if arguments.n < 2 then arguments.n = 2 end
*****0   return arguments[1] == arguments[2]
       end

       local function set_message(state, arguments, level)
*****0   state.failure_message = arguments[1]
       end

*****0 local function is_boolean(state, arguments, level)  return is_type(state, arguments, level, "boolean")  end
*****0 local function is_number(state, arguments, level)   return is_type(state, arguments, level, "number")   end
*****0 local function is_string(state, arguments, level)   return is_type(state, arguments, level, "string")   end
*****0 local function is_table(state, arguments, level)    return is_type(state, arguments, level, "table")    end
    43 local function is_nil(state, arguments, level)      return is_type(state, arguments, level, "nil")      end
*****0 local function is_userdata(state, arguments, level) return is_type(state, arguments, level, "userdata") end
*****0 local function is_function(state, arguments, level) return is_type(state, arguments, level, "function") end
*****0 local function is_thread(state, arguments, level)   return is_type(state, arguments, level, "thread")   end

*****0 assert:register("modifier", "message", set_message)
*****0 assert:register("assertion", "true", is_true, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "false", is_false, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "boolean", is_boolean, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "number", is_number, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "string", is_string, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "table", is_table, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "nil", is_nil, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "userdata", is_userdata, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "function", is_function, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "thread", is_thread, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "returned_arguments", returned_arguments, "assertion.returned_arguments.positive", "assertion.returned_arguments.negative")

*****0 assert:register("assertion", "same", same, "assertion.same.positive", "assertion.same.negative")
*****0 assert:register("assertion", "matches", matches, "assertion.matches.positive", "assertion.matches.negative")
*****0 assert:register("assertion", "match", matches, "assertion.matches.positive", "assertion.matches.negative")
*****0 assert:register("assertion", "near", near, "assertion.near.positive", "assertion.near.negative")
*****0 assert:register("assertion", "equals", equals, "assertion.equals.positive", "assertion.equals.negative")
*****0 assert:register("assertion", "equal", equals, "assertion.equals.positive", "assertion.equals.negative")
*****0 assert:register("assertion", "unique", unique, "assertion.unique.positive", "assertion.unique.negative")
*****0 assert:register("assertion", "error", has_error, "assertion.error.positive", "assertion.error.negative")
*****0 assert:register("assertion", "errors", has_error, "assertion.error.positive", "assertion.error.negative")
*****0 assert:register("assertion", "error_matches", error_matches, "assertion.error.positive", "assertion.error.negative")
*****0 assert:register("assertion", "error_match", error_matches, "assertion.error.positive", "assertion.error.negative")
*****0 assert:register("assertion", "matches_error", error_matches, "assertion.error.positive", "assertion.error.negative")
*****0 assert:register("assertion", "match_error", error_matches, "assertion.error.positive", "assertion.error.negative")
*****0 assert:register("assertion", "truthy", truthy, "assertion.truthy.positive", "assertion.truthy.negative")
*****0 assert:register("assertion", "falsy", falsy, "assertion.falsy.positive", "assertion.falsy.negative")

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/formatters/init.lua
==============================================================================
       -- module will not return anything, only register formatters with the main assert engine
*****0 local assert = require('luassert.assert')
*****0 local match = require('luassert.match')
*****0 local util = require('luassert.util')

*****0 local isatty, colors do
*****0   local ok, term = pcall(require, 'term')
*****0   isatty = io.type(io.stdout) == 'file' and ok and term.isatty(io.stdout)
*****0   if not isatty then
*****0     local isWindows = package.config:sub(1,1) == '\\'
*****0     if isWindows and os.getenv("ANSICON") then
*****0       isatty = true
           end
         end

*****0   colors = setmetatable({
*****0     none = function(c) return c end
*****0   },{ __index = function(self, key)
           return function(c)
*****0       for token in key:gmatch("[^%.]+") do
*****0         c = term.colors[token](c)
             end
*****0       return c
           end
         end
         })
       end

       local function fmt_string(arg)
*****0   if type(arg) == "string" then
*****0     return string.format("(string) '%s'", arg)
         end
       end

       -- A version of tostring which formats numbers more precisely.
       local function tostr(arg)
    42   if type(arg) ~= "number" then
*****0     return tostring(arg)
         end

    42   if arg ~= arg then
*****0     return "NaN"
    42   elseif arg == 1/0 then
*****0     return "Inf"
    42   elseif arg == -1/0 then
*****0     return "-Inf"
         end

    42   local str = string.format("%.20g", arg)

    42   if math.type and math.type(arg) == "float" and not str:find("[%.,]") then
           -- Number is a float but looks like an integer.
           -- Insert ".0" after first run of digits.
*****0     str = str:gsub("%d+", "%0.0", 1)
         end

    42   return str
       end

       local function fmt_number(arg)
    42   if type(arg) == "number" then
    84     return string.format("(number) %s", tostr(arg))
         end
       end

       local function fmt_boolean(arg)
    42   if type(arg) == "boolean" then
*****0     return string.format("(boolean) %s", tostring(arg))
         end
       end

       local function fmt_nil(arg)
    42   if type(arg) == "nil" then
*****0     return "(nil)"
         end
       end

*****0 local type_priorities = {
         number = 1,
         boolean = 2,
         string = 3,
         table = 4,
         ["function"] = 5,
         userdata = 6,
*****0   thread = 7
       }

       local function is_in_array_part(key, length)
*****0   return type(key) == "number" and 1 <= key and key <= length and math.floor(key) == key
       end

       local function get_sorted_keys(t)
*****0   local keys = {}
*****0   local nkeys = 0

*****0   for key in pairs(t) do
*****0     nkeys = nkeys + 1
*****0     keys[nkeys] = key
         end

*****0   local length = #t

         local function key_comparator(key1, key2)
*****0     local type1, type2 = type(key1), type(key2)
*****0     local priority1 = is_in_array_part(key1, length) and 0 or type_priorities[type1] or 8
*****0     local priority2 = is_in_array_part(key2, length) and 0 or type_priorities[type2] or 8

*****0     if priority1 == priority2 then
*****0       if type1 == "string" or type1 == "number" then
*****0         return key1 < key2
*****0       elseif type1 == "boolean" then
*****0         return key1  -- put true before false
             end
           else
*****0       return priority1 < priority2
           end
         end

*****0   table.sort(keys, key_comparator)
*****0   return keys, nkeys
       end

       local function fmt_table(arg, fmtargs)
    42   if type(arg) ~= "table" then
    42     return
         end

*****0   local tmax = assert:get_parameter("TableFormatLevel")
*****0   local showrec = assert:get_parameter("TableFormatShowRecursion")
*****0   local errchar = assert:get_parameter("TableErrorHighlightCharacter") or ""
*****0   local errcolor = assert:get_parameter("TableErrorHighlightColor")
*****0   local crumbs = fmtargs and fmtargs.crumbs or {}
*****0   local cache = {}
         local type_desc

*****0   if getmetatable(arg) == nil then
*****0     type_desc = "(" .. tostring(arg) .. ") "
*****0   elseif not pcall(setmetatable, arg, getmetatable(arg)) then
           -- cannot set same metatable, so it is protected, skip id
*****0     type_desc = "(table) "
         else
           -- unprotected metatable, temporary remove the mt
*****0     local mt = getmetatable(arg)
*****0     setmetatable(arg, nil)
*****0     type_desc = "(" .. tostring(arg) .. ") "
*****0     setmetatable(arg, mt)
         end

         local function ft(t, l, with_crumbs)
*****0     if showrec and cache[t] and cache[t] > 0 then
*****0       return "{ ... recursive }"
           end

*****0     if next(t) == nil then
*****0       return "{ }"
           end

*****0     if l > tmax and tmax >= 0 then
*****0       return "{ ... more }"
           end

*****0     local result = "{"
*****0     local keys, nkeys = get_sorted_keys(t)

*****0     cache[t] = (cache[t] or 0) + 1
*****0     local crumb = crumbs[#crumbs - l + 1]

*****0     for i = 1, nkeys do
*****0       local k = keys[i]
*****0       local v = t[k]
*****0       local use_crumbs = with_crumbs and k == crumb

*****0       if type(v) == "table" then
*****0         v = ft(v, l + 1, use_crumbs)
*****0       elseif type(v) == "string" then
*****0         v = "'"..v.."'"
             end

*****0       local ch = use_crumbs and errchar or ""
*****0       local indent = string.rep(" ",l * 2 - ch:len())
*****0       local mark = (ch:len() == 0 and "" or colors[errcolor](ch))
*****0       result = result .. string.format("\n%s%s[%s] = %s", indent, mark, tostr(k), tostr(v))
           end

*****0     cache[t] = cache[t] - 1

*****0     return result .. " }"
         end

*****0   return type_desc .. ft(arg, 1, true)
       end

       local function fmt_function(arg)
    42   if type(arg) == "function" then
*****0     local debug_info = debug.getinfo(arg)
*****0     return string.format("%s @ line %s in %s", tostring(arg), tostring(debug_info.linedefined), tostring(debug_info.source))
         end
       end

       local function fmt_userdata(arg)
    42   if type(arg) == "userdata" then
*****0     return string.format("(userdata) '%s'", tostring(arg))
         end
       end

       local function fmt_thread(arg)
    42   if type(arg) == "thread" then
*****0     return string.format("(thread) '%s'", tostring(arg))
         end
       end

       local function fmt_matcher(arg)
    84   if not match.is_matcher(arg) then
    42     return
         end
*****0   local not_inverted = {
           [true] = "is.",
           [false] = "no.",
         }
*****0   local args = {}
*****0   for idx = 1, arg.arguments.n do
*****0     table.insert(args, assert:format({ arg.arguments[idx], n = 1, })[1])
         end
*****0   return string.format("(matcher) %s%s(%s)",
*****0                        not_inverted[arg.mod],
*****0                        tostring(arg.name),
*****0                        table.concat(args, ", "))
       end

       local function fmt_arglist(arglist)
    84   if not util.is_arglist(arglist) then
    42     return
         end
*****0   local formatted_vals = {}
*****0   for idx = 1, arglist.n do
*****0     table.insert(formatted_vals, assert:format({ arglist[idx], n = 1, })[1])
         end
*****0   return "(values list) (" .. table.concat(formatted_vals, ", ") .. ")"
       end

*****0 assert:add_formatter(fmt_string)
*****0 assert:add_formatter(fmt_number)
*****0 assert:add_formatter(fmt_boolean)
*****0 assert:add_formatter(fmt_nil)
*****0 assert:add_formatter(fmt_table)
*****0 assert:add_formatter(fmt_function)
*****0 assert:add_formatter(fmt_userdata)
*****0 assert:add_formatter(fmt_thread)
*****0 assert:add_formatter(fmt_matcher)
*****0 assert:add_formatter(fmt_arglist)
       -- Set default table display depth for table formatter
*****0 assert:set_parameter("TableFormatLevel", 3)
*****0 assert:set_parameter("TableFormatShowRecursion", false)
*****0 assert:set_parameter("TableErrorHighlightCharacter", "*")
*****0 assert:set_parameter("TableErrorHighlightColor", isatty and "red" or "none")

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/match.lua
==============================================================================
*****0 local namespace = require 'luassert.namespaces'
*****0 local util = require 'luassert.util'

*****0 local matcher_mt = {
         __call = function(self, value)
*****0     return self.callback(value) == self.mod
         end,
       }

*****0 local state_mt = {
         __call = function(self, ...)
*****0     local keys = util.extract_keys("matcher", self.tokens)
*****0     self.tokens = {}

           local matcher

*****0     for _, key in ipairs(keys) do
*****0       matcher = namespace.matcher[key] or matcher
           end

*****0     if matcher then
*****0       for _, key in ipairs(keys) do
*****0         if namespace.modifier[key] then
*****0           namespace.modifier[key].callback(self)
               end
             end

*****0       local arguments = util.make_arglist(...)
*****0       local matches = matcher.callback(self, arguments, util.errorlevel())
*****0       return setmetatable({
               name = matcher.name,
               mod = self.mod,
               callback = matches,
               arguments = arguments,
*****0       }, matcher_mt)
           else
*****0       local arguments = util.make_arglist(...)

*****0       for _, key in ipairs(keys) do
*****0         if namespace.modifier[key] then
*****0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
               end
             end
           end

*****0     return self
         end,

         __index = function(self, key)
*****0     for token in key:lower():gmatch('[^_]+') do
*****0       table.insert(self.tokens, token)
           end

*****0     return self
         end
       }

*****0 local match = {
         _ = setmetatable({mod=true, callback=function() return true end}, matcher_mt),

         state = function() return setmetatable({mod=true, tokens={}}, state_mt) end,

         is_matcher = function(object)
    42     return type(object) == "table" and getmetatable(object) == matcher_mt
         end,

         is_ref_matcher = function(object)
*****0     local ismatcher = (type(object) == "table" and getmetatable(object) == matcher_mt)
*****0     return ismatcher and object.name == "ref"
         end,
       }

*****0 local mt = {
         __index = function(self, key)
*****0     return rawget(self, key) or self.state()[key]
         end,
       }

*****0 return setmetatable(match, mt)

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/modifiers.lua
==============================================================================
       -- module will not return anything, only register assertions/modifiers with the main assert engine
*****0 local assert = require('luassert.assert')

       local function is(state)
   172   return state
       end

       local function is_not(state)
    40   state.mod = not state.mod
    40   return state
       end

*****0 assert:register("modifier", "is", is)
*****0 assert:register("modifier", "are", is)
*****0 assert:register("modifier", "was", is)
*****0 assert:register("modifier", "has", is)
*****0 assert:register("modifier", "does", is)
*****0 assert:register("modifier", "not", is_not)
*****0 assert:register("modifier", "no", is_not)

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/state.lua
==============================================================================
       -- maintains a state of the assert engine in a linked-list fashion
       -- records; formatters, parameters, spies and stubs

*****0 local state_mt = {
         __call = function(self)
*****0     self:revert()
         end
       }

*****0 local spies_mt = { __mode = "kv" }

*****0 local nilvalue = {} -- unique ID to refer to nil values for parameters

       -- will hold the current state
       local current

       -- exported module table
*****0 local state = {}

       ------------------------------------------------------
       -- Reverts to a (specific) snapshot.
       -- @param self (optional) the snapshot to revert to. If not provided, it will revert to the last snapshot.
       state.revert = function(self)
*****0   if not self then
           -- no snapshot given, so move 1 up
*****0     self = current
*****0     if not self.previous then
             -- top of list, no previous one, nothing to do
*****0       return
           end
         end
*****0   if getmetatable(self) ~= state_mt then error("Value provided is not a valid snapshot", 2) end

*****0   if self.next then
*****0     self.next:revert()
         end
         -- revert formatters in 'last'
*****0   self.formatters = {}
         -- revert parameters in 'last'
*****0   self.parameters = {}
         -- revert spies/stubs in 'last'
*****0   for s,_ in pairs(self.spies) do
*****0     self.spies[s] = nil
*****0     s:revert()
         end
*****0   setmetatable(self, nil) -- invalidate as a snapshot
*****0   current = self.previous
*****0   current.next = nil
       end

       ------------------------------------------------------
       -- Creates a new snapshot.
       -- @return snapshot table
       state.snapshot = function()
*****0   local new = setmetatable ({
           formatters = {},
           parameters = {},
           spies = setmetatable({}, spies_mt),
           previous = current,
           revert = state.revert,
*****0   }, state_mt)
*****0   if current then current.next = new end
*****0   current = new
*****0   return current
       end


       --  FORMATTERS
       state.add_formatter = function(callback)
*****0   table.insert(current.formatters, 1, callback)
       end

       state.remove_formatter = function(callback, s)
*****0   s = s or current
*****0   for i, v in ipairs(s.formatters) do
*****0     if v == callback then
*****0       table.remove(s.formatters, i)
             break
           end
         end
         -- wasn't found, so traverse up 1 state
*****0   if s.previous then
*****0     state.remove_formatter(callback, s.previous)
         end
       end

       state.format_argument = function(val, s, fmtargs)
    42   s = s or current
   378   for _, fmt in ipairs(s.formatters) do
   378     local valfmt = fmt(val, fmtargs)
   378     if valfmt ~= nil then return valfmt end
         end
         -- nothing found, check snapshot 1 up in list
*****0   if s.previous then
*****0     return state.format_argument(val, s.previous, fmtargs)
         end
*****0   return nil -- end of list, couldn't format
       end


       --  PARAMETERS
       state.set_parameter = function(name, value)
*****0   if value == nil then value = nilvalue end
*****0   current.parameters[name] = value
       end

       state.get_parameter = function(name, s)
*****0   s = s or current
*****0   local val = s.parameters[name]
*****0   if val == nil and s.previous then
           -- not found, so check 1 up in list
*****0     return state.get_parameter(name, s.previous)
         end
*****0   if val ~= nilvalue then
*****0     return val
         end
*****0   return nil
       end

       --  SPIES / STUBS
       state.add_spy = function(spy)
*****0   current.spies[spy] = true
       end

*****0 state.snapshot()  -- create initial state

*****0 return state

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/util.lua
==============================================================================
*****0 local util = {}
*****0 local arglist_mt = {}

       -- have pack/unpack both respect the 'n' field
*****0 local _unpack = table.unpack or unpack
*****0 local unpack = function(t, i, j) return _unpack(t, i or 1, j or t.n or #t) end
*****0 local pack = function(...) return { n = select("#", ...), ... } end
*****0 util.pack = pack
*****0 util.unpack = unpack


*****0 function util.deepcompare(t1,t2,ignore_mt,cycles,thresh1,thresh2)
    26   local ty1 = type(t1)
    26   local ty2 = type(t2)
         -- non-table types can be directly compared
    26   if ty1 ~= 'table' or ty2 ~= 'table' then return t1 == t2 end
    10   local mt1 = debug.getmetatable(t1)
    10   local mt2 = debug.getmetatable(t2)
         -- would equality be determined by metatable __eq?
    10   if mt1 and mt1 == mt2 and mt1.__eq then
           -- then use that unless asked not to
*****0     if not ignore_mt then return t1 == t2 end
         else -- we can skip the deep comparison below if t1 and t2 share identity
    10     if rawequal(t1, t2) then return true end
         end

         -- handle recursive tables
    10   cycles = cycles or {{},{}}
    10   thresh1, thresh2 = (thresh1 or 1), (thresh2 or 1)
    10   cycles[1][t1] = (cycles[1][t1] or 0)
    10   cycles[2][t2] = (cycles[2][t2] or 0)
    10   if cycles[1][t1] == 1 or cycles[2][t2] == 1 then
*****0     thresh1 = cycles[1][t1] + 1
*****0     thresh2 = cycles[2][t2] + 1
         end
    10   if cycles[1][t1] > thresh1 and cycles[2][t2] > thresh2 then
*****0     return true
         end

    10   cycles[1][t1] = cycles[1][t1] + 1
    10   cycles[2][t2] = cycles[2][t2] + 1

    31   for k1,v1 in next, t1 do
    21     local v2 = t2[k1]
    21     if v2 == nil then
*****0       return false, {k1}
           end

    21     local same, crumbs = util.deepcompare(v1,v2,nil,cycles,thresh1,thresh2)
    21     if not same then
*****0       crumbs = crumbs or {}
*****0       table.insert(crumbs, k1)
*****0       return false, crumbs
           end
         end
    31   for k2,_ in next, t2 do
           -- only check whether each element has a t1 counterpart, actual comparison
           -- has been done in first loop above
    21     if t1[k2] == nil then return false, {k2} end
         end

    10   cycles[1][t1] = cycles[1][t1] - 1
    10   cycles[2][t2] = cycles[2][t2] - 1

    10   return true
       end

*****0 function util.shallowcopy(t)
*****0   if type(t) ~= "table" then return t end
*****0   local copy = {}
*****0   setmetatable(copy, getmetatable(t))
*****0   for k,v in next, t do
*****0     copy[k] = v
         end
*****0   return copy
       end

*****0 function util.deepcopy(t, deepmt, cache)
*****0   local spy = require 'luassert.spy'
*****0   if type(t) ~= "table" then return t end
*****0   local copy = {}

         -- handle recursive tables
*****0   local cache = cache or {}
*****0   if cache[t] then return cache[t] end
*****0   cache[t] = copy

*****0   for k,v in next, t do
*****0     copy[k] = (spy.is_spy(v) and v or util.deepcopy(v, deepmt, cache))
         end
*****0   if deepmt then
*****0     debug.setmetatable(copy, util.deepcopy(debug.getmetatable(t), false, cache))
         else
*****0     debug.setmetatable(copy, debug.getmetatable(t))
         end
*****0   return copy
       end

       -----------------------------------------------
       -- Copies arguments as a list of arguments
       -- @param args the arguments of which to copy
       -- @return the copy of the arguments
*****0 function util.copyargs(args)
*****0   local copy = {}
*****0   setmetatable(copy, getmetatable(args))
*****0   local match = require 'luassert.match'
*****0   local spy = require 'luassert.spy'
*****0   for k,v in pairs(args) do
*****0     copy[k] = ((match.is_matcher(v) or spy.is_spy(v)) and v or util.deepcopy(v))
         end
*****0   return { vals = copy, refs = util.shallowcopy(args) }
       end

       -----------------------------------------------
       -- Clear an arguments or return values list from a table
       -- @param arglist the table to clear of arguments or return values and their count
       -- @return No return values
*****0 function util.cleararglist(arglist)
*****0   for idx = arglist.n, 1, -1 do
*****0     util.tremove(arglist, idx)
         end
*****0   arglist.n = nil
       end

       -----------------------------------------------
       -- Test specs against an arglist in deepcopy and refs flavours.
       -- @param args deepcopy arglist
       -- @param argsrefs refs arglist
       -- @param specs arguments/return values to match against args/argsrefs
       -- @return true if specs match args/argsrefs, false otherwise
       local function matcharg(args, argrefs, specs)
*****0   local match = require 'luassert.match'
*****0   for idx, argval in pairs(args) do
*****0     local spec = specs[idx]
*****0     if match.is_matcher(spec) then
*****0       if match.is_ref_matcher(spec) then
*****0         argval = argrefs[idx]
             end
*****0       if not spec(argval) then
*****0         return false
             end
*****0     elseif (spec == nil or not util.deepcompare(argval, spec)) then
*****0       return false
           end
         end

*****0   for idx, spec in pairs(specs) do
           -- only check whether each element has an args counterpart,
           -- actual comparison has been done in first loop above
*****0     local argval = args[idx]
*****0     if argval == nil then
             -- no args counterpart, so try to compare using matcher
*****0       if match.is_matcher(spec) then
*****0         if not spec(argval) then
*****0           return false
               end
             else
*****0         return false
             end
           end
         end
*****0   return true
       end

       -----------------------------------------------
       -- Find matching arguments/return values in a saved list of
       -- arguments/returned values.
       -- @param invocations_list list of arguments/returned values to search (list of lists)
       -- @param specs arguments/return values to match against argslist
       -- @return the last matching arguments/returned values if a match is found, otherwise nil
*****0 function util.matchargs(invocations_list, specs)
         -- Search the arguments/returned values last to first to give the
         -- most helpful answer possible. In the cases where you can place
         -- your assertions between calls to check this gives you the best
         -- information if no calls match. In the cases where you can't do
         -- that there is no good way to predict what would work best.
*****0   assert(not util.is_arglist(invocations_list), "expected a list of arglist-object, got an arglist")
*****0   for ii = #invocations_list, 1, -1 do
*****0     local val = invocations_list[ii]
*****0     if matcharg(val.vals, val.refs, specs) then
*****0       return val
           end
         end
*****0   return nil
       end

       -----------------------------------------------
       -- Find matching oncall for an actual call.
       -- @param oncalls list of oncalls to search
       -- @param args actual call argslist to match against
       -- @return the first matching oncall if a match is found, otherwise nil
*****0 function util.matchoncalls(oncalls, args)
*****0   for _, callspecs in ipairs(oncalls) do
           -- This lookup is done immediately on *args* passing into the stub
           -- so pass *args* as both *args* and *argsref* without copying
           -- either.
*****0     if matcharg(args, args, callspecs.vals) then
*****0       return callspecs
           end
         end
*****0   return nil
       end

       -----------------------------------------------
       -- table.insert() replacement that respects nil values.
       -- The function will use table field 'n' as indicator of the
       -- table length, if not set, it will be added.
       -- @param t table into which to insert
       -- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!
       -- @param val value to insert
       -- @return No return values
*****0 function util.tinsert(...)
         -- check optional POS value
   173   local args = {...}
   173   local c = select('#',...)
   173   local t = args[1]
   173   local pos = args[2]
   173   local val = args[3]
   173   if c < 3 then
*****0     val = pos
*****0     pos = nil
         end
         -- set length indicator n if not present (+1)
   173   t.n = (t.n or #t) + 1
   173   if not pos then
*****0     pos = t.n
   173   elseif pos > t.n then
           -- out of our range
*****0     t[pos] = val
*****0     t.n = pos
         end
         -- shift everything up 1 pos
   378   for i = t.n, pos + 1, -1 do
   205     t[i]=t[i-1]
         end
         -- add element to be inserted
   173   t[pos] = val
       end
       -----------------------------------------------
       -- table.remove() replacement that respects nil values.
       -- The function will use table field 'n' as indicator of the
       -- table length, if not set, it will be added.
       -- @param t table from which to remove
       -- @param pos (optional) position in table to remove
       -- @return No return values
*****0 function util.tremove(t, pos)
         -- set length indicator n if not present (+1)
   114   t.n = t.n or #t
   114   if not pos then
*****0     pos = t.n
   114   elseif pos > t.n then
*****0     local removed = t[pos]
           -- out of our range
*****0     t[pos] = nil
*****0     return removed
         end
   114   local removed = t[pos]
         -- shift everything up 1 pos
   274   for i = pos, t.n do
   160     t[i]=t[i+1]
         end
         -- set size, clean last
   114   t[t.n] = nil
   114   t.n = t.n - 1
   114   return removed
       end

       -----------------------------------------------
       -- Checks an element to be callable.
       -- The type must either be a function or have a metatable
       -- containing an '__call' function.
       -- @param object element to inspect on being callable or not
       -- @return boolean, true if the object is callable
*****0 function util.callable(object)
*****0   return type(object) == "function" or type((debug.getmetatable(object) or {}).__call) == "function"
       end

       -----------------------------------------------
       -- Checks an element has tostring.
       -- The type must either be a string or have a metatable
       -- containing an '__tostring' function.
       -- @param object element to inspect on having tostring or not
       -- @return boolean, true if the object has tostring
*****0 function util.hastostring(object)
*****0   return type(object) == "string" or type((debug.getmetatable(object) or {}).__tostring) == "function"
       end

       -----------------------------------------------
       -- Find the first level, not defined in the same file as the caller's
       -- code file to properly report an error.
       -- @param level the level to use as the caller's source file
       -- @return number, the level of which to report an error
*****0 function util.errorlevel(level)
   173   local level = (level or 1) + 1 -- add one to get level of the caller
   173   local info = debug.getinfo(level)
   173   local source = (info or {}).source
   173   local file = source
   346   while file and (file == source or source == "=(tail call)") do
   173     level = level + 1
   173     info = debug.getinfo(level)
   173     source = (info or {}).source
         end
   173   if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself
   173   return level
       end

       -----------------------------------------------
       -- Extract modifier and namespace keys from list of tokens.
       -- @param nspace the namespace from which to match tokens
       -- @param tokens list of tokens to search for keys
       -- @return table, list of keys that were extracted
*****0 function util.extract_keys(nspace, tokens)
   173   local namespace = require 'luassert.namespaces'

         -- find valid keys by coalescing tokens as needed, starting from the end
   173   local keys = {}
   173   local key = nil
   173   local i = #tokens
   558   while i > 0 do
   385     local token = tokens[i]
   385     key = key and (token .. '_' .. key) or token

           -- find longest matching key in the given namespace
   385     local longkey = i > 1 and (tokens[i-1] .. '_' .. key) or nil
   385     while i > 1 and longkey and namespace[nspace][longkey] do
*****0       key = longkey
*****0       i = i - 1
*****0       token = tokens[i]
*****0       longkey = (token .. '_' .. key)
           end

   385     if namespace.modifier[key] or namespace[nspace][key] then
   385       table.insert(keys, 1, key)
   385       key = nil
           end
   385     i = i - 1
         end

         -- if there's anything left we didn't recognize it
   173   if key then
*****0     error("luassert: unknown modifier/" .. nspace .. ": '" .. key .."'", util.errorlevel(2))
         end

   173   return keys
       end

       -----------------------------------------------
       -- store argument list for return values of a function in a table.
       -- The table will get a metatable to identify it as an arglist
*****0 function util.make_arglist(...)
   173   local arglist = { ... }
   173   arglist.n = select('#', ...) -- add values count for trailing nils
   173   return setmetatable(arglist, arglist_mt)
       end

       -----------------------------------------------
       -- check a table to be an arglist type.
*****0 function util.is_arglist(object)
    42   return getmetatable(object) == arglist_mt
       end

*****0 return util

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/mediator.lua
==============================================================================
       local function getUniqueId(obj)
*****0   return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
       end

       local function Subscriber(fn, options)
    34   local sub = {
    34     options = options or {},
    34     fn = fn,
           channel = nil,
           update = function(self, options)
*****0       if options then
*****0         self.fn = options.fn or self.fn
*****0         self.options = options.options or self.options
             end
           end
         }
    34   sub.id = getUniqueId(sub)
    34   return sub
       end

       -- Channel class and functions --

       local function Channel(namespace, parent)
    21   return {
           stopped = false,
    21     namespace = namespace,
    21     callbacks = {},
    21     channels = {},
    21     parent = parent,

           addSubscriber = function(self, fn, options)
    34       local callback = Subscriber(fn, options)
    34       local priority = (#self.callbacks + 1)

    34       options = options or {}

    34       if options.priority and
    23         options.priority >= 0 and
    23         options.priority < priority
             then
    20           priority = options.priority
             end

    34       table.insert(self.callbacks, priority, callback)

    34       return callback
           end,

           getSubscriber = function(self, id)
*****0       for i=1, #self.callbacks do
*****0         local callback = self.callbacks[i]
*****0         if callback.id == id then return { index = i, value = callback } end
             end
             local sub
*****0       for _, channel in pairs(self.channels) do
*****0         sub = channel:getSubscriber(id)
*****0         if sub then break end
             end
*****0       return sub
           end,

           setPriority = function(self, id, priority)
*****0       local callback = self:getSubscriber(id)

*****0       if callback.value then
*****0         table.remove(self.callbacks, callback.index)
*****0         table.insert(self.callbacks, priority, callback.value)
             end
           end,

           addChannel = function(self, namespace)
    42       self.channels[namespace] = Channel(namespace, self)
    21       return self.channels[namespace]
           end,

           hasChannel = function(self, namespace)
*****0       return namespace and self.channels[namespace] and true
           end,

           getChannel = function(self, namespace)
   600       return self.channels[namespace] or self:addChannel(namespace)
           end,

           removeSubscriber = function(self, id)
*****0       local callback = self:getSubscriber(id)

*****0       if callback and callback.value then
*****0         for _, channel in pairs(self.channels) do
*****0           channel:removeSubscriber(id)
               end

*****0         return table.remove(self.callbacks, callback.index)
             end
           end,

           publish = function(self, result, ...)
  1123       for i = 1, #self.callbacks do
   635         local callback = self.callbacks[i]

               -- if it doesn't have a predicate, or it does and it's true then run it
   847         if not callback.options.predicate or callback.options.predicate(...) then
                  -- just take the first result and insert it into the result table
   635           local value, continue = callback.fn(...)

   635           if value then table.insert(result, value) end
   635           if not continue then return result end
               end
             end

   488       if parent then
   325         return parent:publish(result, ...)
             else
   163         return result
             end
           end
    21   }
       end

       -- Mediator class and functions --

*****0 local Mediator = setmetatable(
       {
         Channel = Channel,
*****0   Subscriber = Subscriber
       },
       {
         __call = function (fn, options)
*****0     return {
             channel = Channel('root'),

             getChannel = function(self, channelNamespace)
   293         local channel = self.channel

   872         for i=1, #channelNamespace do
  1158           channel = channel:getChannel(channelNamespace[i])
               end

   293         return channel
             end,

             subscribe = function(self, channelNamespace, fn, options)
    68         return self:getChannel(channelNamespace):addSubscriber(fn, options)
             end,

             getSubscriber = function(self, id, channelNamespace)
*****0         return self:getChannel(channelNamespace):getSubscriber(id)
             end,

             removeSubscriber = function(self, id, channelNamespace)
*****0         return self:getChannel(channelNamespace):removeSubscriber(id)
             end,

             publish = function(self, channelNamespace, ...)
   518         return self:getChannel(channelNamespace):publish({}, ...)
             end
           }
         end
       })
*****0 return Mediator

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/List.lua
==============================================================================
       --- Python-style list class.
       --
       -- **Please Note**: methods that change the list will return the list.
       -- This is to allow for method chaining, but please note that `ls = ls:sort()`
       -- does not mean that a new copy of the list is made. In-place (mutable) methods
       -- are marked as returning 'the list' in this documentation.
       --
       -- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
       --
       -- See <a href="http://www.python.org/doc/current/tut/tut.html">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1
       --
       -- **Note**: The comments before some of the functions are from the Python docs
       -- and contain Python code.
       --
       -- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
       --
       -- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`
       -- @classmod pl.List
       -- @pragma nostrip

     1 local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
     1 local setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string
     1 local tablex = require 'pl.tablex'
     1 local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
     1 local tsub = tablex.sub
     1 local utils = require 'pl.utils'
     1 local class = require 'pl.class'

     1 local array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg
     1 local normalize_slice = tablex._normalize_slice

       -- metatable for our list and map objects has already been defined..
     1 local Multimap = utils.stdmt.MultiMap
     1 local List = utils.stdmt.List

       local iter

     1 class(nil,nil,List)

       -- we want the result to be _covariant_, i.e. t must have type of obj if possible
       local function makelist (t,obj)
*****0     local klass = List
*****0     if obj then
*****0         klass = getmetatable(obj)
           end
*****0     return setmetatable(t,klass)
       end

       local function simple_table(t)
*****0     return type(t) == 'table' and not getmetatable(t) and #t > 0
       end

     1 function List._create (src)
*****0     if simple_table(src) then return src end
       end

     1 function List:_init (src)
*****0     if self == src then return end -- existing table used as self!
*****0     if src then
*****0         for v in iter(src) do
*****0             tinsert(self,v)
               end
           end
       end

       --- Create a new list. Can optionally pass a table;
       -- passing another instance of List will cause a copy to be created;
       -- this will return a plain table with an appropriate metatable.
       -- we pass anything which isn't a simple table to iterate() to work out
       -- an appropriate iterator
       -- @see List.iterate
       -- @param[opt] t An optional list-like table
       -- @return a new List
       -- @usage ls = List();  ls = List {1,2,3,4}
       -- @function List.new

     1 List.new = List

       --- Make a copy of an existing list.
       -- The difference from a plain 'copy constructor' is that this returns
       -- the actual List subtype.
     1 function List:clone()
*****0     local ls = makelist({},self)
*****0     ls:extend(self)
*****0     return ls
       end

       --- Add an item to the end of the list.
       -- @param i An item
       -- @return the list
     1 function List:append(i)
*****0     tinsert(self,i)
*****0     return self
       end

     1 List.push = tinsert

       --- Extend the list by appending all the items in the given list.
       -- equivalent to 'a[len(a):] = L'.
       -- @tparam List L Another List
       -- @return the list
     1 function List:extend(L)
*****0     assert_arg(1,L,'table')
*****0     for i = 1,#L do tinsert(self,L[i]) end
*****0     return self
       end

       --- Insert an item at a given position. i is the index of the
       -- element before which to insert.
       -- @int i index of element before whichh to insert
       -- @param x A data item
       -- @return the list
     1 function List:insert(i, x)
*****0     assert_arg(1,i,'number')
*****0     tinsert(self,i,x)
*****0     return self
       end

       --- Insert an item at the beginning of the list.
       -- @param x a data item
       -- @return the list
     1 function List:put (x)
*****0     return self:insert(1,x)
       end

       --- Remove an element given its index.
       -- (equivalent of Python's del s[i])
       -- @int i the index
       -- @return the list
     1 function List:remove (i)
*****0     assert_arg(1,i,'number')
*****0     tremove(self,i)
*****0     return self
       end

       --- Remove the first item from the list whose value is given.
       -- (This is called 'remove' in Python; renamed to avoid confusion
       -- with table.remove)
       -- Return nil if there is no such item.
       -- @param x A data value
       -- @return the list
     1 function List:remove_value(x)
*****0     for i=1,#self do
*****0         if self[i]==x then tremove(self,i) return self end
           end
*****0     return self
        end

       --- Remove the item at the given position in the list, and return it.
       -- If no index is specified, a:pop() returns the last item in the list.
       -- The item is also removed from the list.
       -- @int[opt] i An index
       -- @return the item
     1 function List:pop(i)
*****0     if not i then i = #self end
*****0     assert_arg(1,i,'number')
*****0     return tremove(self,i)
       end

     1 List.get = List.pop

       --- Return the index in the list of the first item whose value is given.
       -- Return nil if there is no such item.
       -- @function List:index
       -- @param x A data value
       -- @int[opt=1] idx where to start search
       -- @return the index, or nil if not found.

     1 local tfind = tablex.find
     1 List.index = tfind

       --- Does this list contain the value?
       -- @param x A data value
       -- @return true or false
     1 function List:contains(x)
*****0     return tfind(self,x) and true or false
       end

       --- Return the number of times value appears in the list.
       -- @param x A data value
       -- @return number of times x appears
     1 function List:count(x)
*****0     local cnt=0
*****0     for i=1,#self do
*****0         if self[i]==x then cnt=cnt+1 end
           end
*****0     return cnt
       end

       --- Sort the items of the list, in place.
       -- @func[opt='<'] cmp an optional comparison function
       -- @return the list
     1 function List:sort(cmp)
*****0     if cmp then cmp = function_arg(1,cmp) end
*****0     tsort(self,cmp)
*****0     return self
       end

       --- Return a sorted copy of this list.
       -- @func[opt='<'] cmp an optional comparison function
       -- @return a new list
     1 function List:sorted(cmp)
*****0     return List(self):sort(cmp)
       end

       --- Reverse the elements of the list, in place.
       -- @return the list
     1 function List:reverse()
*****0     local t = self
*****0     local n = #t
*****0     for i = 1,n/2 do
*****0         t[i],t[n] = t[n],t[i]
*****0         n = n - 1
           end
*****0     return self
       end

       --- Return the minimum and the maximum value of the list.
       -- @return minimum value
       -- @return maximum value
     1 function List:minmax()
*****0     local vmin,vmax = 1e70,-1e70
*****0     for i = 1,#self do
*****0         local v = self[i]
*****0         if v < vmin then vmin = v end
*****0         if v > vmax then vmax = v end
           end
*****0     return vmin,vmax
       end

       --- Emulate list slicing.  like  'list[first:last]' in Python.
       -- If first or last are negative then they are relative to the end of the list
       -- eg. slice(-2) gives last 2 entries in a list, and
       -- slice(-4,-2) gives from -4th to -2nd
       -- @param first An index
       -- @param last An index
       -- @return a new List
     1 function List:slice(first,last)
*****0     return tsub(self,first,last)
       end

       --- Empty the list.
       -- @return the list
     1 function List:clear()
*****0     for i=1,#self do tremove(self) end
*****0     return self
       end

     1 local eps = 1.0e-10

       --- Emulate Python's range(x) function.
       -- Include it in List table for tidiness
       -- @int start A number
       -- @int[opt] finish A number greater than start; if absent,
       -- then start is 1 and finish is start
       -- @int[opt=1] incr an increment (may be less than 1)
       -- @return a List from start .. finish
       -- @usage List.range(0,3) == List{0,1,2,3}
       -- @usage List.range(4) = List{1,2,3,4}
       -- @usage List.range(5,1,-1) == List{5,4,3,2,1}
     1 function List.range(start,finish,incr)
*****0     if not finish then
*****0         finish = start
*****0         start = 1
           end
*****0     if incr then
*****0     assert_arg(3,incr,'number')
*****0     if math.ceil(incr) ~= incr then finish = finish + eps end
           else
*****0         incr = 1
           end
*****0     assert_arg(1,start,'number')
*****0     assert_arg(2,finish,'number')
*****0     local t = List()
*****0     for i=start,finish,incr do tinsert(t,i) end
*****0     return t
       end

       --- list:len() is the same as #list.
     1 function List:len()
*****0     return #self
       end

       -- Extended operations --

       --- Remove a subrange of elements.
       -- equivalent to 'del s[i1:i2]' in Python.
       -- @int i1 start of range
       -- @int i2 end of range
       -- @return the list
     1 function List:chop(i1,i2)
*****0     return tremovevalues(self,i1,i2)
       end

       --- Insert a sublist into a list
       -- equivalent to 's[idx:idx] = list' in Python
       -- @int idx index
       -- @tparam List list list to insert
       -- @return the list
       -- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
     1 function List:splice(idx,list)
*****0     assert_arg(1,idx,'number')
*****0     idx = idx - 1
*****0     local i = 1
*****0     for v in iter(list) do
*****0         tinsert(self,i+idx,v)
*****0         i = i + 1
           end
*****0     return self
       end

       --- General slice assignment s[i1:i2] = seq.
       -- @int i1  start index
       -- @int i2  end index
       -- @tparam List seq a list
       -- @return the list
     1 function List:slice_assign(i1,i2,seq)
*****0     assert_arg(1,i1,'number')
*****0     assert_arg(1,i2,'number')
*****0     i1,i2 = normalize_slice(self,i1,i2)
*****0     if i2 >= i1 then self:chop(i1,i2) end
*****0     self:splice(i1,seq)
*****0     return self
       end

       --- Concatenation operator.
       -- @within metamethods
       -- @tparam List L another List
       -- @return a new list consisting of the list with the elements of the new list appended
     1 function List:__concat(L)
*****0     assert_arg(1,L,'table')
*****0     local ls = self:clone()
*****0     ls:extend(L)
*****0     return ls
       end

       --- Equality operator ==.  True iff all elements of two lists are equal.
       -- @within metamethods
       -- @tparam List L another List
       -- @return true or false
     1 function List:__eq(L)
*****0     if #self ~= #L then return false end
*****0     for i = 1,#self do
*****0         if self[i] ~= L[i] then return false end
           end
*****0     return true
       end

       --- Join the elements of a list using a delimiter.
       -- This method uses tostring on all elements.
       -- @string[opt=''] delim a delimiter string, can be empty.
       -- @return a string
     1 function List:join (delim)
*****0     delim = delim or ''
*****0     assert_arg(1,delim,'string')
*****0     return concat(array_tostring(self),delim)
       end

       --- Join a list of strings. <br>
       -- Uses `table.concat` directly.
       -- @function List:concat
       -- @string[opt=''] delim a delimiter
       -- @return a string
     1 List.concat = concat

       local function tostring_q(val)
*****0     local s = tostring(val)
*****0     if type(val) == 'string' then
*****0         s = '"'..s..'"'
           end
*****0     return s
       end

       --- How our list should be rendered as a string. Uses join().
       -- @within metamethods
       -- @see List:join
     1 function List:__tostring()
*****0     return '{'..self:join(',',tostring_q)..'}'
       end

       --- Call the function on each element of the list.
       -- @func fun a function or callable object
       -- @param ... optional values to pass to function
     1 function List:foreach (fun,...)
*****0     fun = function_arg(1,fun)
*****0     for i = 1,#self do
*****0         fun(self[i],...)
           end
       end

       local function lookup_fun (obj,name)
*****0     local f = obj[name]
*****0     if not f then error(type(obj).." does not have method "..name,3) end
*****0     return f
       end

       --- Call the named method on each element of the list.
       -- @string name the method name
       -- @param ... optional values to pass to function
     1 function List:foreachm (name,...)
*****0     for i = 1,#self do
*****0         local obj = self[i]
*****0         local f = lookup_fun(obj,name)
*****0         f(obj,...)
           end
       end

       --- Create a list of all elements which match a function.
       -- @func fun a boolean function
       -- @param[opt] arg optional argument to be passed as second argument of the predicate
       -- @return a new filtered list.
     1 function List:filter (fun,arg)
*****0     return makelist(filter(self,fun,arg),self)
       end

       --- Split a string using a delimiter.
       -- @string s the string
       -- @string[opt] delim the delimiter (default spaces)
       -- @return a List of strings
       -- @see pl.utils.split
     1 function List.split (s,delim)
*****0     assert_arg(1,s,'string')
*****0     return makelist(split(s,delim))
       end

       --- Apply a function to all elements.
       -- Any extra arguments will be passed to the function.
       -- @func fun a function of at least one argument
       -- @param ... arbitrary extra arguments.
       -- @return a new list: {f(x) for x in self}
       -- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
       -- @see pl.tablex.imap
     1 function List:map (fun,...)
*****0     return makelist(imap(fun,self,...),self)
       end

       --- Apply a function to all elements, in-place.
       -- Any extra arguments are passed to the function.
       -- @func fun A function that takes at least one argument
       -- @param ... arbitrary extra arguments.
       -- @return the list.
     1 function List:transform (fun,...)
*****0     transform(fun,self,...)
*****0     return self
       end

       --- Apply a function to elements of two lists.
       -- Any extra arguments will be passed to the function
       -- @func fun a function of at least two arguments
       -- @tparam List ls another list
       -- @param ... arbitrary extra arguments.
       -- @return a new list: {f(x,y) for x in self, for x in arg1}
       -- @see pl.tablex.imap2
     1 function List:map2 (fun,ls,...)
*****0     return makelist(imap2(fun,self,ls,...),self)
       end

       --- apply a named method to all elements.
       -- Any extra arguments will be passed to the method.
       -- @string name name of method
       -- @param ... extra arguments
       -- @return a new list of the results
       -- @see pl.seq.mapmethod
     1 function List:mapm (name,...)
*****0     local res = {}
*****0     for i = 1,#self do
*****0       local val = self[i]
*****0       local fn = lookup_fun(val,name)
*****0       res[i] = fn(val,...)
           end
*****0     return makelist(res,self)
       end

       local function composite_call (method,f)
           return function(self,...)
*****0         return self[method](self,f,...)
           end
       end

     1 function List.default_map_with(T)
           return function(self,name)
               local m
*****0         if T then
*****0             local f = lookup_fun(T,name)
*****0             m = composite_call('map',f)
               else
*****0             m = composite_call('mapn',name)
               end
*****0         getmetatable(self)[name] = m -- and cache..
*****0         return m
           end
       end

     1 List.default_map = List.default_map_with

       --- 'reduce' a list using a binary function.
       -- @func fun a function of two arguments
       -- @return result of the function
       -- @see pl.tablex.reduce
     1 function List:reduce (fun)
*****0     return reduce(fun,self)
       end

       --- Partition a list using a classifier function.
       -- The function may return nil, but this will be converted to the string key '<nil>'.
       -- @func fun a function of at least one argument
       -- @param ... will also be passed to the function
       -- @treturn MultiMap a table where the keys are the returned values, and the values are Lists
       -- of values where the function returned that key.
       -- @see pl.MultiMap
     1 function List:partition (fun,...)
*****0     fun = function_arg(1,fun)
*****0     local res = {}
*****0     for i = 1,#self do
*****0         local val = self[i]
*****0         local klass = fun(val,...)
*****0         if klass == nil then klass = '<nil>' end
*****0         if not res[klass] then res[klass] = List() end
*****0         res[klass]:append(val)
           end
*****0     return setmetatable(res,Multimap)
       end

       --- return an iterator over all values.
     1 function List:iter ()
*****0     return iter(self)
       end

       --- Create an iterator over a sequence.
       -- This captures the Python concept of 'sequence'.
       -- For tables, iterates over all values with integer indices.
       -- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
       -- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55
       -- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p
     1 function List.iterate(seq)
*****0     if type(seq) == 'string' then
*****0         local idx = 0
*****0         local n = #seq
*****0         local sub = string.sub
               return function ()
*****0             idx = idx + 1
*****0             if idx > n then return nil
                   else
*****0                 return sub(seq,idx,idx)
                   end
               end
*****0     elseif type(seq) == 'table' then
*****0         local idx = 0
*****0         local n = #seq
               return function()
*****0             idx = idx + 1
*****0             if idx > n then return nil
                   else
*****0                 return seq[idx]
                   end
               end
*****0     elseif type(seq) == 'function' then
*****0         return seq
*****0     elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
*****0         return seq:lines()
           end
       end
     1 iter = List.iterate

     1 return List


==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/class.lua
==============================================================================
       --- Provides a reusable and convenient framework for creating classes in Lua.
       -- Two possible notations:
       --
       --    B = class(A)
       --    class.B(A)
       --
       -- The latter form creates a named class within the current environment. Note
       -- that this implicitly brings in `pl.utils` as a dependency.
       --
       -- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
       -- @module pl.class

       local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
*****0     _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
       local compat

       -- this trickery is necessary to prevent the inheritance of 'super' and
       -- the resulting recursive call problems.
       local function call_ctor (c,obj,...)
*****0     local init = rawget(c,'_init')
*****0     local parent_with_init = rawget(c,'_parent_with_init')

*****0     if parent_with_init then
*****0         if not init then -- inheriting an init
*****0             init = rawget(parent_with_init, '_init')
*****0             parent_with_init = rawget(parent_with_init, '_parent_with_init')
               end
*****0         if parent_with_init then -- super() points to one above wherever _init came from
*****0             rawset(obj,'super',function(obj,...)
*****0                 call_ctor(parent_with_init,obj,...)
                   end)
               end
           else
               -- Without this, calling super() where none exists will sometimes loop and stack overflow
*****0         rawset(obj,'super',nil)
           end

*****0     local res = init(obj,...)
*****0     if parent_with_init then -- If this execution of call_ctor set a super, unset it
*****0         rawset(obj,'super',nil)
           end

*****0     return res
       end

       --- initializes an __instance__ upon creation.
       -- @function class:_init
       -- @param ... parameters passed to the constructor
       -- @usage local Cat = class()
       -- function Cat:_init(name)
       --   --self:super(name)   -- call the ancestor initializer if needed
       --   self.name = name
       -- end
       --
       -- local pussycat = Cat("pussycat")
       -- print(pussycat.name)  --> pussycat

       --- checks whether an __instance__ is derived from some class.
       -- Works the other way around as `class_of`. It has two ways of using;
       -- 1) call with a class to check against, 2) call without params.
       -- @function instance:is_a
       -- @param some_class class to check against, or `nil` to return the class
       -- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then
       -- it returns the class table of the instance
       -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
       -- if pussycat:is_a(Cat) then
       --   -- it's true, it is a Lion, but also a Cat
       -- end
       --
       -- if pussycat:is_a() == Lion then
       --   -- It's true
       -- end
       local function is_a(self,klass)
*****0     if klass == nil then
               -- no class provided, so return the class this instance is derived from
*****0         return getmetatable(self)
           end
*****0     local m = getmetatable(self)
*****0     if not m then return false end --*can't be an object!
*****0     while m do
*****0         if m == klass then return true end
*****0         m = rawget(m,'_base')
           end
*****0     return false
       end

       --- checks whether an __instance__ is derived from some class.
       -- Works the other way around as `is_a`.
       -- @function some_class:class_of
       -- @param some_instance instance to check against
       -- @return `true` if `some_instance` is derived from `some_class`
       -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
       -- if Cat:class_of(pussycat) then
       --   -- it's true
       -- end
       local function class_of(klass,obj)
*****0     if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
*****0     return klass.is_a(obj,klass)
       end

       --- cast an object to another class.
       -- It is not clever (or safe!) so use carefully.
       -- @param some_instance the object to be changed
       -- @function some_class:cast
       local function cast (klass, obj)
*****0     return setmetatable(obj,klass)
       end


       local function _class_tostring (obj)
*****0     local mt = obj._class
*****0     local name = rawget(mt,'_name')
*****0     setmetatable(obj,nil)
*****0     local str = tostring(obj)
*****0     setmetatable(obj,mt)
*****0     if name then str = name ..str:gsub('table','') end
*****0     return str
       end

       local function tupdate(td,ts,dont_override)
*****0     for k,v in pairs(ts) do
*****0         if not dont_override or td[k] == nil then
*****0             td[k] = v
               end
           end
       end

       local function _class(base,c_arg,c)
           -- the class `c` will be the metatable for all its objects,
           -- and they will look up their methods in it.
     1     local mt = {}   -- a metatable for the class to support __call and _handler
           -- can define class by passing it a plain table of methods
     1     local plain = type(base) == 'table' and not getmetatable(base)
     1     if plain then
*****0         c = base
*****0         base = c._base
           else
     1         c = c or {}
           end

     1     if type(base) == 'table' then
               -- our new class is a shallow copy of the base class!
               -- but be careful not to wipe out any methods we have been given at this point!
*****0         tupdate(c,base,plain)
*****0         c._base = base
               -- inherit the 'not found' handler, if present
*****0         if rawget(c,'_handler') then mt.__index = c._handler end
     1     elseif base ~= nil then
*****0         error("must derive from a table type",3)
           end

     1     c.__index = c
     1     setmetatable(c,mt)
     1     if not plain then
     1         if base and rawget(base,'_init') then c._parent_with_init = base end -- For super and inherited init
     1         c._init = nil
           end

     1     if base and rawget(base,'_class_init') then
*****0         base._class_init(c,c_arg)
           end

           -- expose a ctor which can be called by <classname>(<args>)
           mt.__call = function(class_tbl,...)
               local obj
*****0         if rawget(c,'_create') then obj = c._create(...) end
*****0         if not obj then obj = {} end
*****0         setmetatable(obj,c)

*****0         if rawget(c,'_init') or rawget(c,'_parent_with_init') then -- constructor exists
*****0             local res = call_ctor(c,obj,...)
*****0             if res then -- _if_ a ctor returns a value, it becomes the object...
*****0                 obj = res
*****0                 setmetatable(obj,c)
                   end
               end

*****0         if base and rawget(base,'_post_init') then
*****0             base._post_init(obj)
               end

*****0         return obj
           end
           -- Call Class.catch to set a handler for methods/properties not found in the class!
           c.catch = function(self, handler)
*****0         if type(self) == "function" then
                   -- called using . instead of :
*****0             handler = self
               end
*****0         c._handler = handler
*****0         mt.__index = handler
           end
     1     c.is_a = is_a
     1     c.class_of = class_of
     1     c.cast = cast
     1     c._class = c

     1     if not rawget(c,'__tostring') then
     1         c.__tostring = _class_tostring
           end

     1     return c
       end

       --- create a new class, derived from a given base class.
       -- Supporting two class creation syntaxes:
       -- either `Name = class(base)` or `class.Name(base)`.
       -- The first form returns the class directly and does not set its `_name`.
       -- The second form creates a variable `Name` in the current environment set
       -- to the class, and also sets `_name`.
       -- @function class
       -- @param base optional base class
       -- @param c_arg optional parameter to class constructor
       -- @param c optional table to be used as class
       local class
*****0 class = setmetatable({},{
           __call = function(fun,...)
     1         return _class(...)
           end,
           __index = function(tbl,key)
*****0         if key == 'class' then
*****0             io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
*****0             return class
               end
*****0         compat = compat or require 'pl.compat'
*****0         local env = compat.getfenv(2)
               return function(...)
*****0             local c = _class(...)
*****0             c._name = key
*****0             rawset(env,key,c)
*****0             return c
               end
           end
       })

*****0 class.properties = class()

*****0 function class.properties._class_init(klass)
           klass.__index = function(t,key)
               -- normal class lookup!
*****0         local v = klass[key]
*****0         if v then return v end
               -- is it a getter?
*****0         v = rawget(klass,'get_'..key)
*****0         if v then
*****0             return v(t)
               end
               -- is it a field?
*****0         return rawget(t,'_'..key)
           end
           klass.__newindex = function (t,key,value)
               -- if there's a setter, use that, otherwise directly set table
*****0         local p = 'set_'..key
*****0         local setter = klass[p]
*****0         if setter then
*****0             setter(t,value)
               else
*****0             rawset(t,key,value)
               end
           end
       end


*****0 return class


==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/dir.lua
==============================================================================
       --- Listing files in directories and creating/removing directory paths.
       --
       -- Dependencies: `pl.utils`, `pl.path`
       --
       -- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
       -- @module pl.dir

     1 local utils = require 'pl.utils'
     1 local path = require 'pl.path'
     1 local is_windows = path.is_windows
     1 local ldir = path.dir
     1 local mkdir = path.mkdir
     1 local rmdir = path.rmdir
     1 local sub = string.sub
     1 local os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable
     1 local remove = os.remove
     1 local append = table.insert
     1 local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

     1 local exists, isdir = path.exists, path.isdir
     1 local sep = path.sep

     1 local dir = {}

       local function makelist(l)
     1     return setmetatable(l, require('pl.List'))
       end

       local function assert_dir (n,val)
     1     assert_arg(n,val,'string',path.isdir,'not a directory',4)
       end

       local function filemask(mask)
    27     mask = utils.escape(path.normcase(mask))
     9     return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'
       end

       --- Test whether a file name matches a shell pattern.
       -- Both parameters are case-normalized if operating system is
       -- case-insensitive.
       -- @string filename A file name.
       -- @string pattern A shell pattern. The only special characters are
       -- `'*'` and `'?'`: `'*'` matches any sequence of characters and
       -- `'?'` matches any single character.
       -- @treturn bool
       -- @raise dir and mask must be strings
     1 function dir.fnmatch(filename,pattern)
*****0     assert_string(1,filename)
*****0     assert_string(2,pattern)
*****0     return path.normcase(filename):find(filemask(pattern)) ~= nil
       end

       --- Return a list of all file names within an array which match a pattern.
       -- @tab filenames An array containing file names.
       -- @string pattern A shell pattern (see `fnmatch`).
       -- @treturn List(string) List of matching file names.
       -- @raise dir and mask must be strings
     1 function dir.filter(filenames,pattern)
*****0     assert_arg(1,filenames,'table')
*****0     assert_string(2,pattern)
*****0     local res = {}
*****0     local mask = filemask(pattern)
*****0     for i,f in ipairs(filenames) do
*****0         if path.normcase(f):find(mask) then append(res,f) end
           end
*****0     return makelist(res)
       end

       local function _listfiles(dirname,filemode,match)
*****0     local res = {}
*****0     local check = utils.choose(filemode,path.isfile,path.isdir)
*****0     if not dirname then dirname = '.' end
*****0     for f in ldir(dirname) do
*****0         if f ~= '.' and f ~= '..' then
*****0             local p = path.join(dirname,f)
*****0             if check(p) and (not match or match(f)) then
*****0                 append(res,p)
                   end
               end
           end
*****0     return makelist(res)
       end

       --- return a list of all files in a directory which match a shell pattern.
       -- @string[opt='.'] dirname A directory.
       -- @string[opt] mask A shell pattern (see `fnmatch`). If not given, all files are returned.
       -- @treturn {string} list of files
       -- @raise dirname and mask must be strings
     1 function dir.getfiles(dirname,mask)
*****0     dirname = dirname or '.'
*****0     assert_dir(1,dirname)
*****0     if mask then assert_string(2,mask) end
           local match
*****0     if mask then
*****0         mask = filemask(mask)
               match = function(f)
*****0             return path.normcase(f):find(mask)
               end
           end
*****0     return _listfiles(dirname,true,match)
       end

       --- return a list of all subdirectories of the directory.
       -- @string[opt='.'] dirname A directory.
       -- @treturn {string} a list of directories
       -- @raise dir must be a valid directory
     1 function dir.getdirectories(dirname)
*****0     dirname = dirname or '.'
*****0     assert_dir(1,dirname)
*****0     return _listfiles(dirname,false)
       end

       local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

       local function execute_command(cmd,parms)
*****0    if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
*****0    local err = path.is_windows and ' > ' or ' 2> '
*****0     cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)
*****0     local ret = utils.execute(cmd)
*****0     if not ret then
*****0         local err = (utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
*****0         remove(cmd_tmpfile)
*****0         return false,err
           else
*****0         remove(cmd_tmpfile)
*****0         return true
           end
       end

       local function find_ffi_copyfile ()
*****0     if not ffi_checked then
*****0         ffi_checked = true
               local res
*****0         res,alien = pcall(require,'alien')
*****0         if not res then
*****0             alien = nil
*****0             res, ffi = pcall(require,'ffi')
               end
*****0         if not res then
*****0             ffi = nil
*****0             return
               end
           else
*****0         return
           end
*****0     if alien then
               -- register the Win32 CopyFile and MoveFile functions
*****0         local kernel = alien.load('kernel32.dll')
*****0         CopyFile = kernel.CopyFileA
*****0         CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
*****0         MoveFile = kernel.MoveFileA
*****0         MoveFile:types{'string','string',ret='int',abi='stdcall'}
*****0         GetLastError = kernel.GetLastError
*****0         GetLastError:types{ret ='int', abi='stdcall'}
*****0     elseif ffi then
*****0         ffi.cdef [[
                   int CopyFileA(const char *src, const char *dest, int iovr);
                   int MoveFileA(const char *src, const char *dest);
                   int GetLastError();
*****0         ]]
*****0         CopyFile = ffi.C.CopyFileA
*****0         MoveFile = ffi.C.MoveFileA
*****0         GetLastError = ffi.C.GetLastError
           end
*****0     win32_errors = {
               ERROR_FILE_NOT_FOUND    =         2,
               ERROR_PATH_NOT_FOUND    =         3,
               ERROR_ACCESS_DENIED    =          5,
               ERROR_WRITE_PROTECT    =          19,
               ERROR_BAD_UNIT         =          20,
               ERROR_NOT_READY        =          21,
               ERROR_WRITE_FAULT      =          29,
               ERROR_READ_FAULT       =          30,
               ERROR_SHARING_VIOLATION =         32,
               ERROR_LOCK_VIOLATION    =         33,
               ERROR_HANDLE_DISK_FULL  =         39,
               ERROR_BAD_NETPATH       =         53,
               ERROR_NETWORK_BUSY      =         54,
               ERROR_DEV_NOT_EXIST     =         55,
               ERROR_FILE_EXISTS       =         80,
               ERROR_OPEN_FAILED       =         110,
               ERROR_INVALID_NAME      =         123,
               ERROR_BAD_PATHNAME      =         161,
               ERROR_ALREADY_EXISTS    =         183,
           }
       end

       local function two_arguments (f1,f2)
*****0     return utils.quote_arg(f1)..' '..utils.quote_arg(f2)
       end

       local function file_op (is_copy,src,dest,flag)
*****0     if flag == 1 and path.exists(dest) then
*****0         return false,"cannot overwrite destination"
           end
*****0     if is_windows then
               -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
*****0         find_ffi_copyfile()
               -- fallback if there's no Alien, just use DOS commands *shudder*
               -- 'rename' involves a copy and then deleting the source.
*****0         if not CopyFile then
*****0             if path.is_windows then
*****0                 src = src:gsub("/","\\")
*****0                 dest = dest:gsub("/","\\")
                   end
*****0             local res, err = execute_command('copy',two_arguments(src,dest))
*****0             if not res then return false,err end
*****0             if not is_copy then
*****0                 return execute_command('del',utils.quote_arg(src))
                   end
*****0             return true
               else
*****0             if path.isdir(dest) then
*****0                 dest = path.join(dest,path.basename(src))
                   end
                   local ret
*****0             if is_copy then ret = CopyFile(src,dest,flag)
*****0             else ret = MoveFile(src,dest) end
*****0             if ret == 0 then
*****0                 local err = GetLastError()
*****0                 for name,value in pairs(win32_errors) do
*****0                     if value == err then return false,name end
                       end
*****0                 return false,"Error #"..err
*****0             else return true
                   end
               end
           else -- for Unix, just use cp for now
*****0         return execute_command(is_copy and 'cp' or 'mv',
*****0             two_arguments(src,dest))
           end
       end

       --- copy a file.
       -- @string src source file
       -- @string dest destination file or directory
       -- @bool flag true if you want to force the copy (default)
       -- @treturn bool operation succeeded
       -- @raise src and dest must be strings
     1 function dir.copyfile (src,dest,flag)
*****0     assert_string(1,src)
*****0     assert_string(2,dest)
*****0     flag = flag==nil or flag
*****0     return file_op(true,src,dest,flag and 0 or 1)
       end

       --- move a file.
       -- @string src source file
       -- @string dest destination file or directory
       -- @treturn bool operation succeeded
       -- @raise src and dest must be strings
     1 function dir.movefile (src,dest)
*****0     assert_string(1,src)
*****0     assert_string(2,dest)
*****0     return file_op(false,src,dest,0)
       end

       local function _dirfiles(dirname,attrib)
*****0     local dirs = {}
*****0     local files = {}
*****0     for f in ldir(dirname) do
*****0         if f ~= '.' and f ~= '..' then
*****0             local p = path.join(dirname,f)
*****0             local mode = attrib(p,'mode')
*****0             if mode=='directory' then
*****0                 append(dirs,f)
                   else
*****0                 append(files,f)
                   end
               end
           end
*****0     return makelist(dirs), makelist(files)
       end


       --- return an iterator which walks through a directory tree starting at root.
       -- The iterator returns (root,dirs,files)
       -- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
       -- to get the actual full path)
       -- If bottom_up is false (or not present), then the entries at the current level are returned
       -- before we go deeper. This means that you can modify the returned list of directories before
       -- continuing.
       -- This is a clone of os.walk from the Python libraries.
       -- @string root A starting directory
       -- @bool bottom_up False if we start listing entries immediately.
       -- @bool follow_links follow symbolic links
       -- @return an iterator returning root,dirs,files
       -- @raise root must be a directory
     1 function dir.walk(root,bottom_up,follow_links)
*****0     assert_dir(1,root)
           local attrib
*****0     if path.is_windows or not follow_links then
*****0         attrib = path.attrib
           else
*****0         attrib = path.link_attrib
           end

*****0     local to_scan = { root }
*****0     local to_return = {}
           local iter = function()
*****0         while #to_scan > 0 do
*****0             local current_root = table.remove(to_scan)
*****0             local dirs,files = _dirfiles(current_root, attrib)
*****0             for _, d in ipairs(dirs) do
*****0                 table.insert(to_scan, current_root..path.sep..d)
                   end
*****0             if not bottom_up then
*****0                 return current_root, dirs, files
                   else
*****0                 table.insert(to_return, { current_root, dirs, files })
                   end
               end
*****0         if #to_return > 0 then
*****0             return utils.unpack(table.remove(to_return))
               end
           end

*****0     return iter
       end

       --- remove a whole directory tree.
       -- Symlinks in the tree will be deleted without following them.
       -- @string fullpath A directory path (must be an actual directory, not a symlink)
       -- @return true or nil
       -- @return error if failed
       -- @raise fullpath must be a string
     1 function dir.rmtree(fullpath)
*****0     assert_dir(1,fullpath)
*****0     if path.islink(fullpath) then return false,'will not follow symlink' end
*****0     for root,dirs,files in dir.walk(fullpath,true) do
*****0         if path.islink(root) then
                   -- sub dir is a link, remove link, do not follow
*****0             if is_windows then
                       -- Windows requires using "rmdir". Deleting the link like a file
                       -- will instead delete all files from the target directory!!
*****0                 local res, err = rmdir(root)
*****0                 if not res then return nil,err .. ": " .. root end
                   else
*****0                 local res, err = remove(root)
*****0                 if not res then return nil,err .. ": " .. root end
                   end
               else
*****0             for i,f in ipairs(files) do
*****0                 local res, err = remove(path.join(root,f))
*****0                 if not res then return nil,err .. ": " .. path.join(root,f) end
                   end
*****0             local res, err = rmdir(root)
*****0             if not res then return nil,err .. ": " .. root end
               end
           end
*****0     return true
       end


       do
         local dirpat
     1   if path.is_windows then
*****0       dirpat = '(.+)\\[^\\]+$'
         else
     1       dirpat = '(.+)/[^/]+$'
         end

         local _makepath
     1   function _makepath(p)
             -- windows root drive case
*****0       if p:find '^%a:[\\]*$' then
*****0           return true
             end
*****0       if not path.isdir(p) then
*****0           local subp = p:match(dirpat)
*****0           if subp then
*****0             local ok, err = _makepath(subp)
*****0             if not ok then return nil, err end
                 end
*****0           return mkdir(p)
             else
*****0           return true
             end
         end

         --- create a directory path.
         -- This will create subdirectories as necessary!
         -- @string p A directory path
         -- @return true on success, nil + errormsg on failure
         -- @raise failure to create
     1   function dir.makepath (p)
*****0       assert_string(1,p)
*****0       if path.is_windows then
*****0           p = p:gsub("/", "\\")
             end
*****0       return _makepath(path.abspath(p))
         end
       end

       --- clone a directory tree. Will always try to create a new directory structure
       -- if necessary.
       -- @string path1 the base path of the source tree
       -- @string path2 the new base path for the destination
       -- @func file_fun an optional function to apply on all files
       -- @bool verbose an optional boolean to control the verbosity of the output.
       --  It can also be a logging function that behaves like print()
       -- @return true, or nil
       -- @return error message, or list of failed directory creations
       -- @return list of failed file operations
       -- @raise path1 and path2 must be strings
       -- @usage clonetree('.','../backup',copyfile)
     1 function dir.clonetree (path1,path2,file_fun,verbose)
*****0     assert_string(1,path1)
*****0     assert_string(2,path2)
*****0     if verbose == true then verbose = print end
*****0     local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
*****0     local faildirs,failfiles = {},{}
*****0     if not isdir(path1) then return raise 'source is not a valid directory' end
*****0     path1 = abspath(normcase(path1))
*****0     path2 = abspath(normcase(path2))
*****0     if verbose then verbose('normalized:',path1,path2) end
           -- particularly NB that the new path isn't fully contained in the old path
*****0     if path1 == path2 then return raise "paths are the same" end
*****0     local _,i2 = path2:find(path1,1,true)
*****0     if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
*****0         return raise 'destination is a subdirectory of the source'
           end
*****0     local cp = path.common_prefix (path1,path2)
*****0     local idx = #cp
*****0     if idx == 0 then -- no common path, but watch out for Windows paths!
*****0         if path1:sub(2,2) == ':' then idx = 3 end
           end
*****0     for root,dirs,files in dir.walk(path1) do
*****0         local opath = path2..root:sub(idx)
*****0         if verbose then verbose('paths:',opath,root) end
*****0         if not isdir(opath) then
*****0             local ret = dir.makepath(opath)
*****0             if not ret then append(faildirs,opath) end
*****0             if verbose then verbose('creating:',opath,ret) end
               end
*****0         if file_fun then
*****0             for i,f in ipairs(files) do
*****0                 local p1 = join(root,f)
*****0                 local p2 = join(opath,f)
*****0                 local ret = file_fun(p1,p2)
*****0                 if not ret then append(failfiles,p2) end
*****0                 if verbose then
*****0                     verbose('files:',p1,p2,ret)
                       end
                   end
               end
           end
*****0     return true,faildirs,failfiles
       end


       -- each entry of the stack is an array with three items:
       -- 1. the name of the directory
       -- 2. the lfs iterator function
       -- 3. the lfs iterator userdata
       local function treeiter(iterstack)
    13     local diriter = iterstack[#iterstack]
    13     if not diriter then
     1       return -- done
           end

    12     local dirname = diriter[1]
    12     local entry = diriter[2](diriter[3])
    12     if not entry then
     1       table.remove(iterstack)
     1       return treeiter(iterstack) -- tail-call to try next
           end

    11     if entry ~= "." and entry ~= ".." then
     9         entry = dirname .. sep .. entry
    18         if exists(entry) then  -- Just in case a symlink is broken.
     9             local is_dir = isdir(entry)
     9             if is_dir then
*****0                 table.insert(iterstack, { entry, ldir(entry) })
                   end
     9             return entry, is_dir
               end
           end

     2     return treeiter(iterstack) -- tail-call to try next
       end


       --- return an iterator over all entries in a directory tree
       -- @string d a directory
       -- @return an iterator giving pathname and mode (true for dir, false otherwise)
       -- @raise d must be a non-empty string
     1 function dir.dirtree( d )
     1     assert( d and d ~= "", "directory parameter is missing or empty" )

     1     local last = sub ( d, -1 )
     1     if last == sep or last == '/' then
*****0         d = sub( d, 1, -2 )
           end

     1     local iterstack = { {d, ldir(d)} }

     1     return treeiter, iterstack
       end


       --- Recursively returns all the file starting at 'path'. It can optionally take a shell pattern and
       -- only returns files that match 'shell_pattern'. If a pattern is given it will do a case insensitive search.
       -- @string[opt='.'] start_path  A directory.
       -- @string[opt='*'] shell_pattern A shell pattern (see `fnmatch`).
       -- @treturn List(string) containing all the files found recursively starting at 'path' and filtered by 'shell_pattern'.
       -- @raise start_path must be a directory
     1 function dir.getallfiles( start_path, shell_pattern )
     1     start_path = start_path or '.'
     1     assert_dir(1,start_path)
     1     shell_pattern = shell_pattern or "*"

     1     local files = {}
     1     local normcase = path.normcase
    21     for filename, mode in dir.dirtree( start_path ) do
     9         if not mode then
     9             local mask = filemask( shell_pattern )
    18             if normcase(filename):find( mask ) then
     9                 files[#files + 1] = filename
                   end
               end
           end

     1     return makelist(files)
       end

     1 return dir

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/path.lua
==============================================================================
       --- Path manipulation and file queries.
       --
       -- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
       --
       -- NOTE: the functions assume the paths being dealt with to originate
       -- from the OS the application is running on. Windows drive letters are not
       -- to be used when running on a Unix system for example. The one exception
       -- is Windows paths to allow both forward and backward slashes (since Lua
       -- also accepts those)
       --
       -- Dependencies: `pl.utils`, `lfs`
       -- @module pl.path

       -- imports and locals
*****0 local _G = _G
*****0 local sub = string.sub
*****0 local getenv = os.getenv
*****0 local tmpnam = os.tmpname
*****0 local package = package
*****0 local append, concat, remove = table.insert, table.concat, table.remove
*****0 local utils = require 'pl.utils'
*****0 local assert_string,raise = utils.assert_string,utils.raise

*****0 local res,lfs = _G.pcall(_G.require,'lfs')
*****0 if not res then
*****0     error("pl.path requires LuaFileSystem")
       end

*****0 local attrib = lfs.attributes
*****0 local currentdir = lfs.currentdir
*****0 local link_attrib = lfs.symlinkattributes

*****0 local path = {}

       local function err_func(name, param, err, code)
*****0   local ret = ("%s failed"):format(tostring(name))
*****0   if param ~= nil then
*****0     ret = ret .. (" for '%s'"):format(tostring(param))
         end
*****0   ret = ret .. (": %s"):format(tostring(err))
*****0   if code ~= nil then
*****0     ret = ret .. (" (code %s)"):format(tostring(code))
         end
*****0   return ret
       end

       --- Lua iterator over the entries of a given directory.
       -- Implicit link to [`luafilesystem.dir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function dir
*****0 path.dir = lfs.dir

       --- Creates a directory.
       -- Implicit link to [`luafilesystem.mkdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function mkdir
       path.mkdir = function(d)
*****0   local ok, err, code = lfs.mkdir(d)
*****0   if not ok then
*****0     return ok, err_func("mkdir", d, err, code), code
         end
*****0   return ok, err, code
       end

       --- Removes a directory.
       -- Implicit link to [`luafilesystem.rmdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function rmdir
       path.rmdir = function(d)
*****0   local ok, err, code = lfs.rmdir(d)
*****0   if not ok then
*****0     return ok, err_func("rmdir", d, err, code), code
         end
*****0   return ok, err, code
       end

       --- Gets attributes.
       -- Implicit link to [`luafilesystem.attributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function attrib
       path.attrib = function(d, r)
*****0   local ok, err, code = attrib(d, r)
*****0   if not ok then
*****0     return ok, err_func("attrib", d, err, code), code
         end
*****0   return ok, err, code
       end

       --- Get the working directory.
       -- Implicit link to [`luafilesystem.currentdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function currentdir
       path.currentdir = function()
*****0   local ok, err, code = currentdir()
*****0   if not ok then
*****0     return ok, err_func("currentdir", nil, err, code), code
         end
*****0   return ok, err, code
       end

       --- Gets symlink attributes.
       -- Implicit link to [`luafilesystem.symlinkattributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function link_attrib
       path.link_attrib = function(d, r)
*****0   local ok, err, code = link_attrib(d, r)
*****0   if not ok then
*****0     return ok, err_func("link_attrib", d, err, code), code
         end
*****0   return ok, err, code
       end

       --- Changes the working directory.
       -- On Windows, if a drive is specified, it also changes the current drive. If
       -- only specifying the drive, it will only switch drive, but not modify the path.
       -- Implicit link to [`luafilesystem.chdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
       -- @function chdir
       path.chdir = function(d)
*****0   local ok, err, code = lfs.chdir(d)
*****0   if not ok then
*****0     return ok, err_func("chdir", d, err, code), code
         end
*****0   return ok, err, code
       end

       --- is this a directory?
       -- @string P A file path
*****0 function path.isdir(P)
    11     assert_string(1,P)
    11     return attrib(P,'mode') == 'directory'
       end

       --- is this a file?
       -- @string P A file path
*****0 function path.isfile(P)
     1     assert_string(1,P)
     1     return attrib(P,'mode') == 'file'
       end

       -- is this a symbolic link?
       -- @string P A file path
*****0 function path.islink(P)
*****0     assert_string(1,P)
*****0     if link_attrib then
*****0         return link_attrib(P,'mode')=='link'
           else
*****0         return false
           end
       end

       --- return size of a file.
       -- @string P A file path
*****0 function path.getsize(P)
*****0     assert_string(1,P)
*****0     return attrib(P,'size')
       end

       --- does a path exist?
       -- @string P A file path
       -- @return the file path if it exists (either as file, directory, socket, etc), nil otherwise
*****0 function path.exists(P)
     9     assert_string(1,P)
     9     return attrib(P,'mode') ~= nil and P
       end

       --- Return the time of last access as the number of seconds since the epoch.
       -- @string P A file path
*****0 function path.getatime(P)
*****0     assert_string(1,P)
*****0     return attrib(P,'access')
       end

       --- Return the time of last modification as the number of seconds since the epoch.
       -- @string P A file path
*****0 function path.getmtime(P)
*****0     assert_string(1,P)
*****0     return attrib(P,'modification')
       end

       ---Return the system's ctime as the number of seconds since the epoch.
       -- @string P A file path
*****0 function path.getctime(P)
*****0     assert_string(1,P)
*****0     return path.attrib(P,'change')
       end


       local function at(s,i)
  3023     return sub(s,i,i)
       end

*****0 path.is_windows = utils.is_windows

       local sep, other_sep, seps
       -- constant sep is the directory separator for this platform.
       -- constant dirsep is the separator in the PATH environment variable
*****0 if path.is_windows then
*****0     path.sep = '\\'; other_sep = '/'
*****0     path.dirsep = ';'
*****0     seps = { ['/'] = true, ['\\'] = true }
       else
*****0     path.sep = '/'
*****0     path.dirsep = ':'
*****0     seps = { ['/'] = true }
       end
*****0 sep = path.sep

       --- are we running Windows?
       -- @class field
       -- @name path.is_windows

       --- path separator for this platform.
       -- @class field
       -- @name path.sep

       --- separator for PATH for this platform
       -- @class field
       -- @name path.dirsep

       --- given a path, return the directory part and a file part.
       -- if there's no directory part, the first value will be empty
       -- @string P A file path
       -- @return directory part
       -- @return file part
       -- @usage
       -- local dir, file = path.splitpath("some/dir/myfile.txt")
       -- assert(dir == "some/dir")
       -- assert(file == "myfile.txt")
       --
       -- local dir, file = path.splitpath("some/dir/")
       -- assert(dir == "some/dir")
       -- assert(file == "")
       --
       -- local dir, file = path.splitpath("some_dir")
       -- assert(dir == "")
       -- assert(file == "some_dir")
*****0 function path.splitpath(P)
   185     assert_string(1,P)
   185     local i = #P
   185     local ch = at(P,i)
  2991     while i > 0 and ch ~= sep and ch ~= other_sep do
  2806         i = i - 1
  5612         ch = at(P,i)
           end
   185     if i == 0 then
*****0         return '',P
           else
   555         return sub(P,1,i-1), sub(P,i+1)
           end
       end

       --- return an absolute path.
       -- @string P A file path
       -- @string[opt] pwd optional start path to use (default is current dir)
*****0 function path.abspath(P,pwd)
*****0     assert_string(1,P)
*****0     if pwd then assert_string(2,pwd) end
*****0     local use_pwd = pwd ~= nil
*****0     if not use_pwd and not currentdir() then return P end
*****0     P = P:gsub('[\\/]$','')
*****0     pwd = pwd or currentdir()
*****0     if not path.isabs(P) then
*****0         P = path.join(pwd,P)
*****0     elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
*****0         P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
           end
*****0     return path.normpath(P)
       end

       --- given a path, return the root part and the extension part.
       -- if there's no extension part, the second value will be empty
       -- @string P A file path
       -- @treturn string root part (everything upto the "."", maybe empty)
       -- @treturn string extension part (including the ".", maybe empty)
       -- @usage
       -- local file_path, ext = path.splitext("/bonzo/dog_stuff/cat.txt")
       -- assert(file_path == "/bonzo/dog_stuff/cat")
       -- assert(ext == ".txt")
       --
       -- local file_path, ext = path.splitext("")
       -- assert(file_path == "")
       -- assert(ext == "")
*****0 function path.splitext(P)
     8     assert_string(1,P)
     8     local i = #P
     8     local ch = at(P,i)
    32     while i > 0 and ch ~= '.' do
    24         if seps[ch] then
*****0             return P,''
               end
    24         i = i - 1
    48         ch = at(P,i)
           end
     8     if i == 0 then
*****0         return P,''
           else
    24         return sub(P,1,i-1),sub(P,i)
           end
       end

       --- return the directory part of a path
       -- @string P A file path
       -- @treturn string everything before the last dir-separator
       -- @see splitpath
       -- @usage
       -- path.dirname("/some/path/file.txt")   -- "/some/path"
       -- path.dirname("file.txt")              -- "" (empty string)
*****0 function path.dirname(P)
   176     assert_string(1,P)
   176     local p1 = path.splitpath(P)
   176     return p1
       end

       --- return the file part of a path
       -- @string P A file path
       -- @treturn string
       -- @see splitpath
       -- @usage
       -- path.basename("/some/path/file.txt")  -- "file.txt"
       -- path.basename("/some/path/file/")     -- "" (empty string)
*****0 function path.basename(P)
     9     assert_string(1,P)
     9     local _,p2 = path.splitpath(P)
     9     return p2
       end

       --- get the extension part of a path.
       -- @string P A file path
       -- @treturn string
       -- @see splitext
       -- @usage
       -- path.extension("/some/path/file.txt") -- ".txt"
       -- path.extension("/some/path/file_txt") -- "" (empty string)
*****0 function path.extension(P)
     8     assert_string(1,P)
     8     local _,p2 = path.splitext(P)
     8     return p2
       end

       --- is this an absolute path?
       -- @string P A file path
       -- @usage
       -- path.isabs("hello/path")    -- false
       -- path.isabs("/hello/path")   -- true
       -- -- Windows;
       -- path.isabs("hello\path")    -- false
       -- path.isabs("\hello\path")   -- true
       -- path.isabs("C:\hello\path") -- true
       -- path.isabs("C:hello\path")  -- false
*****0 function path.isabs(P)
*****0     assert_string(1,P)
*****0     if path.is_windows and at(P,2) == ":" then
*****0         return seps[at(P,3)] ~= nil
           end
*****0     return seps[at(P,1)] ~= nil
       end

       --- return the path resulting from combining the individual paths.
       -- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
       -- empty elements (except the last) will be ignored.
       -- @string p1 A file path
       -- @string p2 A file path
       -- @string ... more file paths
       -- @treturn string the combined path
       -- @usage
       -- path.join("/first","second","third")   -- "/first/second/third"
       -- path.join("first","second/third")      -- "first/second/third"
       -- path.join("/first","/second","third")  -- "/second/third"
*****0 function path.join(p1,p2,...)
*****0     assert_string(1,p1)
*****0     assert_string(2,p2)
*****0     if select('#',...) > 0 then
*****0         local p = path.join(p1,p2)
*****0         local args = {...}
*****0         for i = 1,#args do
*****0             assert_string(i,args[i])
*****0             p = path.join(p,args[i])
               end
*****0         return p
           end
*****0     if path.isabs(p2) then return p2 end
*****0     local endc = at(p1,#p1)
*****0     if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
*****0         p1 = p1..path.sep
           end
*****0     return p1..p2
       end

       --- normalize the case of a pathname. On Unix, this returns the path unchanged,
       -- for Windows it converts;
       --
       -- * the path to lowercase
       -- * forward slashes to backward slashes
       -- @string P A file path
       -- @usage path.normcase("/Some/Path/File.txt")
       -- -- Windows: "\some\path\file.txt"
       -- -- Others : "/Some/Path/File.txt"
*****0 function path.normcase(P)
    18     assert_string(1,P)
    18     if path.is_windows then
*****0         return P:gsub('/','\\'):lower()
           else
    18         return P
           end
       end

       --- normalize a path name.
       -- `A//B`, `A/./B`, and `A/foo/../B` all become `A/B`.
       --
       -- An empty path results in '.'.
       -- @string P a file path
*****0 function path.normpath(P)
*****0     assert_string(1,P)
           -- Split path into anchor and relative path.
*****0     local anchor = ''
*****0     if path.is_windows then
*****0         if P:match '^\\\\' then -- UNC
*****0             anchor = '\\\\'
*****0             P = P:sub(3)
*****0         elseif seps[at(P, 1)] then
*****0             anchor = '\\'
*****0             P = P:sub(2)
*****0         elseif at(P, 2) == ':' then
*****0             anchor = P:sub(1, 2)
*****0             P = P:sub(3)
*****0             if seps[at(P, 1)] then
*****0                 anchor = anchor..'\\'
*****0                 P = P:sub(2)
                   end
               end
*****0         P = P:gsub('/','\\')
           else
               -- According to POSIX, in path start '//' and '/' are distinct,
               -- but '///+' is equivalent to '/'.
*****0         if P:match '^//' and at(P, 3) ~= '/' then
*****0             anchor = '//'
*****0             P = P:sub(3)
*****0         elseif at(P, 1) == '/' then
*****0             anchor = '/'
*****0             P = P:match '^/*(.*)$'
               end
           end
*****0     local parts = {}
*****0     for part in P:gmatch('[^'..sep..']+') do
*****0         if part == '..' then
*****0             if #parts ~= 0 and parts[#parts] ~= '..' then
*****0                 remove(parts)
                   else
*****0                 append(parts, part)
                   end
*****0         elseif part ~= '.' then
*****0             append(parts, part)
               end
           end
*****0     P = anchor..concat(parts, sep)
*****0     if P == '' then P = '.' end
*****0     return P
       end

       --- relative path from current directory or optional start point
       -- @string P a path
       -- @string[opt] start optional start point (default current directory)
*****0 function path.relpath (P,start)
*****0     assert_string(1,P)
*****0     if start then assert_string(2,start) end
*****0     local split,min,append = utils.split, math.min, table.insert
*****0     P = path.abspath(P,start)
*****0     start = start or currentdir()
           local compare
*****0     if path.is_windows then
*****0         P = P:gsub("/","\\")
*****0         start = start:gsub("/","\\")
*****0         compare = function(v) return v:lower() end
           else
*****0         compare = function(v) return v end
           end
*****0     local startl, Pl = split(start,sep), split(P,sep)
*****0     local n = min(#startl,#Pl)
*****0     if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then
*****0         return P
           end
*****0     local k = n+1 -- default value if this loop doesn't bail out!
*****0     for i = 1,n do
*****0         if compare(startl[i]) ~= compare(Pl[i]) then
*****0             k = i
                   break
               end
           end
*****0     local rell = {}
*****0     for i = 1, #startl-k+1 do rell[i] = '..' end
*****0     if k <= #Pl then
*****0         for i = k,#Pl do append(rell,Pl[i]) end
           end
*****0     return table.concat(rell,sep)
       end


       --- Replace a starting '~' with the user's home directory.
       -- In windows, if HOME isn't set, then USERPROFILE is used in preference to
       -- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
       -- @string P A file path
       -- @treturn[1] string The file path with the `~` prefix substituted, or the input path if it had no prefix.
       -- @treturn[2] nil
       -- @treturn[2] string Error message if the environment variables were unavailable.
*****0 function path.expanduser(P)
*****0     assert_string(1,P)
*****0     if P:sub(1,1) ~= '~' then
*****0         return P
           end

*****0     local home = getenv('HOME')
*****0     if (not home) and (not path.is_windows) then
               -- no more options to try on Nix
*****0         return nil, "failed to expand '~' (HOME not set)"
           end

*****0     if (not home) then
               -- try alternatives on Windows
*****0         home = getenv 'USERPROFILE'
*****0         if not home then
*****0             local hd = getenv 'HOMEDRIVE'
*****0             local hp = getenv 'HOMEPATH'
*****0             if not (hd and hp) then
*****0               return nil, "failed to expand '~' (HOME, USERPROFILE, and HOMEDRIVE and/or HOMEPATH not set)"
                   end
*****0             home = hd..hp
               end
           end

*****0     return home..sub(P,2)
       end


       ---Return a suitable full path to a new temporary file name.
       -- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)
*****0 function path.tmpname ()
*****0     local res = tmpnam()
           -- On Windows if Lua is compiled using MSVC14 os.tmpname
           -- already returns an absolute path within TEMP env variable directory,
           -- no need to prepend it.
*****0     if path.is_windows and not res:find(':') then
*****0         res = getenv('TEMP')..res
           end
*****0     return res
       end

       --- return the largest common prefix path of two paths.
       -- @string path1 a file path
       -- @string path2 a file path
       -- @return the common prefix (Windows: separators will be normalized, casing will be original)
*****0 function path.common_prefix (path1,path2)
*****0     assert_string(1,path1)
*****0     assert_string(2,path2)
           -- get them in order!
*****0     if #path1 > #path2 then path2,path1 = path1,path2 end
           local compare
*****0     if path.is_windows then
*****0         path1 = path1:gsub("/", "\\")
*****0         path2 = path2:gsub("/", "\\")
*****0         compare = function(v) return v:lower() end
           else
*****0         compare = function(v) return v end
           end
*****0     for i = 1,#path1 do
*****0         if compare(at(path1,i)) ~= compare(at(path2,i)) then
*****0             local cp = path1:sub(1,i-1)
*****0             if at(path1,i-1) ~= sep then
*****0                 cp = path.dirname(cp)
                   end
*****0             return cp
               end
           end
*****0     if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
*****0     return path1
           --return ''
       end

       --- return the full path where a particular Lua module would be found.
       -- Both package.path and package.cpath is searched, so the result may
       -- either be a Lua file or a shared library.
       -- @string mod name of the module
       -- @return on success: path of module, lua or binary
       -- @return on error: nil, error string listing paths tried
*****0 function path.package_path(mod)
*****0     assert_string(1,mod)
           local res, err1, err2
*****0     res, err1 = package.searchpath(mod,package.path)
*****0     if res then return res,true end
*****0     res, err2 = package.searchpath(mod,package.cpath)
*****0     if res then return res,false end
*****0     return raise ('cannot find module on path\n' .. err1 .. "\n" .. err2)
       end


       ---- finis -----
*****0 return path

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/tablex.lua
==============================================================================
       --- Extended operations on Lua tables.
       --
       -- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
       --
       -- Dependencies: `pl.utils`, `pl.types`
       -- @module pl.tablex
*****0 local utils = require ('pl.utils')
*****0 local types = require ('pl.types')
*****0 local getmetatable,setmetatable,require = getmetatable,setmetatable,require
*****0 local tsort,append,remove = table.sort,table.insert,table.remove
*****0 local min = math.min
*****0 local pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring
*****0 local function_arg = utils.function_arg
*****0 local assert_arg = utils.assert_arg

*****0 local tablex = {}

       -- generally, functions that make copies of tables try to preserve the metatable.
       -- However, when the source has no obvious type, then we attach appropriate metatables
       -- like List, Map, etc to the result.
       local function setmeta (res,tbl,pl_class)
     2     local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)
     2     return mt and setmetatable(res, mt) or res
       end

       local function makelist(l)
*****0     return setmetatable(l, require('pl.List'))
       end

       local function makemap(m)
*****0     return setmetatable(m, require('pl.Map'))
       end

       local function complain (idx,msg)
*****0     error(('argument %d is not %s'):format(idx,msg),3)
       end

       local function assert_arg_indexable (idx,val)
     4     if not types.is_indexable(val) then
*****0         complain(idx,"indexable")
           end
       end

       local function assert_arg_iterable (idx,val)
    18     if not types.is_iterable(val) then
*****0         complain(idx,"iterable")
           end
       end

       local function assert_arg_writeable (idx,val)
*****0     if not types.is_writeable(val) then
*****0         complain(idx,"writeable")
           end
       end

       --- copy a table into another, in-place.
       -- @within Copying
       -- @tab t1 destination table
       -- @tab t2 source (actually any iterable object)
       -- @return first table
*****0 function tablex.update (t1,t2)
*****0     assert_arg_writeable(1,t1)
*****0     assert_arg_iterable(2,t2)
*****0     for k,v in pairs(t2) do
*****0         t1[k] = v
           end
*****0     return t1
       end

       --- total number of elements in this table.
       -- Note that this is distinct from `#t`, which is the number
       -- of values in the array part; this value will always
       -- be greater or equal. The difference gives the size of
       -- the hash part, for practical purposes. Works for any
       -- object with a __pairs metamethod.
       -- @tab t a table
       -- @return the size
*****0 function tablex.size (t)
*****0     assert_arg_iterable(1,t)
*****0     local i = 0
*****0     for k in pairs(t) do i = i + 1 end
*****0     return i
       end

       --- make a shallow copy of a table
       -- @within Copying
       -- @tab t an iterable source
       -- @return new table
*****0 function tablex.copy (t)
     9     assert_arg_iterable(1,t)
     9     local res = {}
   905     for k,v in pairs(t) do
   896         res[k] = v
           end
     9     return res
       end

       local function cycle_aware_copy(t, cache)
*****0     if type(t) ~= 'table' then return t end
*****0     if cache[t] then return cache[t] end
*****0     assert_arg_iterable(1,t)
*****0     local res = {}
*****0     cache[t] = res
*****0     local mt = getmetatable(t)
*****0     for k,v in pairs(t) do
*****0         k = cycle_aware_copy(k, cache)
*****0         v = cycle_aware_copy(v, cache)
*****0         res[k] = v
           end
*****0     setmetatable(res,mt)
*****0     return res
       end

       --- make a deep copy of a table, recursively copying all the keys and fields.
       -- This supports cycles in tables; cycles will be reproduced in the copy.
       -- This will also set the copied table's metatable to that of the original.
       -- @within Copying
       -- @tab t A table
       -- @return new table
*****0 function tablex.deepcopy(t)
*****0     return cycle_aware_copy(t,{})
       end

*****0 local abs = math.abs

       local function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)
*****0     if cache[t1] and cache[t1][t2] then return true end
*****0     local ty1 = type(t1)
*****0     local ty2 = type(t2)
*****0     if ty1 ~= ty2 then return false end
           -- non-table types can be directly compared
*****0     if ty1 ~= 'table' then
*****0         if ty1 == 'number' and eps then return abs(t1-t2) < eps end
*****0         return t1 == t2
           end
           -- as well as tables which have the metamethod __eq
*****0     local mt = getmetatable(t1)
*****0     if not ignore_mt and mt and mt.__eq then return t1 == t2 end
*****0     for k1 in pairs(t1) do
*****0         if t2[k1]==nil then return false end
           end
*****0     for k2 in pairs(t2) do
*****0         if t1[k2]==nil then return false end
           end
*****0     cache[t1] = cache[t1] or {}
*****0     cache[t1][t2] = true
*****0     for k1,v1 in pairs(t1) do
*****0         local v2 = t2[k1]
*****0         if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end
           end
*****0     return true
       end

       --- compare two values.
       -- if they are tables, then compare their keys and fields recursively.
       -- @within Comparing
       -- @param t1 A value
       -- @param t2 A value
       -- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
       -- @number[opt] eps if defined, then used for any number comparisons
       -- @return true or false
*****0 function tablex.deepcompare(t1,t2,ignore_mt,eps)
*****0     return cycle_aware_compare(t1,t2,ignore_mt,eps,{})
       end

       --- compare two arrays using a predicate.
       -- @within Comparing
       -- @array t1 an array
       -- @array t2 an array
       -- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`
       -- @return true or false
       -- @usage
       -- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, "=="))
       --
       -- assert(tablex.compare(
       --    {1,2,3, hello = "world"},  -- fields are not compared!
       --    {1,2,3}, function(v1, v2) return v1 == v2 end)
*****0 function tablex.compare (t1,t2,cmp)
*****0     assert_arg_indexable(1,t1)
*****0     assert_arg_indexable(2,t2)
*****0     if #t1 ~= #t2 then return false end
*****0     cmp = function_arg(3,cmp)
*****0     for k = 1,#t1 do
*****0         if not cmp(t1[k],t2[k]) then return false end
           end
*****0     return true
       end

       --- compare two list-like tables using an optional predicate, without regard for element order.
       -- @within Comparing
       -- @array t1 a list-like table
       -- @array t2 a list-like table
       -- @param cmp A comparison function (may be nil)
*****0 function tablex.compare_no_order (t1,t2,cmp)
*****0     assert_arg_indexable(1,t1)
*****0     assert_arg_indexable(2,t2)
*****0     if cmp then cmp = function_arg(3,cmp) end
*****0     if #t1 ~= #t2 then return false end
*****0     local visited = {}
*****0     for i = 1,#t1 do
*****0         local val = t1[i]
               local gotcha
*****0         for j = 1,#t2 do
*****0             if not visited[j] then
                       local match
*****0                 if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
*****0                 if match then
*****0                     gotcha = j
                           break
                       end
                   end
               end
*****0         if not gotcha then return false end
*****0         visited[gotcha] = true
           end
*****0     return true
       end


       --- return the index of a value in a list.
       -- Like string.find, there is an optional index to start searching,
       -- which can be negative.
       -- @within Finding
       -- @array t A list-like table
       -- @param val A value
       -- @int idx index to start; -1 means last element,etc (default 1)
       -- @return index of value or nil if not found
       -- @usage find({10,20,30},20) == 2
       -- @usage find({'a','b','a','c'},'a',2) == 3
*****0 function tablex.find(t,val,idx)
*****0     assert_arg_indexable(1,t)
*****0     idx = idx or 1
*****0     if idx < 0 then idx = #t + idx + 1 end
*****0     for i = idx,#t do
*****0         if t[i] == val then return i end
           end
*****0     return nil
       end

       --- return the index of a value in a list, searching from the end.
       -- Like string.find, there is an optional index to start searching,
       -- which can be negative.
       -- @within Finding
       -- @array t A list-like table
       -- @param val A value
       -- @param idx index to start; -1 means last element,etc (default `#t`)
       -- @return index of value or nil if not found
       -- @usage rfind({10,10,10},10) == 3
*****0 function tablex.rfind(t,val,idx)
*****0     assert_arg_indexable(1,t)
*****0     idx = idx or #t
*****0     if idx < 0 then idx = #t + idx + 1 end
*****0     for i = idx,1,-1 do
*****0         if t[i] == val then return i end
           end
*****0     return nil
       end


       --- return the index (or key) of a value in a table using a comparison function.
       --
       -- *NOTE*: the 2nd return value of this function, the value returned
       -- by the comparison function, has a limitation that it cannot be `false`.
       -- Because if it is, then it indicates the comparison failed, and the
       -- function will continue the search. See examples.
       -- @within Finding
       -- @tab t A table
       -- @func cmp A comparison function
       -- @param arg an optional second argument to the function
       -- @return index of value, or nil if not found
       -- @return value returned by comparison function (cannot be `false`!)
       -- @usage
       -- -- using an operator
       -- local lst = { "Rudolph", true, false, 15 }
       -- local idx, cmp_result = tablex.rfind(lst, "==", "Rudolph")
       -- assert(idx == 1)
       -- assert(cmp_result == true)
       --
       -- local idx, cmp_result = tablex.rfind(lst, "==", false)
       -- assert(idx == 3)
       -- assert(cmp_result == true)       -- looking up 'false' works!
       --
       -- -- using a function returning the value looked up
       -- local cmp = function(v1, v2) return v1 == v2 and v2 end
       -- local idx, cmp_result = tablex.rfind(lst, cmp, "Rudolph")
       -- assert(idx == 1)
       -- assert(cmp_result == "Rudolph")  -- the value is returned
       --
       -- -- NOTE: this fails, since 'false' cannot be returned!
       -- local idx, cmp_result = tablex.rfind(lst, cmp, false)
       -- assert(idx == nil)               -- looking up 'false' failed!
       -- assert(cmp_result == nil)
*****0 function tablex.find_if(t,cmp,arg)
*****0     assert_arg_iterable(1,t)
*****0     cmp = function_arg(2,cmp)
*****0     for k,v in pairs(t) do
*****0         local c = cmp(v,arg)
*****0         if c then return k,c end
           end
*****0     return nil
       end

       --- return a list of all values in a table indexed by another list.
       -- @tab tbl a table
       -- @array idx an index table (a list of keys)
       -- @return a list-like table
       -- @usage index_by({10,20,30,40},{2,4}) == {20,40}
       -- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
*****0 function tablex.index_by(tbl,idx)
*****0     assert_arg_indexable(1,tbl)
*****0     assert_arg_indexable(2,idx)
*****0     local res = {}
*****0     for i = 1,#idx do
*****0         res[i] = tbl[idx[i]]
           end
*****0     return setmeta(res,tbl,'List')
       end

       --- apply a function to all values of a table.
       -- This returns a table of the results.
       -- Any extra arguments are passed to the function.
       -- @within MappingAndFiltering
       -- @func fun A function that takes at least one argument
       -- @tab t A table
       -- @param ... optional arguments
       -- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
*****0 function tablex.map(fun,t,...)
*****0     assert_arg_iterable(1,t)
*****0     fun = function_arg(1,fun)
*****0     local res = {}
*****0     for k,v in pairs(t) do
*****0         res[k] = fun(v,...)
           end
*****0     return setmeta(res,t)
       end

       --- apply a function to all values of a list.
       -- This returns a table of the results.
       -- Any extra arguments are passed to the function.
       -- @within MappingAndFiltering
       -- @func fun A function that takes at least one argument
       -- @array t a table (applies to array part)
       -- @param ... optional arguments
       -- @return a list-like table
       -- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
*****0 function tablex.imap(fun,t,...)
*****0     assert_arg_indexable(1,t)
*****0     fun = function_arg(1,fun)
*****0     local res = {}
*****0     for i = 1,#t do
*****0         res[i] = fun(t[i],...) or false
           end
*****0     return setmeta(res,t,'List')
       end

       --- apply a named method to values from a table.
       -- @within MappingAndFiltering
       -- @string name the method name
       -- @array t a list-like table
       -- @param ... any extra arguments to the method
       -- @return a `List` with the results of the method (1st result only)
       -- @usage
       -- local Car = {}
       -- Car.__index = Car
       -- function Car.new(car)
       --   return setmetatable(car or {}, Car)
       -- end
       -- Car.speed = 0
       -- function Car:faster(increase)
       --   self.speed = self.speed + increase
       --   return self.speed
       -- end
       --
       -- local ferrari = Car.new{ name = "Ferrari" }
       -- local lamborghini = Car.new{ name = "Lamborghini", speed = 50 }
       -- local cars = { ferrari, lamborghini }
       --
       -- assert(ferrari.speed == 0)
       -- assert(lamborghini.speed == 50)
       -- tablex.map_named_method("faster", cars, 10)
       -- assert(ferrari.speed == 10)
       -- assert(lamborghini.speed == 60)
*****0 function tablex.map_named_method (name,t,...)
*****0     utils.assert_string(1,name)
*****0     assert_arg_indexable(2,t)
*****0     local res = {}
*****0     for i = 1,#t do
*****0         local val = t[i]
*****0         local fun = val[name]
*****0         res[i] = fun(val,...)
           end
*****0     return setmeta(res,t,'List')
       end

       --- apply a function to all values of a table, in-place.
       -- Any extra arguments are passed to the function.
       -- @func fun A function that takes at least one argument
       -- @tab t a table
       -- @param ... extra arguments passed to `fun`
       -- @see tablex.foreach
*****0 function tablex.transform (fun,t,...)
*****0     assert_arg_iterable(1,t)
*****0     fun = function_arg(1,fun)
*****0     for k,v in pairs(t) do
*****0         t[k] = fun(v,...)
           end
       end

       --- generate a table of all numbers in a range.
       -- This is consistent with a numerical for loop.
       -- @int start  number
       -- @int finish number
       -- @int[opt=1] step  make this negative for start < finish
*****0 function tablex.range (start,finish,step)
           local res
*****0     step = step or 1
*****0     if start == finish then
*****0         res = {start}
*****0     elseif (start > finish and step > 0) or (finish > start and step < 0) then
*****0         res = {}
           else
*****0         local k = 1
*****0         res = {}
*****0         for i=start,finish,step do res[k]=i; k=k+1 end
           end
*****0     return makelist(res)
       end

       --- apply a function to values from two tables.
       -- @within MappingAndFiltering
       -- @func fun a function of at least two arguments
       -- @tab t1 a table
       -- @tab t2 a table
       -- @param ... extra arguments
       -- @return a table
       -- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
*****0 function tablex.map2 (fun,t1,t2,...)
*****0     assert_arg_iterable(1,t1)
*****0     assert_arg_iterable(2,t2)
*****0     fun = function_arg(1,fun)
*****0     local res = {}
*****0     for k,v in pairs(t1) do
*****0         res[k] = fun(v,t2[k],...)
           end
*****0     return setmeta(res,t1,'List')
       end

       --- apply a function to values from two arrays.
       -- The result will be the length of the shortest array.
       -- @within MappingAndFiltering
       -- @func fun a function of at least two arguments
       -- @array t1 a list-like table
       -- @array t2 a list-like table
       -- @param ... extra arguments
       -- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
*****0 function tablex.imap2 (fun,t1,t2,...)
*****0     assert_arg_indexable(2,t1)
*****0     assert_arg_indexable(3,t2)
*****0     fun = function_arg(1,fun)
*****0     local res,n = {},math.min(#t1,#t2)
*****0     for i = 1,n do
*****0         res[i] = fun(t1[i],t2[i],...)
           end
*****0     return res
       end

       --- 'reduce' a list using a binary function.
       -- @func fun a function of two arguments
       -- @array t a list-like table
       -- @array memo optional initial memo value. Defaults to first value in table.
       -- @return the result of the function
       -- @usage reduce('+',{1,2,3,4}) == 10
*****0 function tablex.reduce (fun,t,memo)
*****0     assert_arg_indexable(2,t)
*****0     fun = function_arg(1,fun)
*****0     local n = #t
*****0     if n == 0 then
*****0         return memo
           end
*****0     local res = memo and fun(memo, t[1]) or t[1]
*****0     for i = 2,n do
*****0         res = fun(res,t[i])
           end
*****0     return res
       end

       --- apply a function to all elements of a table.
       -- The arguments to the function will be the value,
       -- the key and _finally_ any extra arguments passed to this function.
       -- Note that the Lua 5.0 function table.foreach passed the _key_ first.
       -- @within Iterating
       -- @tab t a table
       -- @func fun a function on the elements; `function(value, key, ...)`
       -- @param ... extra arguments passed to `fun`
       -- @see tablex.transform
*****0 function tablex.foreach(t,fun,...)
*****0     assert_arg_iterable(1,t)
*****0     fun = function_arg(2,fun)
*****0     for k,v in pairs(t) do
*****0         fun(v,k,...)
           end
       end

       --- apply a function to all elements of a list-like table in order.
       -- The arguments to the function will be the value,
       -- the index and _finally_ any extra arguments passed to this function
       -- @within Iterating
       -- @array t a table
       -- @func fun a function with at least one argument
       -- @param ... optional arguments
*****0 function tablex.foreachi(t,fun,...)
*****0     assert_arg_indexable(1,t)
*****0     fun = function_arg(2,fun)
*****0     for i = 1,#t do
*****0         fun(t[i],i,...)
           end
       end

       --- Apply a function to a number of tables.
       -- A more general version of map
       -- The result is a table containing the result of applying that function to the
       -- ith value of each table. Length of output list is the minimum length of all the lists
       -- @within MappingAndFiltering
       -- @func fun a function of n arguments
       -- @tab ... n tables
       -- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
       -- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}
       -- @param fun A function that takes as many arguments as there are tables
*****0 function tablex.mapn(fun,...)
*****0     fun = function_arg(1,fun)
*****0     local res = {}
*****0     local lists = {...}
*****0     local minn = 1e40
*****0     for i = 1,#lists do
*****0         minn = min(minn,#(lists[i]))
           end
*****0     for i = 1,minn do
*****0         local args,k = {},1
*****0         for j = 1,#lists do
*****0             args[k] = lists[j][i]
*****0             k = k + 1
               end
*****0         res[#res+1] = fun(unpack(args))
           end
*****0     return res
       end

       --- call the function with the key and value pairs from a table.
       -- The function can return a value and a key (note the order!). If both
       -- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that
       -- key into a table and append into it. If only value is not nil, then it is appended to the result.
       -- @within MappingAndFiltering
       -- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
       -- @tab t A table
       -- @param ... optional arguments
       -- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
       -- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
*****0 function tablex.pairmap(fun,t,...)
*****0     assert_arg_iterable(1,t)
*****0     fun = function_arg(1,fun)
*****0     local res = {}
*****0     for k,v in pairs(t) do
*****0         local rv,rk = fun(k,v,...)
*****0         if rk then
*****0             if res[rk] then
*****0                 if type(res[rk]) == 'table' then
*****0                     table.insert(res[rk],rv)
                       else
*****0                     res[rk] = {res[rk], rv}
                       end
                   else
*****0                 res[rk] = rv
                   end
               else
*****0             res[#res+1] = rv
               end
           end
*****0     return res
       end

*****0 local function keys_op(i,v) return i end

       --- return all the keys of a table in arbitrary order.
       -- @within Extraction
       -- @tab t A list-like table where the values are the keys of the input table
*****0 function tablex.keys(t)
*****0     assert_arg_iterable(1,t)
*****0     return makelist(tablex.pairmap(keys_op,t))
       end

*****0 local function values_op(i,v) return v end

       --- return all the values of the table in arbitrary order
       -- @within Extraction
       -- @tab t A list-like table where the values are the values of the input table
*****0 function tablex.values(t)
*****0     assert_arg_iterable(1,t)
*****0     return makelist(tablex.pairmap(values_op,t))
       end

*****0 local function index_map_op (i,v) return i,v end

       --- create an index map from a list-like table. The original values become keys,
       -- and the associated values are the indices into the original list.
       -- @array t a list-like table
       -- @return a map-like table
*****0 function tablex.index_map (t)
*****0     assert_arg_indexable(1,t)
*****0     return makemap(tablex.pairmap(index_map_op,t))
       end

*****0 local function set_op(i,v) return true,v end

       --- create a set from a list-like table. A set is a table where the original values
       -- become keys, and the associated values are all true.
       -- @array t a list-like table
       -- @return a set (a map-like table)
*****0 function tablex.makeset (t)
*****0     assert_arg_indexable(1,t)
*****0     return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))
       end

       --- combine two tables, either as union or intersection. Corresponds to
       -- set operations for sets () but more general. Not particularly
       -- useful for list-like tables.
       -- @within Merging
       -- @tab t1 a table
       -- @tab t2 a table
       -- @bool dup true for a union, false for an intersection.
       -- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
       -- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
       -- @see tablex.index_map
*****0 function tablex.merge (t1,t2,dup)
*****0     assert_arg_iterable(1,t1)
*****0     assert_arg_iterable(2,t2)
*****0     local res = {}
*****0     for k,v in pairs(t1) do
*****0         if dup or t2[k] then res[k] = v end
           end
*****0     if dup then
*****0       for k,v in pairs(t2) do
*****0         res[k] = v
             end
           end
*****0     return setmeta(res,t1,'Map')
       end

       --- the union of two map-like tables.
       -- If there are duplicate keys, the second table wins.
       -- @tab t1 a table
       -- @tab t2 a table
       -- @treturn tab
       -- @see tablex.merge
*****0 function tablex.union(t1, t2)
*****0     return tablex.merge(t1, t2, true)
       end

       --- the intersection of two map-like tables.
       -- @tab t1 a table
       -- @tab t2 a table
       -- @treturn tab
       -- @see tablex.merge
*****0 function tablex.intersection(t1, t2)
*****0     return tablex.merge(t1, t2, false)
       end

       --- a new table which is the difference of two tables.
       -- With sets (where the values are all true) this is set difference and
       -- symmetric difference depending on the third parameter.
       -- @within Merging
       -- @tab s1 a map-like table or set
       -- @tab s2 a map-like table or set
       -- @bool symm symmetric difference (default false)
       -- @return a map-like table or set
*****0 function tablex.difference (s1,s2,symm)
*****0     assert_arg_iterable(1,s1)
*****0     assert_arg_iterable(2,s2)
*****0     local res = {}
*****0     for k,v in pairs(s1) do
*****0         if s2[k] == nil then res[k] = v end
           end
*****0     if symm then
*****0         for k,v in pairs(s2) do
*****0             if s1[k] == nil then res[k] = v end
               end
           end
*****0     return setmeta(res,s1,'Map')
       end

       --- A table where the key/values are the values and value counts of the table.
       -- @array t a list-like table
       -- @func cmp a function that defines equality (otherwise uses ==)
       -- @return a map-like table
       -- @see seq.count_map
*****0 function tablex.count_map (t,cmp)
*****0     assert_arg_indexable(1,t)
*****0     local res,mask = {},{}
*****0     cmp = function_arg(2,cmp or '==')
*****0     local n = #t
*****0     for i = 1,#t do
*****0         local v = t[i]
*****0         if not mask[v] then
*****0             mask[v] = true
                   -- check this value against all other values
*****0             res[v] = 1  -- there's at least one instance
*****0             for j = i+1,n do
*****0                 local w = t[j]
*****0                 local ok = cmp(v,w)
*****0                 if ok then
*****0                     res[v] = res[v] + 1
*****0                     mask[w] = true
                       end
                   end
               end
           end
*****0     return makemap(res)
       end

       --- filter an array's values using a predicate function
       -- @within MappingAndFiltering
       -- @array t a list-like table
       -- @func pred a boolean function
       -- @param arg optional argument to be passed as second argument of the predicate
*****0 function tablex.filter (t,pred,arg)
     2     assert_arg_indexable(1,t)
     4     pred = function_arg(2,pred)
     2     local res,k = {},1
    19     for i = 1,#t do
    17         local v = t[i]
    34         if pred(v,arg) then
    16             res[k] = v
    16             k = k + 1
               end
           end
     2     return setmeta(res,t,'List')
       end

       --- return a table where each element is a table of the ith values of an arbitrary
       -- number of tables. It is equivalent to a matrix transpose.
       -- @within Merging
       -- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
       -- @array ... arrays to be zipped
*****0 function tablex.zip(...)
*****0     return tablex.mapn(function(...) return {...} end,...)
       end

       local _copy
*****0 function _copy (dest,src,idest,isrc,nsrc,clean_tail)
*****0     idest = idest or 1
*****0     isrc = isrc or 1
           local iend
*****0     if not nsrc then
*****0         nsrc = #src
*****0         iend = #src
           else
*****0         iend = isrc + min(nsrc-1,#src-isrc)
           end
*****0     if dest == src then -- special case
*****0         if idest > isrc and iend >= idest then -- overlapping ranges
*****0             src = tablex.sub(src,isrc,nsrc)
*****0             isrc = 1; iend = #src
               end
           end
*****0     for i = isrc,iend do
*****0         dest[idest] = src[i]
*****0         idest = idest + 1
           end
*****0     if clean_tail then
*****0         tablex.clear(dest,idest)
           end
*****0     return dest
       end

       --- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
       -- @within Copying
       -- @array dest a list-like table
       -- @array src a list-like table
       -- @int[opt=1] idest where to start copying values into destination
       -- @int[opt=1] isrc where to start copying values from source
       -- @int[opt=#src] nsrc number of elements to copy from source
*****0 function tablex.icopy (dest,src,idest,isrc,nsrc)
*****0     assert_arg_indexable(1,dest)
*****0     assert_arg_indexable(2,src)
*****0     return _copy(dest,src,idest,isrc,nsrc,true)
       end

       --- copy an array into another one.
       -- @within Copying
       -- @array dest a list-like table
       -- @array src a list-like table
       -- @int[opt=1] idest where to start copying values into destination
       -- @int[opt=1] isrc where to start copying values from source
       -- @int[opt=#src] nsrc number of elements to copy from source
*****0 function tablex.move (dest,src,idest,isrc,nsrc)
*****0     assert_arg_indexable(1,dest)
*****0     assert_arg_indexable(2,src)
*****0     return _copy(dest,src,idest,isrc,nsrc,false)
       end

*****0 function tablex._normalize_slice(self,first,last)
*****0   local sz = #self
*****0   if not first then first=1 end
*****0   if first<0 then first=sz+first+1 end
         -- make the range _inclusive_!
*****0   if not last then last=sz end
*****0   if last < 0 then last=sz+1+last end
*****0   return first,last
       end

       --- Extract a range from a table, like  'string.sub'.
       -- If first or last are negative then they are relative to the end of the list
       -- eg. sub(t,-2) gives last 2 entries in a list, and
       -- sub(t,-4,-2) gives from -4th to -2nd
       -- @within Extraction
       -- @array t a list-like table
       -- @int first An index
       -- @int last An index
       -- @return a new List
*****0 function tablex.sub(t,first,last)
*****0     assert_arg_indexable(1,t)
*****0     first,last = tablex._normalize_slice(t,first,last)
*****0     local res={}
*****0     for i=first,last do append(res,t[i]) end
*****0     return setmeta(res,t,'List')
       end

       --- set an array range to a value. If it's a function we use the result
       -- of applying it to the indices.
       -- @array t a list-like table
       -- @param val a value
       -- @int[opt=1] i1 start range
       -- @int[opt=#t] i2 end range
*****0 function tablex.set (t,val,i1,i2)
*****0     assert_arg_indexable(1,t)
*****0     i1,i2 = i1 or 1,i2 or #t
*****0     if types.is_callable(val) then
*****0         for i = i1,i2 do
*****0             t[i] = val(i)
               end
           else
*****0         for i = i1,i2 do
*****0             t[i] = val
               end
           end
       end

       --- create a new array of specified size with initial value.
       -- @int n size
       -- @param val initial value (can be `nil`, but don't expect `#` to work!)
       -- @return the table
*****0 function tablex.new (n,val)
*****0     local res = {}
*****0     tablex.set(res,val,1,n)
*****0     return res
       end

       --- clear out the contents of a table.
       -- @array t a list
       -- @param istart optional start position
*****0 function tablex.clear(t,istart)
*****0     istart = istart or 1
*****0     for i = istart,#t do remove(t) end
       end

       --- insert values into a table.
       -- similar to `table.insert` but inserts values from given table `values`,
       -- not the object itself, into table `t` at position `pos`.
       -- @within Copying
       -- @array t the list
       -- @int[opt] position (default is at end)
       -- @array values
*****0 function tablex.insertvalues(t, ...)
     1     assert_arg(1,t,'table')
           local pos, values
     1     if select('#', ...) == 1 then
     1         pos,values = #t+1, ...
           else
*****0         pos,values = ...
           end
     1     if #values > 0 then
     1         for i=#t,pos,-1 do
*****0             t[i+#values] = t[i]
               end
     1         local offset = 1 - pos
     9         for i=pos,pos+#values-1 do
     8             t[i] = values[i + offset]
               end
           end
     1     return t
       end

       --- remove a range of values from a table.
       -- End of range may be negative.
       -- @array t a list-like table
       -- @int i1 start index
       -- @int i2 end index
       -- @return the table
*****0 function tablex.removevalues (t,i1,i2)
*****0     assert_arg(1,t,'table')
*****0     i1,i2 = tablex._normalize_slice(t,i1,i2)
*****0     for i = i1,i2 do
*****0         remove(t,i1)
           end
*****0     return t
       end

       local _find
       _find = function (t,value,tables)
*****0     for k,v in pairs(t) do
*****0         if v == value then return k end
           end
*****0     for k,v in pairs(t) do
*****0         if not tables[v] and type(v) == 'table' then
*****0             tables[v] = true
*****0             local res = _find(v,value,tables)
*****0             if res then
*****0                 res = tostring(res)
*****0                 if type(k) ~= 'string' then
*****0                     return '['..k..']'..res
                       else
*****0                     return k..'.'..res
                       end
                   end
               end
           end
       end

       --- find a value in a table by recursive search.
       -- @within Finding
       -- @tab t the table
       -- @param value the value
       -- @array[opt] exclude any tables to avoid searching
       -- @return a fieldspec, e.g. 'a.b' or 'math.sin'
       -- @usage search(_G,math.sin,{package.path}) == 'math.sin'
*****0 function tablex.search (t,value,exclude)
*****0     assert_arg_iterable(1,t)
*****0     local tables = {[t]=true}
*****0     if exclude then
*****0         for _,v in pairs(exclude) do tables[v] = true end
           end
*****0     return _find(t,value,tables)
       end

       --- return an iterator to a table sorted by its keys
       -- @within Iterating
       -- @tab t the table
       -- @func f an optional comparison function (f(x,y) is true if x < y)
       -- @usage for k,v in tablex.sort(t) do print(k,v) end
       -- @return an iterator to traverse elements sorted by the keys
*****0 function tablex.sort(t,f)
*****0     local keys = {}
*****0     for k in pairs(t) do keys[#keys + 1] = k end
*****0     tsort(keys,f)
*****0     local i = 0
           return function()
*****0         i = i + 1
*****0         return keys[i], t[keys[i]]
           end
       end

       --- return an iterator to a table sorted by its values
       -- @within Iterating
       -- @tab t the table
       -- @func f an optional comparison function (f(x,y) is true if x < y)
       -- @usage for k,v in tablex.sortv(t) do print(k,v) end
       -- @return an iterator to traverse elements sorted by the values
*****0 function tablex.sortv(t,f)
*****0     f = function_arg(2, f or '<')
*****0     local keys = {}
*****0     for k in pairs(t) do keys[#keys + 1] = k end
*****0     tsort(keys,function(x, y) return f(t[x], t[y]) end)
*****0     local i = 0
           return function()
*****0         i = i + 1
*****0         return keys[i], t[keys[i]]
           end
       end

       --- modifies a table to be read only.
       -- This only offers weak protection. Tables can still be modified with
       -- `table.insert` and `rawset`.
       --
       -- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the
       -- equivalent metamethods are only available in Lua 5.2 and newer.
       -- @tab t the table
       -- @return the table read only (a proxy).
*****0 function tablex.readonly(t)
*****0     local mt = {
               __index=t,
               __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
               __pairs=function() return pairs(t) end,
               __ipairs=function() return ipairs(t) end,
               __len=function() return #t end,
*****0         __metatable=false
           }
*****0     return setmetatable({}, mt)
       end

*****0 return tablex

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/types.lua
==============================================================================
       ---- Dealing with Detailed Type Information

       -- Dependencies `pl.utils`
       -- @module pl.types

*****0 local utils = require 'pl.utils'
*****0 local math_ceil = math.ceil
*****0 local assert_arg = utils.assert_arg
*****0 local types = {}

       --- is the object either a function or a callable object?.
       -- @param obj Object to check.
*****0 function types.is_callable (obj)
*****0     return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call and true
       end

       --- is the object of the specified type?.
       -- If the type is a string, then use type, otherwise compare with metatable.
       --
       -- NOTE: this function is imported from `utils.is_type`.
       -- @param obj An object to check
       -- @param tp The expected type
       -- @function is_type
       -- @see utils.is_type
*****0 types.is_type = utils.is_type

*****0 local fileMT = getmetatable(io.stdout)

       --- a string representation of a type.
       -- For tables and userdata with metatables, we assume that the metatable has a `_name`
       -- field. If the field is not present it will return 'unknown table' or
       -- 'unknown userdata'.
       -- Lua file objects return the type 'file'.
       -- @param obj an object
       -- @return a string like 'number', 'table', 'file' or 'List'
*****0 function types.type (obj)
*****0     local t = type(obj)
*****0     if t == 'table' or t == 'userdata' then
*****0         local mt = getmetatable(obj)
*****0         if mt == fileMT then
*****0             return 'file'
*****0         elseif mt == nil then
*****0             return t
               else
                   -- TODO: the "unknown" is weird, it should just return the type
*****0             return mt._name or "unknown "..t
               end
           else
*****0         return t
           end
       end

       --- is this number an integer?
       -- @param x a number
       -- @raise error if x is not a number
       -- @return boolean
*****0 function types.is_integer (x)
*****0     return math_ceil(x)==x
       end

       --- Check if the object is "empty".
       -- An object is considered empty if it is:
       --
       -- - `nil`
       -- - a table without any items (key-value pairs or indexes)
       -- - a string with no content ("")
       -- - not a nil/table/string
       -- @param o The object to check if it is empty.
       -- @param ignore_spaces If the object is a string and this is true the string is
       -- considered empty if it only contains spaces.
       -- @return `true` if the object is empty, otherwise a falsy value.
*****0 function types.is_empty(o, ignore_spaces)
*****0     if o == nil then
*****0         return true
*****0     elseif type(o) == "table" then
*****0         return next(o) == nil
*****0     elseif type(o) == "string" then
*****0         return o == "" or (not not ignore_spaces and (not not o:find("^%s+$")))
           else
*****0         return true
           end
       end

       local function check_meta (val)
    11     if type(val) == 'table' then return true end
*****0     return getmetatable(val)
       end

       --- is an object 'array-like'?
       -- An object is array like if:
       --
       -- - it is a table, or
       -- - it has a metatable with `__len` and `__index` methods
       --
       -- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata
       -- @param val any value.
       -- @return `true` if the object is array-like, otherwise a falsy value.
*****0 function types.is_indexable (val)
     2     local mt = check_meta(val)
     2     if mt == true then return true end
*****0     return mt and mt.__len and mt.__index and true
       end

       --- can an object be iterated over with `pairs`?
       -- An object is iterable if:
       --
       -- - it is a table, or
       -- - it has a metatable with a `__pairs` meta method
       --
       -- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata
       -- @param val any value.
       -- @return `true` if the object is iterable, otherwise a falsy value.
*****0 function types.is_iterable (val)
     9     local mt = check_meta(val)
     9     if mt == true then return true end
*****0     return mt and mt.__pairs and true
       end

       --- can an object accept new key/pair values?
       -- An object is iterable if:
       --
       -- - it is a table, or
       -- - it has a metatable with a `__newindex` meta method
       --
       -- @param val any value.
       -- @return `true` if the object is writeable, otherwise a falsy value.
*****0 function types.is_writeable (val)
*****0     local mt = check_meta(val)
*****0     if mt == true then return true end
*****0     return mt and mt.__newindex and true
       end

       -- Strings that should evaluate to true.   -- TODO: add on/off ???
*****0 local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
       -- Conditions types should evaluate to true.
*****0 local true_types = {
           boolean=function(o, true_strs, check_objs) return o end,
           string=function(o, true_strs, check_objs)
*****0         o = o:lower()
*****0         if trues[o] then
*****0             return true
               end
               -- Check alternative user provided strings.
*****0         for _,v in ipairs(true_strs or {}) do
*****0             if type(v) == "string" and o == v:lower() then
*****0                 return true
                   end
               end
*****0         return false
           end,
           number=function(o, true_strs, check_objs) return o ~= 0 end,
*****0     table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
       }
       --- Convert to a boolean value.
       -- True values are:
       --
       -- * boolean: true.
       -- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
       -- * number: Any non-zero value.
       -- * table: Is not empty and `check_objs` is true.
       -- * everything else: Is not `nil` and `check_objs` is true.
       --
       -- @param o The object to evaluate.
       -- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
       -- This should be a List of strings. E.g. "ja" to support German.
       -- @param[opt] check_objs True if objects should be evaluated.
       -- @return true if the input evaluates to true, otherwise false.
*****0 function types.to_bool(o, true_strs, check_objs)
           local true_func
*****0     if true_strs then
*****0         assert_arg(2, true_strs, "table")
           end
*****0     true_func = true_types[type(o)]
*****0     if true_func then
*****0         return true_func(o, true_strs, check_objs)
*****0     elseif check_objs and o ~= nil then
*****0         return true
           end
*****0     return false
       end


*****0 return types

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/utils.lua
==============================================================================
       --- Generally useful routines.
       -- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
       --
       -- Dependencies: `pl.compat`, all exported fields and functions from
       -- `pl.compat` are also available in this module.
       --
       -- @module pl.utils
*****0 local format = string.format
*****0 local compat = require 'pl.compat'
*****0 local stdout = io.stdout
*****0 local append = table.insert
*****0 local concat = table.concat
*****0 local _unpack = table.unpack  -- always injected by 'compat'
*****0 local find = string.find
*****0 local sub = string.sub
*****0 local next = next
*****0 local floor = math.floor

*****0 local is_windows = compat.is_windows
*****0 local err_mode = 'default'
       local raise
       local operators
*****0 local _function_factories = {}


*****0 local utils = { _VERSION = "1.14.0" }
*****0 for k, v in pairs(compat) do utils[k] = v  end

       --- Some standard patterns
       -- @table patterns
*****0 utils.patterns = {
           FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number
           INTEGER = '[+%-%d]%d*',                     -- integer number
           IDEN = '[%a_][%w_]*',                       -- identifier
           FILE = '[%a%.\\][:%][%w%._%-\\]*',          -- file
       }


       --- Standard meta-tables as used by other Penlight modules
       -- @table stdmt
       -- @field List the List metatable
       -- @field Map the Map metatable
       -- @field Set the Set metatable
       -- @field MultiMap the MultiMap metatable
*****0 utils.stdmt = {
           List = {_name='List'},
           Map = {_name='Map'},
           Set = {_name='Set'},
           MultiMap = {_name='MultiMap'},
       }


       --- pack an argument list into a table.
       -- @param ... any arguments
       -- @return a table with field `n` set to the length
       -- @function utils.pack
       -- @see compat.pack
       -- @see utils.npairs
       -- @see utils.unpack
*****0 utils.pack = table.pack  -- added here to be symmetrical with unpack

       --- unpack a table and return its contents.
       --
       -- NOTE: this implementation differs from the Lua implementation in the way
       -- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.
       -- @param t table to unpack
       -- @param[opt] i index from which to start unpacking, defaults to 1
       -- @param[opt] j index of the last element to unpack, defaults to `t.n` or else `#t`
       -- @return multiple return values from the table
       -- @function utils.unpack
       -- @see compat.unpack
       -- @see utils.pack
       -- @see utils.npairs
       -- @usage
       -- local t = table.pack(nil, nil, nil, 4)
       -- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil
       --
       -- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4
*****0 function utils.unpack(t, i, j)
*****0     return _unpack(t, i or 1, j or t.n or #t)
       end

       --- print an arbitrary number of arguments using a format.
       -- Output will be sent to `stdout`.
       -- @param fmt The format (see `string.format`)
       -- @param ... Extra arguments for format
*****0 function utils.printf(fmt, ...)
*****0     utils.assert_string(1, fmt)
*****0     utils.fprintf(stdout, fmt, ...)
       end

       --- write an arbitrary number of arguments to a file using a format.
       -- @param f File handle to write to.
       -- @param fmt The format (see `string.format`).
       -- @param ... Extra arguments for format
*****0 function utils.fprintf(f,fmt,...)
*****0     utils.assert_string(2,fmt)
*****0     f:write(format(fmt,...))
       end

       do
           local function import_symbol(T,k,v,libname)
*****0         local key = rawget(T,k)
               -- warn about collisions!
*****0         if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
*****0             utils.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",libname,k)
*****0             return
               end
*****0         rawset(T,k,v)
           end

           local function lookup_lib(T,t)
*****0         for k,v in pairs(T) do
*****0             if v == t then return k end
               end
*****0         return '?'
           end

*****0     local already_imported = {}

           --- take a table and 'inject' it into the local namespace.
           -- @param t The table (table), or module name (string), defaults to this `utils` module table
           -- @param T An optional destination table (defaults to callers environment)
*****0     function utils.import(t,T)
*****0         T = T or _G
*****0         t = t or utils
*****0         if type(t) == 'string' then
*****0             t = require (t)
               end
*****0         local libname = lookup_lib(T,t)
*****0         if already_imported[t] then return end
*****0         already_imported[t] = libname
*****0         for k,v in pairs(t) do
*****0             import_symbol(T,k,v,libname)
               end
           end
       end

       --- return either of two values, depending on a condition.
       -- @param cond A condition
       -- @param value1 Value returned if cond is truthy
       -- @param value2 Value returned if cond is falsy
*****0 function utils.choose(cond, value1, value2)
*****0     if cond then
*****0         return value1
           else
*****0         return value2
           end
       end

       --- convert an array of values to strings.
       -- @param t a list-like table
       -- @param[opt] temp (table) buffer to use, otherwise allocate
       -- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.
       -- @return the converted buffer
*****0 function utils.array_tostring (t,temp,tostr)
*****0     temp, tostr = temp or {}, tostr or tostring
*****0     for i = 1,#t do
*****0         temp[i] = tostr(t[i],i)
           end
*****0     return temp
       end



       --- is the object of the specified type?
       -- If the type is a string, then use type, otherwise compare with metatable
       -- @param obj An object to check
       -- @param tp String of what type it should be
       -- @return boolean
       -- @usage utils.is_type("hello world", "string")   --> true
       -- -- or check metatable
       -- local my_mt = {}
       -- local my_obj = setmetatable(my_obj, my_mt)
       -- utils.is_type(my_obj, my_mt)  --> true
*****0 function utils.is_type (obj,tp)
*****0     if type(tp) == 'string' then return type(obj) == tp end
*****0     local mt = getmetatable(obj)
*****0     return tp == mt
       end



       --- an iterator with indices, similar to `ipairs`, but with a range.
       -- This is a nil-safe index based iterator that will return `nil` when there
       -- is a hole in a list. To be safe ensure that table `t.n` contains the length.
       -- @tparam table t the table to iterate over
       -- @tparam[opt=1] integer i_start start index
       -- @tparam[opt=t.n or #t] integer i_end end index
       -- @tparam[opt=1] integer step step size
       -- @treturn integer index
       -- @treturn any value at index (which can be `nil`!)
       -- @see utils.pack
       -- @see utils.unpack
       -- @usage
       -- local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing
       --
       -- for i, v in utils.npairs(t, 2) do  -- start at index 2
       --   t[i] = tostring(t[i])
       -- end
       --
       -- -- t = { n = 3, [2] = "123", [3] = "nil" }
*****0 function utils.npairs(t, i_start, i_end, step)
*****0   step = step or 1
*****0   if step == 0 then
*****0     error("iterator step-size cannot be 0", 2)
         end
*****0   local i = (i_start or 1) - step
*****0   i_end = i_end or t.n or #t
*****0   if step < 0 then
           return function()
*****0       i = i + step
*****0       if i < i_end then
*****0         return nil
             end
*****0       return i, t[i]
           end

         else
           return function()
*****0       i = i + step
*****0       if i > i_end then
*****0         return nil
             end
*****0       return i, t[i]
           end
         end
       end



       --- an iterator over all non-integer keys (inverse of `ipairs`).
       -- It will skip any key that is an integer number, so negative indices or an
       -- array with holes will not return those either (so it returns slightly less than
       -- 'the inverse of `ipairs`').
       --
       -- This uses `pairs` under the hood, so any value that is iterable using `pairs`
       -- will work with this function.
       -- @tparam table t the table to iterate over
       -- @treturn key
       -- @treturn value
       -- @usage
       -- local t = {
       --   "hello",
       --   "world",
       --   hello = "hallo",
       --   world = "Welt",
       -- }
       --
       -- for k, v in utils.kpairs(t) do
       --   print("German: ", v)
       -- end
       --
       -- -- output;
       -- -- German: hallo
       -- -- German: Welt
*****0 function utils.kpairs(t)
         local index
         return function()
           local value
           while true do
*****0       index, value = next(t, index)
*****0       if type(index) ~= "number" or floor(index) ~= index then
               break
             end
           end
*****0     return index, value
         end
       end



       --- Error handling
       -- @section Error-handling

       --- assert that the given argument is in fact of the correct type.
       -- @param n argument index
       -- @param val the value
       -- @param tp the type
       -- @param verify an optional verification function
       -- @param msg an optional custom message
       -- @param lev optional stack position for trace, default 2
       -- @return the validated value
       -- @raise if `val` is not the correct type
       -- @usage
       -- local param1 = assert_arg(1,"hello",'table')  --> error: argument 1 expected a 'table', got a 'string'
       -- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')
       --      --> error: argument 4: '!@#$%^&*' not a directory
*****0 function utils.assert_arg (n,val,tp,verify,msg,lev)
   438     if type(val) ~= tp then
*****0         error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
           end
   439     if verify and not verify(val) then
*****0         error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
           end
   438     return val
       end

       --- creates an Enum or constants lookup table for improved error handling.
       -- This helps prevent magic strings in code by throwing errors for accessing
       -- non-existing values, and/or converting strings/identifiers to other values.
       --
       -- Calling on the object does the same, but returns a soft error; `nil + err`, if
       -- the call is successful (the key exists), it will return the value.
       --
       -- When calling with varargs or an array the values will be equal to the keys.
       -- The enum object is read-only.
       -- @tparam table|vararg ... the input for the Enum. If varargs or an array then the
       -- values in the Enum will be equal to the names (must be strings), if a hash-table
       -- then values remain (any type), and the keys must be strings.
       -- @return Enum object (read-only table/object)
       -- @usage -- Enum access at runtime
       -- local obj = {}
       -- obj.MOVEMENT = utils.enum("FORWARD", "REVERSE", "LEFT", "RIGHT")
       --
       -- if current_movement == obj.MOVEMENT.FORWARD then
       --   -- do something
       --
       -- elseif current_movement == obj.MOVEMENT.REVERES then
       --   -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error
       --   -- "'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')"
       --
       -- end
       -- @usage -- standardized error codes
       -- local obj = {
       --   ERR = utils.enum {
       --     NOT_FOUND = "the item was not found",
       --     OUT_OF_BOUNDS = "the index is outside the allowed range"
       --   },
       --
       --   some_method = function(self)
       --     return nil, self.ERR.OUT_OF_BOUNDS
       --   end,
       -- }
       --
       -- local result, err = obj:some_method()
       -- if not result then
       --   if err == obj.ERR.NOT_FOUND then
       --     -- check on error code, not magic strings
       --
       --   else
       --     -- return the error description, contained in the constant
       --     return nil, "error: "..err  -- "error: the index is outside the allowed range"
       --   end
       -- end
       -- @usage -- validating/converting user-input
       -- local color = "purple"
       -- local ansi_colors = utils.enum {
       --   black     = 30,
       --   red       = 31,
       --   green     = 32,
       -- }
       -- local color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum
       -- if not color_code then
       --   print("bad 'color', " .. err)
       --   -- "bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')"
       --   os.exit(1)
       -- end
*****0 function utils.enum(...)
*****0   local first = select(1, ...)
*****0   local enum = {}
         local lst

*****0   if type(first) ~= "table" then
           -- vararg with strings
*****0     lst = utils.pack(...)
*****0     for i, value in utils.npairs(lst) do
*****0       utils.assert_arg(i, value, "string")
*****0       enum[value] = value
           end

         else
           -- table/array with values
*****0     utils.assert_arg(1, first, "table")
*****0     lst = {}
           -- first add array part
*****0     for i, value in ipairs(first) do
*****0       if type(value) ~= "string" then
*****0         error(("expected 'string' but got '%s' at index %d"):format(type(value), i), 2)
             end
*****0       lst[i] = value
*****0       enum[value] = value
           end
           -- add key-ed part
*****0     for key, value in utils.kpairs(first) do
*****0       if type(key) ~= "string" then
*****0         error(("expected key to be 'string' but got '%s'"):format(type(key)), 2)
             end
*****0       if enum[key] then
*****0         error(("duplicate entry in array and hash part: '%s'"):format(key), 2)
             end
*****0       enum[key] = value
*****0       lst[#lst+1] = key
           end
         end

*****0   if not lst[1] then
*****0     error("expected at least 1 entry", 2)
         end

*****0   local valid = "(expected one of: '" .. concat(lst, "', '") .. "')"
*****0   setmetatable(enum, {
           __index = function(self, key)
*****0       error(("'%s' is not a valid value %s"):format(tostring(key), valid), 2)
           end,
           __newindex = function(self, key, value)
*****0       error("the Enum object is read-only", 2)
           end,
           __call = function(self, key)
*****0       if type(key) == "string" then
*****0         local v = rawget(self, key)
*****0         if v ~= nil then
*****0           return v
               end
             end
*****0       return nil, ("'%s' is not a valid value %s"):format(tostring(key), valid)
           end
         })

*****0   return enum
       end


       --- process a function argument.
       -- This is used throughout Penlight and defines what is meant by a function:
       -- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
       -- such as '>' or '#'. If a function factory has been registered for the type, it will
       -- be called to get the function.
       -- @param idx argument index
       -- @param f a function, operator string, or callable object
       -- @param msg optional error message
       -- @return a callable
       -- @raise if idx is not a number or if f is not callable
*****0 function utils.function_arg (idx,f,msg)
     2     utils.assert_arg(1,idx,'number')
     2     local tp = type(f)
     2     if tp == 'function' then return f end  -- no worries!
           -- ok, a string can correspond to an operator (like '==')
*****0     if tp == 'string' then
*****0         if not operators then operators = require 'pl.operator'.optable end
*****0         local fn = operators[f]
*****0         if fn then return fn end
*****0         local fn, err = utils.string_lambda(f)
*****0         if not fn then error(err..': '..f) end
*****0         return fn
*****0     elseif tp == 'table' or tp == 'userdata' then
*****0         local mt = getmetatable(f)
*****0         if not mt then error('not a callable object',2) end
*****0         local ff = _function_factories[mt]
*****0         if not ff then
*****0             if not mt.__call then error('not a callable object',2) end
*****0             return f
               else
*****0             return ff(f) -- we have a function factory for this type!
               end
           end
*****0     if not msg then msg = " must be callable" end
*****0     if idx > 0 then
*****0         error("argument "..idx..": "..msg,2)
           else
*****0         error(msg,2)
           end
       end


       --- assert the common case that the argument is a string.
       -- @param n argument index
       -- @param val a value that must be a string
       -- @return the validated value
       -- @raise val must be a string
       -- @usage
       -- local val = 42
       -- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'
*****0 function utils.assert_string (n, val)
   434     return utils.assert_arg(n,val,'string',nil,nil,3)
       end

       --- control the error strategy used by Penlight.
       -- This is a global setting that controls how `utils.raise` behaves:
       --
       -- - 'default': return `nil + error` (this is the default)
       -- - 'error': throw a Lua error
       -- - 'quit': exit the program
       --
       -- @param mode either 'default', 'quit'  or 'error'
       -- @see utils.raise
*****0 function utils.on_error (mode)
*****0     mode = tostring(mode)
*****0     if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
*****0       err_mode = mode
           else
             -- fail loudly
*****0       local err = "Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'"
*****0       if err_mode == 'default' then
*****0         error(err, 2)  -- even in 'default' mode fail loud in this case
             end
*****0       raise(err)
           end
       end

       --- used by Penlight functions to return errors. Its global behaviour is controlled
       -- by `utils.on_error`.
       -- To use this function you MUST use it in conjunction with `return`, since it might
       -- return `nil + error`.
       -- @param err the error string.
       -- @see utils.on_error
       -- @usage
       -- if some_condition then
       --   return utils.raise("some condition was not met")  -- MUST use 'return'!
       -- end
*****0 function utils.raise (err)
*****0     if err_mode == 'default' then
*****0         return nil, err
*****0     elseif err_mode == 'quit' then
*****0         return utils.quit(err)
           else
*****0         error(err, 2)
           end
       end
*****0 raise = utils.raise



       --- File handling
       -- @section files

       --- return the contents of a file as a string
       -- @param filename The file path
       -- @param is_bin open in binary mode
       -- @return file contents
*****0 function utils.readfile(filename,is_bin)
*****0     local mode = is_bin and 'b' or ''
*****0     utils.assert_string(1,filename)
*****0     local f,open_err = io.open(filename,'r'..mode)
*****0     if not f then return raise (open_err) end
*****0     local res,read_err = f:read('*a')
*****0     f:close()
*****0     if not res then
               -- Errors in io.open have "filename: " prefix,
               -- error in file:read don't, add it.
*****0         return raise (filename..": "..read_err)
           end
*****0     return res
       end

       --- write a string to a file
       -- @param filename The file path
       -- @param str The string
       -- @param is_bin open in binary mode
       -- @return true or nil
       -- @return error message
       -- @raise error if filename or str aren't strings
*****0 function utils.writefile(filename,str,is_bin)
*****0     local mode = is_bin and 'b' or ''
*****0     utils.assert_string(1,filename)
*****0     utils.assert_string(2,str)
*****0     local f,err = io.open(filename,'w'..mode)
*****0     if not f then return raise(err) end
*****0     local ok, write_err = f:write(str)
*****0     f:close()
*****0     if not ok then
               -- Errors in io.open have "filename: " prefix,
               -- error in file:write don't, add it.
*****0         return raise (filename..": "..write_err)
           end
*****0     return true
       end

       --- return the contents of a file as a list of lines
       -- @param filename The file path
       -- @return file contents as a table
       -- @raise error if filename is not a string
*****0 function utils.readlines(filename)
*****0     utils.assert_string(1,filename)
*****0     local f,err = io.open(filename,'r')
*****0     if not f then return raise(err) end
*****0     local res = {}
*****0     for line in f:lines() do
*****0         append(res,line)
           end
*****0     f:close()
*****0     return res
       end

       --- OS functions
       -- @section OS-functions

       --- execute a shell command and return the output.
       -- This function redirects the output to tempfiles and returns the content of those files.
       -- @param cmd a shell command
       -- @param bin boolean, if true, read output as binary file
       -- @return true if successful
       -- @return actual return code
       -- @return stdout output (string)
       -- @return errout output (string)
*****0 function utils.executeex(cmd, bin)
*****0     local outfile = os.tmpname()
*****0     local errfile = os.tmpname()

*****0     if is_windows and not outfile:find(':') then
*****0         outfile = os.getenv('TEMP')..outfile
*****0         errfile = os.getenv('TEMP')..errfile
           end
*****0     cmd = cmd .. " > " .. utils.quote_arg(outfile) .. " 2> " .. utils.quote_arg(errfile)

*****0     local success, retcode = utils.execute(cmd)
*****0     local outcontent = utils.readfile(outfile, bin)
*****0     local errcontent = utils.readfile(errfile, bin)
*****0     os.remove(outfile)
*****0     os.remove(errfile)
*****0     return success, retcode, (outcontent or ""), (errcontent or "")
       end

       --- Quote and escape an argument of a command.
       -- Quotes a single (or list of) argument(s) of a command to be passed
       -- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.
       -- @param argument (string or table/list) the argument to quote. If a list then
       -- all arguments in the list will be returned as a single string quoted.
       -- @return quoted and escaped argument.
       -- @usage
       -- local options = utils.quote_arg {
       --     "-lluacov",
       --     "-e",
       --     "utils = print(require('pl.utils')._VERSION",
       -- }
       -- -- returns: -lluacov -e 'utils = print(require('\''pl.utils'\'')._VERSION'
*****0 function utils.quote_arg(argument)
*****0     if type(argument) == "table" then
               -- encode an entire table
*****0         local r = {}
*****0         for i, arg in ipairs(argument) do
*****0             r[i] = utils.quote_arg(arg)
               end

*****0         return concat(r, " ")
           end
           -- only a single argument
*****0     if is_windows then
*****0         if argument == "" or argument:find('[ \f\t\v]') then
                   -- Need to quote the argument.
                   -- Quotes need to be escaped with backslashes;
                   -- additionally, backslashes before a quote, escaped or not,
                   -- need to be doubled.
                   -- See documentation for CommandLineToArgvW Windows function.
*****0             argument = '"' .. argument:gsub([[(\*)"]], [[%1%1\"]]):gsub([[\+$]], "%0%0") .. '"'
               end

               -- os.execute() uses system() C function, which on Windows passes command
               -- to cmd.exe. Escape its special characters.
*****0         return (argument:gsub('["^<>!|&%%]', "^%0"))
           else
*****0         if argument == "" or argument:find('[^a-zA-Z0-9_@%+=:,./-]') then
                   -- To quote arguments on posix-like systems use single quotes.
                   -- To represent an embedded single quote close quoted string ('),
                   -- add escaped quote (\'), open quoted string again (').
*****0             argument = "'" .. argument:gsub("'", [['\'']]) .. "'"
               end

*****0         return argument
           end
       end

       --- error out of this program gracefully.
       -- @param[opt] code The exit code, defaults to -`1` if omitted
       -- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)
       -- @param ... extra arguments for message's format'
       -- @see utils.fprintf
       -- @usage utils.quit(-1, "Error '%s' happened", "42")
       -- -- is equivalent to
       -- utils.quit("Error '%s' happened", "42")  --> Error '42' happened
*****0 function utils.quit(code, msg, ...)
*****0     if type(code) == 'string' then
*****0         utils.fprintf(io.stderr, code, msg, ...)
*****0         io.stderr:write('\n')
*****0         code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code
*****0     elseif msg then
*****0         utils.fprintf(io.stderr, msg, ...)
*****0         io.stderr:write('\n')
           end
*****0     os.exit(code, true)
       end


       --- String functions
       -- @section string-functions

       --- escape any Lua 'magic' characters in a string
       -- @param s The input string
*****0 function utils.escape(s)
     9     utils.assert_string(1,s)
     9     return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
       end

       --- split a string into a list of strings separated by a delimiter.
       -- @param s The input string
       -- @param re optional A Lua string pattern; defaults to '%s+'
       -- @param plain optional If truthy don't use Lua patterns
       -- @param n optional maximum number of elements (if there are more, the last will remain un-split)
       -- @return a list-like table
       -- @raise error if s is not a string
       -- @see splitv
*****0 function utils.split(s,re,plain,n)
*****0     utils.assert_string(1,s)
*****0     local i1,ls = 1,{}
*****0     if not re then re = '%s+' end
*****0     if re == '' then return {s} end
           while true do
*****0         local i2,i3 = find(s,re,i1,plain)
*****0         if not i2 then
*****0             local last = sub(s,i1)
*****0             if last ~= '' then append(ls,last) end
*****0             if #ls == 1 and ls[1] == '' then
*****0                 return {}
                   else
*****0                 return ls
                   end
               end
*****0         append(ls,sub(s,i1,i2-1))
*****0         if n and #ls == n then
*****0             ls[#ls] = sub(s,i1)
*****0             return ls
               end
*****0         i1 = i3+1
           end
       end

       --- split a string into a number of return values.
       -- Identical to `split` but returns multiple sub-strings instead of
       -- a single list of sub-strings.
       -- @param s the string
       -- @param re A Lua string pattern; defaults to '%s+'
       -- @param plain don't use Lua patterns
       -- @param n optional maximum number of splits
       -- @return n values
       -- @usage first,next = splitv('user=jane=doe','=', false, 2)
       -- assert(first == "user")
       -- assert(next == "jane=doe")
       -- @see split
*****0 function utils.splitv (s,re, plain, n)
*****0     return _unpack(utils.split(s,re, plain, n))
       end


       --- Functional
       -- @section functional


       --- 'memoize' a function (cache returned value for next call).
       -- This is useful if you have a function which is relatively expensive,
       -- but you don't know in advance what values will be required, so
       -- building a table upfront is wasteful/impossible.
       -- @param func a function that takes exactly one argument (which later serves as the cache key) and returns a single value
       -- @return a function taking one argument and returning a single value either from the cache or by running the original input function
*****0 function utils.memoize(func)
*****0     local cache = {}
           return function(k)
*****0         local res = cache[k]
*****0         if res == nil then
*****0             res = func(k)
*****0             cache[k] = res
               end
*****0         return res
           end
       end


       --- associate a function factory with a type.
       -- A function factory takes an object of the given type and
       -- returns a function for evaluating it
       -- @tab mt metatable
       -- @func fun a callable that returns a function
*****0 function utils.add_function_factory (mt,fun)
*****0     _function_factories[mt] = fun
       end

       local function _string_lambda(f)
*****0     if f:find '^|' or f:find '_' then
*****0         local args,body = f:match '|([^|]*)|(.+)'
*****0         if f:find '_' then
*****0             args = '_'
*****0             body = f
               else
*****0             if not args then return raise 'bad string lambda' end
               end
*****0         local fstr = 'return function('..args..') return '..body..' end'
*****0         local fn,err = utils.load(fstr)
*****0         if not fn then return raise(err) end
*****0         fn = fn()
*****0         return fn
           else
*****0         return raise 'not a string lambda'
           end
       end


       --- an anonymous function as a string. This string is either of the form
       -- '|args| expression' or is a function of one argument, '_'
       -- @param lf function as a string
       -- @return a function
       -- @function utils.string_lambda
       -- @usage
       -- string_lambda '|x|x+1' (2) == 3
       -- string_lambda '_+1' (2) == 3
*****0 utils.string_lambda = utils.memoize(_string_lambda)


       --- bind the first argument of the function to a value.
       -- @param fn a function of at least two values (may be an operator string)
       -- @param p a value
       -- @return a function such that f(x) is fn(p,x)
       -- @raise same as @{function_arg}
       -- @see func.bind1
       -- @usage local function f(msg, name)
       --   print(msg .. " " .. name)
       -- end
       --
       -- local hello = utils.bind1(f, "Hello")
       --
       -- print(hello("world"))     --> "Hello world"
       -- print(hello("sunshine"))  --> "Hello sunshine"
*****0 function utils.bind1 (fn,p)
*****0     fn = utils.function_arg(1,fn)
*****0     return function(...) return fn(p,...) end
       end


       --- bind the second argument of the function to a value.
       -- @param fn a function of at least two values (may be an operator string)
       -- @param p a value
       -- @return a function such that f(x) is fn(x,p)
       -- @raise same as @{function_arg}
       -- @usage local function f(a, b, c)
       --   print(a .. " " .. b .. " " .. c)
       -- end
       --
       -- local hello = utils.bind1(f, "world")
       --
       -- print(hello("Hello", "!"))  --> "Hello world !"
       -- print(hello("Bye", "?"))    --> "Bye world ?"
*****0 function utils.bind2 (fn,p)
*****0     fn = utils.function_arg(1,fn)
*****0     return function(x,...) return fn(x,p,...) end
       end




       --- Deprecation
       -- @section deprecation

       do
         -- the default implementation
         local deprecation_func = function(msg, trace)
*****0     if trace then
*****0       warn(msg, "\n", trace)  -- luacheck: ignore
           else
*****0       warn(msg)  -- luacheck: ignore
           end
         end

         --- Sets a deprecation warning function.
         -- An application can override this function to support proper output of
         -- deprecation warnings. The warnings can be generated from libraries or
         -- functions by calling `utils.raise_deprecation`. The default function
         -- will write to the 'warn' system (introduced in Lua 5.4, or the compatibility
         -- function from the `compat` module for earlier versions).
         --
         -- Note: only applications should set/change this function, libraries should not.
         -- @param func a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional.
         -- @see utils.raise_deprecation
         -- @usage
         -- -- write to the Nginx logs with OpenResty
         -- utils.set_deprecation_func(function(msg, trace)
         --   ngx.log(ngx.WARN, msg, (trace and (" " .. trace) or nil))
         -- end)
         --
         -- -- disable deprecation warnings
         -- utils.set_deprecation_func()
*****0   function utils.set_deprecation_func(func)
*****0     if func == nil then
*****0       deprecation_func = function() end
           else
*****0       utils.assert_arg(1, func, "function")
*****0       deprecation_func = func
           end
         end

         --- raises a deprecation warning.
         -- For options see the usage example below.
         --
         -- Note: the `opts.deprecated_after` field is the last version in which
         -- a feature or option was NOT YET deprecated! Because when writing the code it
         -- is quite often not known in what version the code will land. But the last
         -- released version is usually known.
         -- @param opts options table
         -- @see utils.set_deprecation_func
         -- @usage
         -- warn("@on")   -- enable Lua warnings, they are usually off by default
         --
         -- function stringx.islower(str)
         --   raise_deprecation {
         --     source = "Penlight " .. utils._VERSION,                   -- optional
         --     message = "function 'islower' was renamed to 'is_lower'", -- required
         --     version_removed = "2.0.0",                                -- optional
         --     deprecated_after = "1.2.3",                               -- optional
         --     no_trace = true,                                          -- optional
         --   }
         --   return stringx.is_lower(str)
         -- end
         -- -- output: "[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)"
*****0   function utils.raise_deprecation(opts)
*****0     utils.assert_arg(1, opts, "table")
*****0     if type(opts.message) ~= "string" then
*****0       error("field 'message' of the options table must be a string", 2)
           end
           local trace
*****0     if not opts.no_trace then
*****0       trace = debug.traceback("", 2):match("[\n%s]*(.-)$")
           end
           local msg
*****0     if opts.deprecated_after and opts.version_removed then
*****0       msg = (" (deprecated after %s, scheduled for removal in %s)"):format(
*****0         tostring(opts.deprecated_after), tostring(opts.version_removed))
*****0     elseif opts.deprecated_after then
*****0       msg = (" (deprecated after %s)"):format(tostring(opts.deprecated_after))
*****0     elseif opts.version_removed then
*****0       msg = (" (scheduled for removal in %s)"):format(tostring(opts.version_removed))
           else
*****0       msg = ""
           end

*****0     msg = opts.message .. msg

*****0     if opts.source then
*****0       msg = "[" .. opts.source .."] " .. msg
           else
*****0       if msg:sub(1,1) == "@" then
               -- in Lua 5.4 "@" prefixed messages are control messages to the warn system
*****0         error("message cannot start with '@'", 2)
             end
           end

*****0     deprecation_func(msg, trace)
         end

       end


*****0 return utils



==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/say/init.lua
==============================================================================
*****0 local unpack = table.unpack or unpack

*****0 local registry = { }
       local current_namespace
       local fallback_namespace

*****0 local s = {

         _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
         _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
         _VERSION     = "Say 1.3",

         set_namespace = function(self, namespace)
     1     current_namespace = namespace
     1     if not registry[current_namespace] then
*****0       registry[current_namespace] = {}
           end
         end,

         set_fallback = function(self, namespace)
*****0     fallback_namespace = namespace
*****0     if not registry[fallback_namespace] then
*****0       registry[fallback_namespace] = {}
           end
         end,

         set = function(self, key, value)
    19     registry[current_namespace][key] = value
         end
       }

*****0 local __meta = {
         __call = function(self, key, vars)
   156     if vars ~= nil and type(vars) ~= "table" then
*****0       error(("expected parameter table to be a table, got '%s'"):format(type(vars)), 2)
           end
   156     vars = vars or {}
   156     vars.n = math.max((vars.n or 0), #vars)

   156     local str = registry[current_namespace][key] or registry[fallback_namespace][key]

   156     if str == nil then
*****0       return nil
           end
   156     str = tostring(str)
   156     local strings = {}

   666     for i = 1, vars.n or #vars do
   510       table.insert(strings, tostring(vars[i]))
           end

   156     return #strings > 0 and str:format(unpack(strings)) or str
         end,

         __index = function(self, key)
*****0     return registry[key]
         end
       }

*****0 s:set_fallback('en')
*****0 s:set_namespace('en')

*****0 s._registry = registry

*****0 return setmetatable(s, __meta)

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/vusted/run.lua
==============================================================================
       return function()
         -- HACK: for wipe out "$@" arg buffer
*****0   vim.cmd("silent! %bwipeout!")

         -- for loading test target
*****0   vim.o.runtimepath = vim.fn.getcwd() .. "," .. vim.o.runtimepath

*****0   local argv = vim.fn.argv()
         ---@cast argv string[]

         -- NOTICE: replace global arg
*****0   arg = argv
*****0   vim.cmd("%argdelete")

*****0   if vim.tbl_contains(arg, "--version") then
*****0     local version = _VERSION:sub(5)
*****0     local package_version = vim.fn.system("luarocks --lua-version=" .. version .. " show vusted --mversion")
*****0     print(package_version)
*****0     os.exit(0)
         end

*****0   if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then
*****0     require("lldebugger").start()
         end

*****0   local runner = require("busted.runner")
*****0   local ok, result = pcall(runner, { standalone = false, output = "vusted.default" })

         -- NOTICE: place after calling busted.runner to use patched os.exit when using --coverage
     1   local exit = os.exit
     1   if os.getenv("VUSTED_DISABLE_EXIT") then
*****0     exit = function() end
*****0     require("busted.compatibility").exit = exit -- HACK
         end

     1   local code = 0
     1   if not ok then
*****0     print(result .. "\n")
*****0     code = 1
         end
     1   exit(code)
       end

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/init.lua
==============================================================================
     8 local Path = require('plenary.path')
     8 local os_sep = require('plenary.path').path.sep
     8 local notify = require('notify')

     8 local wdayToEngName = {
           [1] = 'Sunday',
           [2] = 'Monday',
           [3] = 'Tuesday',
           [4] = 'Wednesday',
           [5] = 'Thursday',
           [6] = 'Friday',
           [7] = 'Saturday',
       }

       local function save(obj)
   473     Path:new(obj.path):write(vim.fn.json_encode(obj.content), 'w')
       end

     8 local obj = {
           path = nil,
       }

     8 local defaultHoursPerWeekday = {
           Monday = 8,
           Tuesday = 8,
           Wednesday = 8,
           Thursday = 8,
           Friday = 8,
           Saturday = 0,
           Sunday = 0,
       }

     8 local weekdayNumberMap = {
           Sunday = 0,
           Monday = 1,
           Tuesday = 2,
           Wednesday = 3,
           Thursday = 4,
           Friday = 5,
           Saturday = 6,
       }

     8 local defaults = {
    16     path = vim.fn.stdpath('data') .. os_sep .. 'maorun-time.json',
     8     hoursPerWeekday = defaultHoursPerWeekday,
       }
     8 local config = defaults

       local function init(user_config)
   498     config = vim.tbl_deep_extend('force', defaults, user_config or {})
   249     if user_config.hoursPerWeekday ~= nil then
   206         config.hoursPerWeekday = user_config.hoursPerWeekday
           end
   249     obj.path = config.path
   249     local p = Path:new(obj.path)
   747     if not p:exists() then
    14         p:touch({ parents = true })
           end

   747     local data = Path:new(obj.path):read()
   249     if data ~= '' then
   129         obj.content = vim.json.decode(data)
           else
   120         obj.content = {}
           end
           -- Ensure hoursPerWeekday is initialized if not present (e.g. new file)
   249     if obj.content['hoursPerWeekday'] == nil then
   123         obj.content['hoursPerWeekday'] = config.hoursPerWeekday
           end

   249     if obj.content['data'] == nil then
   120         obj.content['data'] = {}
           end

   249     local year_str = os.date('%Y')
   249     local week_str = os.date('%W')
   249     local project_name = 'default_project' -- Hardcoded for now
   249     local file_name = 'default_file' -- Hardcoded for now

   249     if obj.content['data'][year_str] == nil then
   135         obj.content['data'][year_str] = {}
           end
   249     if obj.content['data'][year_str][week_str] == nil then
   135         obj.content['data'][year_str][week_str] = {}
           end
   249     if obj.content['data'][year_str][week_str][project_name] == nil then
   135         obj.content['data'][year_str][week_str][project_name] = {}
           end
   249     if obj.content['data'][year_str][week_str][project_name][file_name] == nil then
   135         obj.content['data'][year_str][week_str][project_name][file_name] = {
   135             weekdays = {}, -- Will store weekday -> {summary={}, items={...}}
                   -- The weekly summary (overhour) is not initialized here,
                   -- it will be handled by the calculate function.
   135         }
           end
   249     return obj
       end

       ---@param opts {weeknumber: string|osdate, year: string|osdate}|nil
       local function calculate(opts)
   184     opts = vim.tbl_deep_extend('keep', opts or {}, {
   125         year = os.date('%Y'),
   125         weeknumber = os.date('%W'),
    92     })

    92     local year_str = opts.year
    92     local week_str = opts.weeknumber

    92     if not obj.content['data'][year_str] or not obj.content['data'][year_str][week_str] then
               -- No data for this year/week, nothing to calculate
*****0         return
           end

    92     local current_week_data = obj.content['data'][year_str][week_str]

           -- Initialize week summary if it doesn't exist under current_week_data.summary
    92     if current_week_data.summary == nil then
    41         current_week_data.summary = {}
           end

    92     local prevWeekOverhour = 0
           -- Ensure year_str data exists before trying to access previous week
    92     if obj.content['data'][year_str] then
    92         local prev_week_number_str = string.format('%02d', tonumber(week_str) - 1)
    92         if obj.content['data'][year_str][prev_week_number_str] then
     2             local prev_week_data = obj.content['data'][year_str][prev_week_number_str]
     2             if prev_week_data and prev_week_data.summary and prev_week_data.summary.overhour then
     2                 prevWeekOverhour = prev_week_data.summary.overhour
                   end
               end
           end

    92     current_week_data.summary.overhour = prevWeekOverhour -- Initialize with previous week's carry-over
           -- local total_time_in_week = 0 -- Can be used if we want to store total logged time for the week explicitly

           -- Iterate over projects in the current week
   290     for project_name, project_data in pairs(current_week_data) do
   198         if project_name ~= 'summary' then -- Skip the summary table itself
                   -- Iterate over files in the current project
   216             for file_name, file_data in pairs(project_data) do
   110                 if file_data.weekdays then
                           -- Iterate over weekdays in the current file
   202                     for weekday_name, day_data in pairs(file_data.weekdays) do
    92                         local time_in_weekday = 0
    92                         if day_data.items then
   195                             for _, item_entry in pairs(day_data.items) do
   103                                 if item_entry.diffInHours ~= nil then
   100                                     time_in_weekday = time_in_weekday + item_entry.diffInHours
                                       end
                                   end
                               end

                               -- Update summary for this specific day under project -> file -> weekday
    92                         if day_data.summary == nil then
     1                             day_data.summary = {}
                               end
    92                         day_data.summary.diffInHours = time_in_weekday

    92                         local expected_hours = obj.content['hoursPerWeekday'][weekday_name] or 0
    92                         day_data.summary.overhour = time_in_weekday - expected_hours

                               -- Accumulate this day's overhour to the overall week summary
    92                         current_week_data.summary.overhour = current_week_data.summary.overhour
    92                             + day_data.summary.overhour
                               -- total_time_in_week = total_time_in_week + time_in_weekday -- Accumulate total logged time
                           end
                       end
                   end
               end
           end
           -- If you want to store the total logged time for the week in the summary:
           -- current_week_data.summary.totalLoggedTime = total_time_in_week
       end

       local function TimePause()
    10     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
    10     obj.content.paused = true
    10     save(obj)
    20     notify({
               'Timetracking paused',
    10     }, 'info', { title = 'TimeTracking - Pause' })
       end

       local function TimeResume()
     7     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
     7     obj.content.paused = false
     7     save(obj)
    14     notify({
               'Timetracking resumed',
     7     }, 'info', { title = 'TimeTracking - Resume' })
       end
       local function isPaused()
    72     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
    72     return obj.content.paused
       end

       ---@param opts? { weekday?: string|osdate, time?: number, project?: string, file?: string }
       local function TimeStart(opts)
     9     opts = opts or {}
     9     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
    18     if isPaused() then
*****0         return
           end

     9     local weekday = opts.weekday
     9     local time = opts.time
     9     local project = opts.project or 'default_project'
     9     local file = opts.file or 'default_file'

     9     if weekday == nil then
    15         local current_wday_numeric = os.date('*t', os.time()).wday
     5         weekday = wdayToEngName[current_wday_numeric]
           end
     9     if time == nil then
*****0         time = os.time()
           end

     9     local year_str = os.date('%Y', time) -- Use time for year_str for consistency if time is provided
     9     local week_str = os.date('%W', time) -- Use time for week_str for consistency

           -- Ensure path exists (init might have only created for current os.date)
     9     if obj.content['data'][year_str] == nil then
*****0         obj.content['data'][year_str] = {}
           end
     9     if obj.content['data'][year_str][week_str] == nil then
*****0         obj.content['data'][year_str][week_str] = {}
           end
     9     if obj.content['data'][year_str][week_str][project] == nil then
     1         obj.content['data'][year_str][week_str][project] = {}
           end
     9     if obj.content['data'][year_str][week_str][project][file] == nil then
     1         obj.content['data'][year_str][week_str][project][file] = { weekdays = {} }
           end
     9     if obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] == nil then
     8         obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] = {
     8             summary = {},
     8             items = {},
     8         }
           end

     9     local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
     9     local canStart = true
    10     for _, item in pairs(dayItem.items) do
     1         canStart = canStart and (item.startTime ~= nil and item.endTime ~= nil)
           end
     9     if canStart then
     8         local timeReadable = os.date('*t', time)
    16         table.insert(dayItem.items, {
     8             startTime = time,
     8             startReadable = string.format('%02d:%02d', timeReadable.hour, timeReadable.min),
               })
           end
     9     save(obj)
       end

       ---@param opts? { weekday?: string|osdate, time?: number, project?: string, file?: string }
       local function TimeStop(opts)
     7     opts = opts or {}
     7     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
    14     if isPaused() then
*****0         return
           end

     7     local weekday = opts.weekday
     7     local time = opts.time
     7     local project = opts.project or 'default_project'
     7     local file = opts.file or 'default_file'

     7     if weekday == nil then
    12         local current_wday_numeric = os.date('*t', os.time()).wday
     4         weekday = wdayToEngName[current_wday_numeric]
           end
     7     if time == nil then
*****0         time = os.time()
           end

     7     local year_str = os.date('%Y', time)
     7     local week_str = os.date('%W', time)

           -- Check if the path to the day's items exists in the new structure
     7     local dayItem_path_exists = obj.content['data'][year_str]
     7         and obj.content['data'][year_str][week_str]
     7         and obj.content['data'][year_str][week_str][project]
     7         and obj.content['data'][year_str][week_str][project][file]
     7         and obj.content['data'][year_str][week_str][project][file]['weekdays']
     7         and obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
     7         and obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday].items

     7     if dayItem_path_exists then
     6         local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
    12         for _, item in pairs(dayItem.items) do
     6             if item.endTime == nil then
     5                 item.endTime = time
     5                 local timeReadable = os.date('*t', time)
     5                 item.endReadable = string.format('%02d:%02d', timeReadable.hour, timeReadable.min)
     5                 item.diffInHours = os.difftime(item.endTime, item.startTime) / 60 / 60
                   end
               end
           end

     7     calculate({ year = year_str, weeknumber = week_str }) -- Calculate regardless of whether items were stopped, to update summaries.
     7     save(obj)

     7     local heute_text = 'N/A'
     7     if dayItem_path_exists then
               -- Accessing dayItem here is safe because dayItem_path_exists is true
     6         local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
     6         if dayItem.summary and dayItem.summary.overhour then
     6             heute_text = string.format('%.2f', dayItem.summary.overhour)
               end
           end

     7     local gesamt_text = 'N/A'
           -- Check path for overall week summary - this might be inaccurate until 'calculate' is updated
           if
     7         obj.content['data'][year_str]
     7         and obj.content['data'][year_str][week_str]
     7         and obj.content['data'][year_str][week_str].summary -- This summary is at week level
     7         and obj.content['data'][year_str][week_str].summary.overhour
           then
*****0         gesamt_text =
     7             string.format('%.2f', obj.content['data'][year_str][week_str].summary.overhour)
           end

    14     notify({
     7         'Heute: ' .. heute_text .. ' Stunden',
     7         'Gesamt: ' .. gesamt_text .. ' Stunden',
     7     }, 'info', { title = 'TimeTracking - Stop' })
       end

       -- calculate an average over the hoursPerWeekday
       local function calculateAverage()
     2     local sum = 0
     2     local count = 0
    14     for _, value in pairs(config.hoursPerWeekday) do
    12         sum = sum + value
    12         count = count + 1
           end
     2     return sum / count
       end

       local function saveTime(startTime, endTime, weekday, clearDay, project, file)
    42     project = project or 'default_project'
    42     file = file or 'default_file'
    42     local year_str = os.date('%Y', startTime) -- Use startTime to determine year/week
    42     local week_str = os.date('%W', startTime)

           -- Ensure path exists
    42     if obj.content['data'][year_str] == nil then
*****0         obj.content['data'][year_str] = {}
           end
    42     if obj.content['data'][year_str][week_str] == nil then
    15         obj.content['data'][year_str][week_str] = {}
           end
    42     if obj.content['data'][year_str][week_str][project] == nil then
    20         obj.content['data'][year_str][week_str][project] = {}
           end
    42     if obj.content['data'][year_str][week_str][project][file] == nil then
    21         obj.content['data'][year_str][week_str][project][file] = { weekdays = {} }
           end
    42     if obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] == nil then
    34         obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] = {
    34             summary = {},
    34             items = {},
    34         }
           end

           -- Handle clearDay logic - if true, existing items for the day are cleared.
           -- The original saveTime had a complex `clearDay` check in the first 'if'.
           -- Assuming if clearDay is passed as non-nil (and not 'nope'), it means we should clear.
           -- The addTime function passes clearDay as 'yes' or nil. 'nope' was for subtractTime.
           -- For simplicity here, if clearDay is true (boolean), we clear.
           -- The addTime/setTime logic will need to ensure clearDay is passed appropriately.
           -- The original logic for clearDay was: `if clearDay == nil and ... == nil then init day`.
           -- This seems more about init than clearing. The actual clearing is done by `clearDay()` func.
           -- Let's stick to the new structure path first. The `clearDay` param in `saveTime` might be redundant
           -- if `clearDay()` function is used before `addTime` in `setTime`.
           -- For now, `clearDay` in `saveTime` doesn't actively clear, it's more for path init.

    42     local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
    42     local timeReadableStart = os.date('*t', startTime)
    42     local item = {
    42         startTime = startTime,
    42         startReadable = string.format('%02d:%02d', timeReadableStart.hour, timeReadableStart.min),
    42         endTime = endTime,
           }
    42     local timeReadableEnd = os.date('*t', endTime)
    42     item.endReadable = string.format('%02d:%02d', timeReadableEnd.hour, timeReadableEnd.min)

    42     item.diffInHours = os.difftime(item.endTime, item.startTime) / 60 / 60

    42     table.insert(dayItem.items, item)
    42     calculate({ year = year_str, weeknumber = week_str })
    42     save(obj)

    84     notify({
    42         'Heute: ' .. string.format('%.2f', dayItem.summary.overhour) .. ' Stunden',
               'Gesamt: '
    42             .. string.format('%.2f', obj.content['data'][year_str][week_str].summary.overhour)
    42             .. ' Stunden',
    42     }, 'info', { title = 'TimeTracking - SaveTime' }) -- Changed title for clarity
       end

       -- adds time into the current week
       ---@param opts { time: number, weekday: string|osdate, clearDay?: string, project?: string, file?: string }
       local function addTime(opts)
    33     local time = opts.time
    33     local weekday = opts.weekday
    33     local clearDay = opts.clearDay -- This is 'yes' or nil from setTime/setIllDay, or 'nope'
    33     local project = opts.project or 'default_project'
    33     local file = opts.file or 'default_file'

           -- The original clearDay logic: if nil, it's 'nope'; if 'yes', it's nil for saveTime's old check.
           -- This is confusing. Let's simplify: `clearDay` in `addTime` means "should the day be cleared before adding".
           -- `setTime` calls `clearDay()` then `addTime()`. So `addTime` itself doesn't need to handle clearing.
           -- The `clearDay` parameter passed to `saveTime` from here will be the original `opts.clearDay` value.
           -- saveTime's responsibility is just to save, path creation is fine.

    33     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
           -- local years = obj.content['data'][os.date('%Y')] -- Not used with new structure that uses year_str, week_str from time
    33     if weekday == nil then
     1         local current_wday_numeric = os.date('*t', os.time()).wday
     1         weekday = wdayToEngName[current_wday_numeric]
           end

           -- local week = years[os.date('%W')] -- Not used with new structure
    42     local currentWeekdayNumeric = os.date('*t').wday - 1 -- Sunday=0, Monday=1, etc.
    33     local targetWeekdayNumeric = weekdayNumberMap[weekday]

           -- If targetWeekdayNumeric is nil, treat as a custom/new weekday
    33     if targetWeekdayNumeric == nil then
*****0         targetWeekdayNumeric = currentWeekdayNumeric
           end

    33     local diffDays = currentWeekdayNumeric - (targetWeekdayNumeric or currentWeekdayNumeric)
    33     if diffDays < 0 then
    20         diffDays = diffDays + 7
           end

           -- This block is now redundant because saveTime handles path creation.
           -- if obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] == nil then
           --     obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] = {
           --         items = {},
           --     }
           -- end

           -- Get current timestamp
    33     local current_ts = os.time()

           -- Subtract "diffDays" days from the current timestamp
    33     local target_day_ref_ts = current_ts - (diffDays * 24 * 3600)
    33     local target_day_t_info = os.date('*t', target_day_ref_ts)

           -- Extract hours/min/sec from "time"
    33     local minutes_float = (time - math.floor(time)) * 60
    33     local seconds_float = (minutes_float - math.floor(minutes_float)) * 60
    33     local hours_to_subtract = math.floor(time)
    33     local minutes_to_subtract = math.floor(minutes_float)
    33     local seconds_to_subtract = math.floor(seconds_float)

           -- Build a new osdateparam table with only supported fields
    33     local endTime_date_table = {
    33         year = target_day_t_info.year,
    33         month = target_day_t_info.month,
    33         day = target_day_t_info.day,
               hour = 23,
               min = 0,
               sec = 0,
    33         isdst = target_day_t_info.isdst,
           }

    33     local endTime_ts = os.time(endTime_date_table)

           -- Calculate startTime by subtracting the duration from endTime_ts
*****0     local startTime_ts = endTime_ts
    33         - (hours_to_subtract * 3600 + minutes_to_subtract * 60 + seconds_to_subtract)

    33     local startTime = startTime_ts
    33     local endTime = endTime_ts

    33     local paused = isPaused()
    33     if paused then
     1         TimeResume()
           end

           -- Pass project and file to saveTime
    33     saveTime(startTime, endTime, weekday, clearDay, project, file)

    33     if paused then
     1         TimePause()
           end
    33     return obj
       end

       -- subtracts time from the current week
       ---@param opts { time: number, weekday: string|osdate, project?: string, file?: string }
       local function subtractTime(opts)
     9     local time = opts.time
     9     local weekday = opts.weekday
     9     local project = opts.project or 'default_project'
     9     local file = opts.file or 'default_file'

     9     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
           -- local years = obj.content['data'][os.date('%Y')] -- Not used
     9     if weekday == nil then
     1         local current_wday_numeric = os.date('*t', os.time()).wday
     1         weekday = wdayToEngName[current_wday_numeric]
           end

           -- local week = years[os.date('%W')] -- Not used
    10     local currentWeekdayNumeric = os.date('*t').wday - 1 -- Sunday=0, Monday=1, etc.
     9     local targetWeekdayNumeric = weekdayNumberMap[weekday]

     9     if targetWeekdayNumeric == nil then
               -- Use notify if available, or print an error. Let's assume notify is available as it's used elsewhere.
*****0         if notify then
*****0             notify(
                       "Error: Weekday '"
*****0                     .. tostring(weekday)
*****0                     .. "' is not recognized in weekdayNumberMap.",
                       'error',
*****0                 { title = 'TimeTracking Error' }
                   )
               else
*****0             print(
                       "Error: Weekday '"
*****0                     .. tostring(weekday)
*****0                     .. "' is not recognized in weekdayNumberMap."
                   )
               end
*****0         return -- Stop execution if weekday is invalid
           end

     9     local diffDays = currentWeekdayNumeric - targetWeekdayNumeric
     9     if diffDays < 0 then
     6         diffDays = diffDays + 7
           end

           -- This block is now redundant because saveTime handles path creation.
           -- if obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] == nil then
           --     obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] = {
           --         items = {},
           --     }
           -- end

     9     local current_ts = os.time()

     9     local target_day_ref_ts = current_ts - (diffDays * 24 * 3600)
     9     local target_day_t_info = os.date('*t', target_day_ref_ts)

     9     local minutes_float = (time - math.floor(time)) * 60
     9     local seconds_float = (minutes_float - math.floor(minutes_float)) * 60
     9     local hours_to_subtract = math.floor(time)
     9     local minutes_to_subtract = math.floor(minutes_float)
     9     local seconds_to_subtract = math.floor(seconds_float)

     9     local endTime_date_table = {
     9         year = target_day_t_info.year,
     9         month = target_day_t_info.month,
     9         day = target_day_t_info.day,
               hour = 23,
               min = 0,
               sec = 0,
     9         isdst = target_day_t_info.isdst,
           }

     9     local startTime_ts = os.time(endTime_date_table)
*****0     local endTime_ts = startTime_ts
     9         - (hours_to_subtract * 3600 + minutes_to_subtract * 60 + seconds_to_subtract)

     9     local startTime = startTime_ts
     9     local endTime = endTime_ts

     9     local paused = isPaused()
     9     if paused then
     1         TimeResume()
           end

           -- Pass project, file. 'nope' for clearDay indicates not to clear.
     9     saveTime(startTime, endTime, weekday, 'nope', project, file)

     9     if paused then
     1         TimePause()
           end

     9     return obj
       end

       local function setIllDay(weekday)
     4     addTime({
     4         time = calculateAverage(),
     2         weekday = weekday,
               clearDay = 'yes',
           })
     2     return obj
       end

       local function clearDay(weekday, project, file)
     1     project = project or 'default_project'
     1     file = file or 'default_file'
     1     local year_str = os.date('%Y')
     1     local week_str = os.date('%W')

           if
     1         obj.content['data'][year_str]
     1         and obj.content['data'][year_str][week_str]
     1         and obj.content['data'][year_str][week_str][project]
     1         and obj.content['data'][year_str][week_str][project][file]
     1         and obj.content['data'][year_str][week_str][project][file]['weekdays']
     1         and obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
           then
               local dayItems =
     1             obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday].items
     1         if dayItems then
     3             for key, _ in pairs(dayItems) do
     2                 dayItems[key] = nil
                   end
               end
           end
     1     calculate({ year = year_str, weeknumber = week_str }) -- Recalculate for the current/affected week
     1     save(obj)
       end

       ---@param opts { time: number, weekday: string|osdate, project?: string, file?: string }
       local function setTime(opts)
     1     opts = opts or {}
     1     local project = opts.project or 'default_project'
     1     local file = opts.file or 'default_file'

     1     clearDay(opts.weekday, project, file) -- Pass project and file to clearDay
     2     addTime({
     1         time = opts.time,
     1         weekday = opts.weekday,
               clearDay = 'yes', -- 'yes' indicates to saveTime that items might have been cleared
     1         project = project,
     1         file = file,
           })
       end

     8 local timeGroup = vim.api.nvim_create_augroup('Maorun-Time', {})
    16 vim.api.nvim_create_autocmd({ 'FocusGained', 'BufEnter', 'VimEnter' }, {
     8     group = timeGroup,
           desc = 'Start Timetracking on VimEnter or BufEnter (if second vim was leaved)',
           callback = function()
*****0         TimeStart()
           end,
       })
    16 vim.api.nvim_create_autocmd('VimLeave', {
     8     group = timeGroup,
           desc = 'End Timetracking on VimLeave',
           callback = function()
*****0         TimeStop()
           end,
       })

       ---@param opts { hours?: boolean, weekday?: boolean, project?: boolean, file?: boolean }
       ---@param callback fun(hours:number, weekday: string, project:string, file:string) the function to call
       local function select(opts, callback)
*****0     opts = vim.tbl_deep_extend('force', { -- Use 'force' to ensure defaults are applied
               hours = true,
               weekday = true,
               project = true,
               file = true,
*****0     }, opts or {})

*****0     local selected_project = 'default_project'
*****0     local selected_file = 'default_file'

           local function get_file_input()
*****0         if opts.file then
*****0             vim.ui.input({ prompt = 'File name? (default: default_file) ' }, function(input)
*****0                 selected_file = (input and input ~= '') and input or 'default_file'
*****0                 get_weekday_selection() -- Proceed to weekday selection
                   end)
               else
*****0             get_weekday_selection() -- Skip file input
               end
           end

           local function get_project_input()
*****0         if opts.project then
*****0             vim.ui.input({ prompt = 'Project name? (default: default_project) ' }, function(input)
*****0                 selected_project = (input and input ~= '') and input or 'default_project'
*****0                 get_file_input() -- Proceed to file input
                   end)
               else
*****0             get_file_input() -- Skip project input
               end
           end

*****0     local selections = {}
*****0     local selectionNumbers = {}
*****0     for _, value in pairs(weekdayNumberMap) do
*****0         if not selectionNumbers[value] then
*****0             selectionNumbers[value] = 1
*****0             selections[#selections + 1] = _
               end
           end

           ---@param weekday string
           local function selectHours(weekday_param)
*****0         if opts.hours then
*****0             vim.ui.input({
                       prompt = 'How many hours? ',
                   }, function(input)
*****0                 local n = tonumber(input)
*****0                 if n == nil or input == nil or input == '' then
*****0                     return
                       end
*****0                 callback(n, weekday_param, selected_project, selected_file)
                   end)
               else
                   -- If hours are not required, pass a default or handle appropriately
*****0             callback(0, weekday_param, selected_project, selected_file) -- Assuming 0 hours if not prompted
               end
           end

           local function get_weekday_selection()
*****0         if opts.weekday then
*****0             if pcall(require, 'telescope') then
*****0                 local telescopeSelect = require('maorun.time.weekday_select')
*****0                 telescopeSelect({
                           prompt_title = 'Which day?',
                           list = selections,
                           action = function(selected_weekday)
*****0                         selectHours(selected_weekday)
                           end,
                       })
                   else
*****0                 vim.ui.select(selections, {
                           prompt = 'Which day? ',
                       }, function(selected_weekday)
*****0                     selectHours(selected_weekday)
                       end)
                   end
               else
                   -- If weekday is not required, pass a default or handle appropriately
                   -- This case might need clarification: what weekday to use if not selected?
                   -- For now, assuming it means no time entry if weekday selection is skipped.
                   -- Or, pass a default like current day, but callback expects a weekday.
                   -- Let's assume callback is only made if weekday is selected.
                   -- If opts.weekday is false, the chain stops or uses a predefined weekday.
                   -- For now, if weekday is false, we directly call callback with defaults (e.g. for project/file only ops)
                   -- callback(0, nil, selected_project, selected_file) -- This line is problematic if weekday is essential
                   -- Safest is to ensure weekday selection happens if callback needs it.
                   -- The current design implies `select` is primarily for operations that involve weekday and hours.
                   -- If only project/file are needed for some future op, `select` might need more changes.
                   -- Given the context of addTime, substractTime, setTime, weekday and hours are essential.
               end
           end

           -- Start the chain of inputs
*****0     get_project_input()
       end

     8 Time = {
           add = function()
*****0         select(
                   {},
                   function(hours, weekday, project, file) -- Add project and file to callback params
*****0                 addTime({ time = hours, weekday = weekday, project = project, file = file })
                   end
               )
           end,
     8     addTime = addTime,
           subtract = function()
*****0         select({}, function(hours, weekday, project, file) -- Add project and file
*****0             subtractTime({ time = hours, weekday = weekday, project = project, file = file })
               end)
           end,
     8     subtractTime = subtractTime,
     8     clearDay = clearDay, -- clearDay now takes project and file, but this public Time.clearDay would need them.
           -- This might require another vim.ui.select or direct args. For now, it's an issue.
           -- TODO: Adjust public Time.clearDay or make it internal / part of setTime only.
     8     TimePause = TimePause,
     8     TimeResume = TimeResume,
     8     TimeStop = TimeStop,
           set = function()
*****0         select({}, function(hours, weekday, project, file) -- Add project and file
*****0             setTime({ time = hours, weekday = weekday, project = project, file = file })
               end)
           end,
     8     setTime = setTime,
     8     setIllDay = setIllDay,
     8     setHoliday = setIllDay,
           calculate = function(opts) -- Accept opts
*****0         init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
*****0         calculate(opts)
*****0         save(obj)
*****0         return obj
           end,
     8 }

     8 return {
     8     setup = init,
     8     TimeStart = TimeStart,
     8     TimeStop = TimeStop,
     8     TimePause = TimePause,
     8     TimeResume = TimeResume,
     8     setIllDay = setIllDay,
     8     setHoliday = setIllDay,
     8     addTime = addTime,
     8     subtractTime = subtractTime,
     8     setTime = setTime,
     8     clearDay = clearDay,
     8     isPaused = isPaused,
           calculate = function(opts) -- Accept opts
    42         init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
    42         calculate(opts)
    42         save(obj)
    42         return obj
           end,

     8     weekdays = weekdayNumberMap,
     8 }

==============================================================================
test/add_time_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep()
     1 helper.notify_dep()

     2 local maorunTime = require('maorun.time')
     2 local Path = require('plenary.path')
     2 local os_module = require('os') -- Use a different name to avoid conflict with global os

       local tempPath

     2 before_each(function()
     5     tempPath = os_module.tmpname()
           -- Ensure the file is created for setup, similar to calculate_spec
     5     maorunTime.setup({ path = tempPath })
       end)

     2 after_each(function()
     5     os_module.remove(tempPath)
       end)

     3 describe('addTime', function()
     3     it('should add time to a specific weekday', function()
     1         maorunTime.setup({ path = tempPath })
     1         local targetWeekday = 'Monday'
     1         local hoursToAdd = 2
     1         maorunTime.addTime({ time = hoursToAdd, weekday = targetWeekday })
               local data =
     1             maorunTime.calculate({ year = os_module.date('%Y'), weeknumber = os_module.date('%W') })

     4         assert.are.same(
     1             hoursToAdd,
     1             data.content.data[os_module.date('%Y')][os_module.date('%W')]['default_project']['default_file'].weekdays[targetWeekday].items[1].diffInHours
     1         )
               local endTimeTs =
     1             data.content.data[os_module.date('%Y')][os_module.date('%W')]['default_project']['default_file'].weekdays[targetWeekday].items[1].endTime
     1         local endTimeInfo = os_module.date('*t', endTimeTs)
     4         assert.are.same(23, endTimeInfo.hour)
     4         assert.are.same(0, endTimeInfo.min)
     4         assert.are.same(0, endTimeInfo.sec)

               local startTimeTs =
     1             data.content.data[os_module.date('%Y')][os_module.date('%W')]['default_project']['default_file'].weekdays[targetWeekday].items[1].startTime
     4         assert.are.same(hoursToAdd * 3600, endTimeTs - startTimeTs)
           end)

     3     it('should handle floating point time addition', function()
     1         maorunTime.setup({ path = tempPath })
     1         local targetWeekday = 'Tuesday'
     1         local hoursToAdd = 2.5
     1         maorunTime.addTime({ time = hoursToAdd, weekday = targetWeekday })

               -- Calculate the year and week that addTime would have used
               -- NOTE: Using a fixed os.time() for consistent test runs might be better in real scenarios,
               -- but for now, this replicates the logic closely.
     1         local current_ts_for_test = os_module.time()
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
               -- Accessing the weekdays map from the maorunTime module itself
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[targetWeekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

     4         assert.are.same(
     1             hoursToAdd,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items[1].diffInHours
     1         )
               local endTimeTs =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items[1].endTime
     1         local endTimeInfo = os_module.date('*t', endTimeTs)
     4         assert.are.same(23, endTimeInfo.hour)
     4         assert.are.same(0, endTimeInfo.min)
     4         assert.are.same(0, endTimeInfo.sec)

               local startTimeTs =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items[1].startTime
               -- Using math.floor for comparison due to potential floating point inaccuracies with seconds
     6         assert.are.same(math.floor(hoursToAdd * 3600), math.floor(endTimeTs - startTimeTs))
           end)

     3     it('should add time to the current day if weekday is nil', function()
     1         maorunTime.setup({ path = tempPath })
     1         local hoursToAdd = 3
     1         local targetWeekday = os_module.date('%A') -- Get current weekday name

     1         maorunTime.addTime({ time = hoursToAdd })
               local data =
     1             maorunTime.calculate({ year = os_module.date('%Y'), weeknumber = os_module.date('%W') })

     4         assert.are.same(
     1             hoursToAdd,
     1             data.content.data[os_module.date('%Y')][os_module.date('%W')]['default_project']['default_file'].weekdays[targetWeekday].items[1].diffInHours
     1         )
               local endTimeTs =
     1             data.content.data[os_module.date('%Y')][os_module.date('%W')]['default_project']['default_file'].weekdays[targetWeekday].items[1].endTime
     1         local endTimeInfo = os_module.date('*t', endTimeTs)
     4         assert.are.same(23, endTimeInfo.hour)
     4         assert.are.same(0, endTimeInfo.min)
     4         assert.are.same(0, endTimeInfo.sec)

               local startTimeTs =
     1             data.content.data[os_module.date('%Y')][os_module.date('%W')]['default_project']['default_file'].weekdays[targetWeekday].items[1].startTime
     4         assert.are.same(hoursToAdd * 3600, endTimeTs - startTimeTs)
           end)

     3     it('should add time correctly when tracking is paused', function()
     1         maorunTime.setup({ path = tempPath })
     1         maorunTime.TimePause()
     4         assert.is_true(maorunTime.isPaused())

     1         local targetWeekday = 'Wednesday'
     1         local hoursToAdd = 4
     1         maorunTime.addTime({ time = hoursToAdd, weekday = targetWeekday })

               -- Calculate the year and week that addTime would have used
     1         local current_ts_for_test = os_module.time()
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[targetWeekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

     4         assert.are.same(
     1             hoursToAdd,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items[1].diffInHours
     1         )
               -- The problem description says "should resume and re-pause", implying isPaused should be true.
               -- However, addTime typically unpauses. Let's assume it should be unpaused after adding time.
               -- If the intention is that addTime itself re-pauses, the implementation of addTime or TimePause would need to reflect that.
               -- For now, asserting based on typical behavior of addTime unpausing.
               -- assert.is_false(maorunTime.isPaused())
               -- Update: Based on the subtask description "Assert maorunTime.isPaused() is true (should resume and re-pause)",
               -- we expect it to be true.
     4         assert.is_true(maorunTime.isPaused())
           end)

     3     it('should add to existing entries, not overwrite by default', function()
     1         maorunTime.setup({ path = tempPath })
     1         local targetWeekday = 'Thursday'
     1         local initialHours = 1
     1         local additionalHours = 2

     1         maorunTime.addTime({ time = initialHours, weekday = targetWeekday })
     1         maorunTime.addTime({ time = additionalHours, weekday = targetWeekday })

               -- Calculate the year and week that addTime would have used for targetWeekday
     1         local current_ts_for_test = os_module.time() -- Time reference for date calculations
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[targetWeekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

     4         assert.are.same(
     1             2,
     1             #data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items
               )
     4         assert.are.same(
     1             initialHours,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items[1].diffInHours
     1         )
     4         assert.are.same(
     1             additionalHours,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].items[2].diffInHours
     1         )
           end)
       end)

==============================================================================
test/calculate_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep()
     1 helper.notify_dep()

     2 local maorunTime = require('maorun.time')
     2 local os = require('os')
     2 local Path = require('plenary.path') -- Added for file manipulation
       local tempPath

     2 before_each(function()
     9     tempPath = os.tmpname()
       end)
     2 after_each(function()
     9     os.remove(tempPath)
       end)

     3 describe('calculate', function()
     3     it('should calculate correct', function()
     2         maorunTime.setup({
     1             path = tempPath,
               })
     1         local data = maorunTime.calculate()
               -- Check the nested structure for weekdays
               -- After setup and calculate on an empty file, the structure should include default project/file path
               -- and the weekdays table under it should be empty.
     1         local year_data = data.content.data[os.date('%Y')]
     1         local week_data = year_data and year_data[os.date('%W')]
     1         local project_data = week_data and week_data['default_project']
     1         local file_data = project_data and project_data['default_file']
     4         assert.are.same({}, file_data and file_data.weekdays or nil)

     1         local targetWeekday = 'Monday'
     1         maorunTime.addTime({ time = 2, weekday = targetWeekday })

     2         data = maorunTime.calculate()

     1         local year = os.date('%Y')
     1         local week = os.date('%W')

     4         assert.are.same(
     1             -6,
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[targetWeekday].summary.overhour,
     1             'Daily overhour for ' .. targetWeekday
               )
     4         assert.are.same(-6, data.content.data[year][week].summary.overhour, 'Weekly overhour') -- Week summary path is correct
     4         assert.are.same(
     1             2,
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[targetWeekday].summary.diffInHours
     1         )
     4         assert.are.same(
     1             -6,
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[targetWeekday].summary.overhour
     1         )
     4         assert.are.same(
     1             2,
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[targetWeekday].items[1].diffInHours
     1         )
           end)

     3     it('should calculate correctly with custom hoursPerWeekday', function()
     1         local customHours = {
                   Monday = 8,
                   Tuesday = 6,
                   Wednesday = 8,
                   Thursday = 8,
                   Friday = 4,
                   Saturday = 0,
                   Sunday = 0,
               }
     2         maorunTime.setup({
     1             path = tempPath,
     1             hoursPerWeekday = customHours,
               })

     1         local targetWeekday = 'Tuesday' -- Hardcode for predictability
               -- local currentYear = os.date('%Y') -- Will use expected_year_key
               -- local currentWeek = os.date('%W') -- Will use expected_week_key

     1         maorunTime.addTime({ time = 7, weekday = targetWeekday })

               -- Calculate the year and week that addTime would have used for targetWeekday
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[targetWeekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

               -- Assertions
     4         assert.are.same(
     1             7,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].summary.diffInHours
     1         )
     4         assert.are.same(
     1             1,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekday].summary.overhour
     1         )
     4         assert.are.same(1, data.content.data[expected_year_key][expected_week_key].summary.overhour) -- Week summary path
           end)

     3     it('should sum multiple entries for a single day', function()
     2         maorunTime.setup({
     1             path = tempPath, -- Default hoursPerWeekday (8 hours per day)
               })

     1         local targetWeekday = 'Monday' -- Hardcode for predictability
     1         local currentYear = os.date('%Y')
     1         local currentWeek = os.date('%W')

     1         maorunTime.addTime({ time = 2, weekday = targetWeekday })
     1         maorunTime.addTime({ time = 3, weekday = targetWeekday })

     1         local data = maorunTime.calculate()

               -- Assertions for targetWeekday
     4         assert.are.same(
     1             5,
     1             data.content.data[currentYear][currentWeek]['default_project']['default_file'].weekdays[targetWeekday].summary.diffInHours
     1         )
     4         assert.are.same(
     1             -3,
     1             data.content.data[currentYear][currentWeek]['default_project']['default_file'].weekdays[targetWeekday].summary.overhour
     1         )
               -- Assertion for total summary
     4         assert.are.same(-3, data.content.data[currentYear][currentWeek].summary.overhour) -- Week summary path
           end)

     3     it('should calculate correctly with entries on multiple days', function()
     2         maorunTime.setup({
     1             path = tempPath, -- Default hoursPerWeekday (8 hours per day)
               })

     1         local weekday1 = 'Wednesday' -- Changed from Monday
     1         local weekday2 = 'Thursday' -- Changed from Tuesday
               -- local currentYear = os.date('%Y') -- Will use expected_year_key
               -- local currentWeek = os.date('%W') -- Will use expected_week_key

     1         maorunTime.addTime({ time = 7, weekday = weekday1 }) -- Wednesday
     1         maorunTime.addTime({ time = 9, weekday = weekday2 }) -- Thursday

               -- Calculate the year and week that addTime would have used.
               -- Both weekday1 and weekday2, due to addTime's logic, will fall into the same week.
               -- So, we can use weekday1 as the reference.
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday1]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

               -- Assertions for weekday1 (Monday)
     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday1],
                   'Data for weekday1 should exist'
     1         )
     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday1].summary,
                   'Summary for weekday1 should exist'
     1         )
     4         assert.are.same(
     1             7,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday1].summary.diffInHours
     1         )
     4         assert.are.same(
     1             -1,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday1].summary.overhour
     1         )

               -- Assertions for weekday2 (Tuesday)
     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday2],
                   'Data for weekday2 should exist'
     1         )
     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday2].summary,
                   'Summary for weekday2 should exist'
     1         )
     4         assert.are.same(
     1             9,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday2].summary.diffInHours
     1         )
     4         assert.are.same(
     1             1,
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday2].summary.overhour
     1         )

               -- Assertion for total summary
     4         assert.are.same(0, data.content.data[expected_year_key][expected_week_key].summary.overhour) -- Week summary path
           end)

     3     it('should incorporate prevWeekOverhour into current week calculation', function()
     1         maorunTime.setup({ path = tempPath })
     3         local initialContentJson = Path:new(tempPath):read()
     1         if initialContentJson == '' then
     2             print(
                       "Warning (prevWeekOverhour test): tempPath file was empty after setup. Using '{}'."
     1             )
     1             initialContentJson = '{}'
               end
     2         local initialContent = vim.json.decode(initialContentJson)

     1         local currentYear = os.date('%Y')
     2         local currentWeekNum = tonumber(os.date('%W'))
     1         local currentWeekString = os.date('%W')

     1         if currentWeekNum <= 1 then
*****0             print(
                       "Skipping 'prevWeekOverhour' test as current week is "
*****0                     .. currentWeekString
*****0                     .. ' in '
*****0                     .. currentYear
*****0                     .. '.'
                   )
*****0             return -- Skip the rest of this test
               end

     2         local prevWeekString = string.format('%02d', currentWeekNum - 1)
     1         local prevWeekOverhourValue = 5

               -- Prepare data for the previous week and write it to the file
     2         local fileData = vim.deepcopy(initialContent) -- Start with what setup wrote to preserve hoursConf etc.
     1         if not fileData.data then
     1             fileData.data = {}
               end
     1         if not fileData.data[currentYear] then
     1             fileData.data[currentYear] = {}
               end

     1         fileData.data[currentYear][prevWeekString] = {
     1             summary = { overhour = prevWeekOverhourValue },
                   -- 'weekdays' is not strictly needed here for 'calculate' to read prevWeekOverhour
     1         }

               -- Ensure current week structure for default project/file exists for addTime to modify.
               -- addTime calls saveTime which initializes the project/file/weekday path.
               -- The week summary is handled by calculate.
     1         if not fileData.data[currentYear][currentWeekString] then
     1             fileData.data[currentYear][currentWeekString] = {
                       -- summary will be created by calculate if it doesn't exist
     1                 ['default_project'] = {
     1                     ['default_file'] = {
     1                         weekdays = {},
     1                     },
     1                 },
     1             }
*****0         elseif not fileData.data[currentYear][currentWeekString]['default_project'] then
*****0             fileData.data[currentYear][currentWeekString]['default_project'] = {
*****0                 ['default_file'] = {
                           weekdays = {},
                       },
                   }
*****0         elseif
*****0             not fileData.data[currentYear][currentWeekString]['default_project']['default_file']
               then
*****0             fileData.data[currentYear][currentWeekString]['default_project']['default_file'] =
*****0                 { weekdays = {} }
               end

               -- Ensure 'paused' key exists, copying from initialContent or defaulting.
     1         if initialContent.paused == nil then
     1             fileData.paused = false -- Default if not in initialContent
               else
*****0             fileData.paused = initialContent.paused
               end

     5         Path:new(tempPath):write(vim.fn.json_encode(fileData), 'w')

     1         local dayToLog = 'Monday' -- Default hours for Monday is 8
     1         maorunTime.addTime({ time = 6, weekday = dayToLog }) -- This logs 6 hours -> -2 for the day

     1         local data = maorunTime.calculate() -- This uses os.date() for year/week

     1         local yearFromOS = os.date('%Y')
     1         local weekFromOS = os.date('%W')

     4         assert.are.same(
     1             -2,
     1             data.content.data[yearFromOS][weekFromOS]['default_project']['default_file'].weekdays[dayToLog].summary.overhour
     1         )
     4         assert.are.same(
     1             prevWeekOverhourValue - 2, -- 5 - 2 = 3
     1             data.content.data[yearFromOS][weekFromOS].summary.overhour
     1         )
           end)

     3     it('should calculate correctly for a specific year and weeknumber option', function()
     1         maorunTime.setup({ path = tempPath }) -- Initialize to create the file and get default configs
     3         local initialContentJson = Path:new(tempPath):read()
     1         if initialContentJson == '' then
     2             print(
                       "Warning (specific year/week test): tempPath file was empty after setup. Using '{}'."
     1             )
     1             initialContentJson = '{}'
               end
     2         local fileContent = vim.json.decode(initialContentJson) -- Get hoursPerWeekday, paused status

     1         local testYear = '2022'
     1         local testWeek = '30' -- Corresponds to July 25-31, 2022. Wednesday is July 27th.
     1         local testWeekday = 'Wednesday'
     1         local loggedHours = 10

               -- Ensure hoursPerWeekday from setup is used. Default to 8 if somehow not found.
     1         local hoursForTestWeekday = 8
     1         if fileContent.hoursPerWeekday and fileContent.hoursPerWeekday[testWeekday] then
*****0             hoursForTestWeekday = fileContent.hoursPerWeekday[testWeekday]
               end
     1         local expectedDailyOvertime = loggedHours - hoursForTestWeekday

               -- Prepare data for the specific year and week
     1         if not fileContent.data then
     1             fileContent.data = {}
               end
     1         if not fileContent.data[testYear] then
     1             fileContent.data[testYear] = {}
               end

     1         fileContent.data[testYear][testWeek] = {
                   -- summary will be created by calculate
     1             ['default_project'] = {
     1                 ['default_file'] = {
     1                     weekdays = {
     1                         [testWeekday] = {
                                   -- summary for weekday will be created by calculate
     1                             items = {
                                       {
     1                                     startTime = os.time({
                                               year = 2022,
                                               month = 7,
                                               day = 27,
                                               hour = 9,
                                               min = 0,
                                               sec = 0,
     1                                     }),
     1                                     endTime = os.time({
                                               year = 2022,
                                               month = 7,
                                               day = 27,
                                               hour = 9,
                                               min = 0,
                                               sec = 0,
                                           })
     1                                         + loggedHours * 3600,
     1                                     diffInHours = loggedHours,
     1                                 },
     1                             },
     1                         },
     1                     },
     1                 },
     1             },
     1         }
     5         Path:new(tempPath):write(vim.fn.json_encode(fileContent), 'w')

               -- Call calculate with options for the specific year and week
     1         local data = maorunTime.calculate({ year = testYear, weeknumber = testWeek })

               -- Assertions for the specific year and week data
     3         assert.is_not_nil(data.content.data, 'data.content.data should exist')
     3         assert.is_not_nil(
     1             data.content.data[testYear],
     1             'Data for year ' .. testYear .. ' should exist'
               )
     1         local weekData = data.content.data[testYear][testWeek]
     3         assert.is_not_nil(
     1             weekData,
     1             'Data for ' .. testYear .. ' week ' .. testWeek .. ' should exist'
               )

     3         assert.is_not_nil(
     1             weekData['default_project']['default_file'].weekdays,
     1             'weekData.weekdays should exist for ' .. testYear .. ' week ' .. testWeek -- Check project/file path
               )
     1         local weekdayData = weekData['default_project']['default_file'].weekdays[testWeekday]
     3         assert.is_not_nil(
     1             weekdayData,
                   'Data for '
     1                 .. testWeekday
     1                 .. ' in '
     1                 .. testYear
     1                 .. ' week '
     1                 .. testWeek
     1                 .. ' should exist'
               )

     4         assert.are.same(
     1             loggedHours,
     1             weekdayData.summary.diffInHours,
     1             'Logged hours for ' .. testWeekday
               )
     4         assert.are.same(
     1             expectedDailyOvertime,
     1             weekdayData.summary.overhour,
     1             'Overtime for ' .. testWeekday
               )
     4         assert.are.same(expectedDailyOvertime, weekData.summary.overhour, 'Total weekly overtime')
           end)

     3     it('should return zero totals for a week with no logged time', function()
     1         maorunTime.setup({ path = tempPath }) -- Basic setup

     1         local currentYear = os.date('%Y')
     1         local currentWeek = os.date('%W')

               -- No time is added. Call calculate directly.
     1         local data = maorunTime.calculate() -- Uses current year/week by default

               -- Assertions
     1         local weekData = data.content.data[currentYear][currentWeek]
     3         assert.is_not_nil(weekData, 'Week data should exist even if no time logged')
     3         assert.is_not_nil(weekData.summary, 'Week summary should exist')

     1         local projectData = weekData['default_project']
     3         assert.is_not_nil(projectData, 'Default project data should exist')
     1         local fileData = projectData['default_file']
     3         assert.is_not_nil(fileData, 'Default file data should exist')
     3         assert.is_not_nil(fileData.weekdays, 'Weekdays table should exist in default project/file')

     4         assert.are.same(
     1             0,
     1             weekData.summary.overhour, -- Week summary path
                   'Weekly overhour should be 0 for an empty week with no prior history'
     1         )

     6         assert.are.same(0, vim.tbl_count(fileData.weekdays), 'Weekdays table should be empty')
           end)

     3     it('should treat all logged time as overtime if weekday configured for zero hours', function()
     1         local targetWeekday = 'Saturday' -- A day often configured for 0 hours
     1         local loggedHours = 2

     1         local customHours = {
                   Monday = 8,
                   Tuesday = 8,
                   Wednesday = 8,
                   Thursday = 8,
                   Friday = 8,
                   Saturday = 0, -- Target for this test
                   Sunday = 0,
               }

     2         maorunTime.setup({
     1             path = tempPath,
     1             hoursPerWeekday = customHours,
               })

               -- local currentYear = os.date('%Y') -- Will use expected_year_key
               -- local currentWeek = os.date('%W') -- Will use expected_week_key

               -- Add time to the target weekday
     1         maorunTime.addTime({ time = loggedHours, weekday = targetWeekday })

               -- Calculate the year and week that addTime would have used for targetWeekday
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[targetWeekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

               -- Assertions
     1         local weekData = data.content.data[expected_year_key][expected_week_key]
     3         assert.is_not_nil(weekData, 'Week data should exist')

     1         local weekdayData = weekData['default_project']['default_file'].weekdays[targetWeekday]
     3         assert.is_not_nil(weekdayData, 'Data for ' .. targetWeekday .. ' should exist')
     3         assert.is_not_nil(weekdayData.summary, 'Summary for ' .. targetWeekday .. ' should exist')

     4         assert.are.same(
     1             loggedHours,
     1             weekdayData.summary.diffInHours,
     1             'Logged hours for ' .. targetWeekday
               )
               -- Expected overtime is loggedHours - 0 = loggedHours
     4         assert.are.same(
     1             loggedHours,
     1             weekdayData.summary.overhour,
     1             'Overtime for ' .. targetWeekday .. ' (configured for 0 hours)'
               )

               -- Assuming no other entries and no prevWeekOverhour
     4         assert.are.same(
     1             loggedHours,
     1             weekData.summary.overhour, -- Week summary path
     1             'Weekly overhour should reflect the ' .. targetWeekday .. ' overtime'
               )
           end)
       end)

     3 describe('setIllDay', function()
     3     it('should add the average time on a specific weekday', function()
     2         maorunTime.setup({
     1             path = tempPath,
               })

     1         local targetWeekdayForAvg = 'Monday'
     1         maorunTime.setIllDay(targetWeekdayForAvg) -- Uses default project/file

     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[targetWeekdayForAvg]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
*****0             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)
     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })
     1         local expected_avg = 40 / 7
               local actual_avg =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetWeekdayForAvg].items[1].diffInHours
     2         assert(
     2             math.abs(expected_avg - actual_avg) < 0.001,
     3             string.format(
     1                 'Average hours for default config on %s. Expected close to %s, got %s',
     1                 targetWeekdayForAvg,
     1                 expected_avg,
                       actual_avg
     1             )
               )

     2         maorunTime.setup({
     1             path = tempPath,
     1             hoursPerWeekday = {
                       Monday = 8,
                       Tuesday = 8,
                       Wednesday = 8,
                       Thursday = 7,
                       Friday = 5, -- Sum = 36, Count = 5, Avg = 7.2
     1             },
               })

     1         local targetCustomWeekday = 'Friday' -- Using Friday as it has a unique value (5) in this custom map
     1         maorunTime.setIllDay(targetCustomWeekday) -- Uses default project/file

               -- Recalculate expected year/week for targetCustomWeekday
     1         current_ts_for_test = os.time()
     1         currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         targetWeekdayNumeric_for_test = maorunTime.weekdays[targetCustomWeekday]
     1         diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)
     1         expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         expected_week_key = os.date('%W', target_day_ref_ts_for_test)

     2         data = maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })
     4         assert.are.same(
     1             7.2, -- This average ( (8+8+8+7+5) / 5 = 36/5 = 7.2 ) should still be correct
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[targetCustomWeekday].items[1].diffInHours
     1         )
           end)
       end)

==============================================================================
test/helper.lua
==============================================================================
       local function join_paths(...)
    28     local result = table.concat({ ... }, '/')
    28     return result
       end

       local function test_dir()
    15     local data_path = vim.fn.stdpath('data')
    14     local package_root = join_paths(data_path, 'test')
    14     return package_root
       end

       local function notify_dep()
     7     local package_root = test_dir()
     7     local lspconfig_path = join_paths(package_root, 'notify')
    14     vim.opt.runtimepath:append(lspconfig_path)
    14     if vim.fn.isdirectory(lspconfig_path) ~= 1 then
     2         vim.fn.system({
                   'git',
                   'clone',
                   'https://github.com/rcarriga/nvim-notify',
     1             lspconfig_path,
               })
           end
       end

       local function plenary_dep()
     7     local package_root = test_dir()
     7     local lspconfig_path = join_paths(package_root, 'plenary')
    14     vim.opt.runtimepath:append(lspconfig_path)
    15     if vim.fn.isdirectory(lspconfig_path) ~= 1 then
     2         vim.fn.system({
                   'git',
                   'clone',
                   'https://github.com/nvim-lua/plenary.nvim',
     1             lspconfig_path,
               })
           end
       end

     7 return {
     7     plenary_dep = plenary_dep,
     7     notify_dep = notify_dep,
     7 }

==============================================================================
test/plugin_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep()
     1 helper.notify_dep()

     2 local maorunTime = require('maorun.time')
     2 local os = require('os')
       local tempPath

     1 local wdayToEngName = {
           [1] = 'Sunday',
           [2] = 'Monday',
           [3] = 'Tuesday',
           [4] = 'Wednesday',
           [5] = 'Thursday',
           [6] = 'Friday',
           [7] = 'Saturday',
       }

     2 before_each(function()
     8     tempPath = os.tmpname()
       end)
     2 after_each(function()
     8     os.remove(tempPath)
       end)

     3 describe('init plugin', function()
     3     it('should have the path saved', function()
     2         local data = maorunTime.setup({
     1             path = tempPath,
     1         }).path
     4         assert.are.same(tempPath, data)
           end)

     3     it('should have default hoursPerWeekday', function()
     2         local data = maorunTime.setup({
     1             path = tempPath,
     1         }).content
     1         local expectedHours = {
                   Monday = 8,
                   Tuesday = 8,
                   Wednesday = 8,
                   Thursday = 8,
                   Friday = 8,
                   Saturday = 0,
                   Sunday = 0,
               }
     4         assert.are.same(expectedHours, data.hoursPerWeekday)
           end)

     3     it('should overwrite default hourPerWeekday', function()
     2         local data = maorunTime.setup({
     1             path = tempPath,
     1             hoursPerWeekday = {
                       Montag = 7,

                       Wednesday = 6,
     1             },
     1         }).content

     5         assert.are.same({
                   Montag = 7,

                   Wednesday = 6,
     1         }, data.hoursPerWeekday)
           end)

     3     it('should initialize initial date', function()
     2         local data = maorunTime.setup({
     1             path = tempPath,
     1         }).content
               -- Updated expected structure for init
     5         assert.are.same({
     1             [os.date('%Y')] = {
     1                 [os.date('%W')] = {
     1                     ['default_project'] = {
     1                         ['default_file'] = {
     1                             weekdays = {},
     1                         },
     1                     },
                           -- Week summary is not created by init directly anymore, but by calculate
     1                 },
     1             },
     1         }, data.data)
           end)
       end)

     3 it('should add/subtract time to a specific day', function()
           -- local data_obj = maorunTime.setup({ path = tempPath }) -- Get the full object for easier access
           -- For this test, maorunTime functions return the main 'obj', so .content is needed.
     1     maorunTime.setup({ path = tempPath })

     1     local current_wday_numeric = os.date('*t', os.time()).wday
     1     local current_weekday = wdayToEngName[current_wday_numeric] -- Standardized English name
     1     local current_wday_numeric = os.date('*t', os.time()).wday
     1     local current_weekday = wdayToEngName[current_wday_numeric] -- Standardized English name

     2     local data = maorunTime.addTime({
               time = 2,
     1         weekday = current_weekday,
           })

     1     local year = os.date('%Y')
     1     local weekNum = os.date('%W')
     1     local year = os.date('%Y')
     1     local weekNum = os.date('%W')
           -- Access the data through the new structure for assertions
     1     local week_content_path = data.content.data[year][weekNum]['default_project']['default_file']
     1     local week_summary_path = data.content.data[year][weekNum].summary -- Week summary is still at week level

     1     local configured_hours_day = data.content.hoursPerWeekday[current_weekday]

     1     local expected_daily_overhour_1st_add = 2 - configured_hours_day
     4     assert.are.same(
     1         expected_daily_overhour_1st_add,
     1         week_content_path.weekdays[current_weekday].summary.overhour,
     1         'Daily overhour for ' .. current_weekday .. ' after 1st add'
           )
     3     assert.is_not_nil(
     1         week_summary_path,
               'Week summary should exist after calculate (called by addTime via saveTime)'
     1     )
     1     if week_summary_path then -- Guard against nil if calculate didn't run or create it
     4         assert.are.same(
     1             expected_daily_overhour_1st_add,
     1             week_summary_path.overhour,
                   'Weekly overhour after 1st add'
     1         )
           end

     2     data = maorunTime.addTime({
               time = 2, -- Current test adds 2, not 3 as per original instruction example
     1         weekday = current_weekday,
     1     })
           -- Re-access paths as 'data' object might be new
     1     week_content_path = data.content.data[year][weekNum]['default_project']['default_file']
     1     week_summary_path = data.content.data[year][weekNum].summary

     1     local total_logged_hours_after_2nd_add = 4 -- (2 from first add + 2 from second)
     1     local expected_daily_overhour_2nd_add = total_logged_hours_after_2nd_add - configured_hours_day
     4     assert.are.same(
     1         expected_daily_overhour_2nd_add,
     1         week_content_path.weekdays[current_weekday].summary.overhour,
     1         'Daily overhour for ' .. current_weekday .. ' after 2nd add'
           )
     1     if week_summary_path then
     4         assert.are.same(
     1             expected_daily_overhour_2nd_add,
     1             week_summary_path.overhour,
                   'Weekly overhour after 2nd add'
     1         )
           end

     2     data = maorunTime.subtractTime({ time = 2, weekday = current_weekday })
     1     week_content_path = data.content.data[year][weekNum]['default_project']['default_file']
     1     week_summary_path = data.content.data[year][weekNum].summary

     1     local final_logged_hours_after_subtract = 2 -- (4 - 2)
*****0     local expected_daily_overhour_after_subtract = final_logged_hours_after_subtract
     1         - configured_hours_day
     4     assert.are.same(
     1         expected_daily_overhour_after_subtract,
     1         week_content_path.weekdays[current_weekday].summary.overhour,
     1         'Daily overhour for ' .. current_weekday .. ' after subtract'
           )
     1     if week_summary_path then
     4         assert.are.same(
     1             expected_daily_overhour_after_subtract,
     1             week_summary_path.overhour,
                   'Weekly overhour after subtract'
     1         )
           end
       end)

     3 describe('pause / resume time-tracking', function()
     3     it('should pause time tracking', function()
     2         maorunTime.setup({
     1             path = tempPath,
               })

     1         maorunTime.TimePause()

     4         assert.is_true(maorunTime.isPaused())
           end)
     3     it('should resume time tracking', function()
     2         maorunTime.setup({
     1             path = tempPath,
               })

     1         maorunTime.TimePause()

     1         maorunTime.TimeResume()

     4         assert.is_false(maorunTime.isPaused())
           end)
       end)

     3 it('should init weekdayNumberMap', function()
     2     maorunTime.setup({
     1         path = tempPath,
           })
     3     assert.same(maorunTime.weekdays, {
               Sunday = 0,
               Monday = 1,
               Tuesday = 2,
               Wednesday = 3,
               Thursday = 4,
               Friday = 5,
               Saturday = 6,
           })
       end)

==============================================================================
test/project_file_tracking_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep() -- Ensure plenary is cloned/available
     1 helper.notify_dep() -- Might as well ensure notify is also there, like other specs

     2 local time_init_module = require('maorun.time.init')
     2 local fs = require('plenary.path') -- This should now work if plenary_dep sets up paths or if LUA_PATH is correct
     2 local inspect = require('inspect') -- For debugging test failures

     3 describe('Project and File Tracking Functionality', function()
           -- Simpler temp path definition
     1     local test_json_filename = 'test_project_file_maorun_time.json'
     1     local test_json_path = '/tmp/' .. test_json_filename -- Using /tmp for simplicity
           local original_os_date
           local time_data_obj -- To access internal state for assertions

           local function safe_delete_test_file()
    36         if fs:new(test_json_path):exists() then
    14             os.remove(test_json_path)
               end
           end

           -- Fixed date: Monday, 2023-10-16, Week 42
     1     local mock_date_params = {
               year = '2023',
               week = '42',
               weekday_name = 'Monday',
               wday_numeric = 2, -- Sunday=1, Monday=2
               day_of_month = 16,
               month_num = 10,
               hour = 10,
               min = 0,
               sec = 0,
           }

           local function get_mock_time(offset_seconds)
    14         offset_seconds = offset_seconds or 0
    42         return os.time({
    28             year = tonumber(mock_date_params.year),
    14             month = mock_date_params.month_num,
    14             day = mock_date_params.day_of_month,
    14             hour = mock_date_params.hour,
    14             min = mock_date_params.min,
    14             sec = mock_date_params.sec,
    14         }) + offset_seconds
           end

     2     setup(function()
               -- No need to create /tmp/, it should exist
     1         safe_delete_test_file() -- Clean before setup too, just in case
     2         original_os_date = os.date
     1         os.date = function(format, time_val)
   202             if format == '%Y' then
    79                 return mock_date_params.year
                   end
   123             if format == '%W' then
    79                 return mock_date_params.week
                   end
    44             if format == '%A' then
*****0                 return mock_date_params.weekday_name
                   end
    44             if format == '*t' then
    44                 local current_time_val = time_val or get_mock_time()
    44                 local t = original_os_date('*t', current_time_val)
                       -- Override specific fields based on mock_date_params for consistency if time_val is not today
                       if
    44                     time_val == nil
*****0                     or (
    68                         t.year == tonumber(mock_date_params.year)
     4                         and t.month == mock_date_params.month_num
     4                         and t.day == mock_date_params.day_of_month
                           )
                       then
    14                     t.wday = mock_date_params.wday_numeric
                           -- Keep other fields like hour/min/sec from original_os_date for flexibility if needed by tested code
                       end
    44                 return t
                   end
*****0             return original_os_date(format, time_val)
               end
           end)

     2     teardown(function()
     2         os.date = original_os_date
     1         safe_delete_test_file()
           end)

     2     before_each(function()
     7         safe_delete_test_file() -- Ensure clean state
    14         time_data_obj = time_init_module.setup({
     7             path = test_json_path,
     7             hoursPerWeekday = {
                       Monday = 8,
                       Tuesday = 8,
                       Wednesday = 8,
                       Thursday = 8,
                       Friday = 8,
                       Saturday = 0,
                       Sunday = 0,
     7             },
     7         })
               -- Clear any existing data that might persist in the module's state and ensure file is written
     7         if time_data_obj and time_data_obj.content then
     7             if time_data_obj.content.data then -- Check if data table exists before clearing
     7                 time_data_obj.content.data = {}
                   end
                   -- Call calculate to ensure the (potentially cleared) state is saved
                   -- This uses the mocked os.date for year and week by default from calculate's opts.
     7             time_init_module.calculate({})
               end
           end)

           local function get_data_from_json()
    21         local content = fs:new(test_json_path):read()
     7         if content == '' or content == nil then
*****0             return {}
               end
    14         return vim.json.decode(content)
           end

     3     describe('TimeStart and TimeStop', function()
     3         it('should create entries in the specified project and file', function()
     1             local project = 'TestProject'
     1             local file = 'TestFile.lua'
     1             local startTime = get_mock_time()
     1             local stopTime = get_mock_time(3600) -- 1 hour later

     2             time_init_module.TimeStart({
     1                 project = project,
     1                 file = file,
     1                 time = startTime,
                       weekday = 'Monday',
                   })
     2             time_init_module.TimeStop({
     1                 project = project,
     1                 file = file,
     1                 time = stopTime,
                       weekday = 'Monday',
                   })

     1             local data = get_data_from_json()
     1             local year_data = data.data[mock_date_params.year]
     3             assert.is_not_nil(year_data, 'Year data should exist')
     1             local week_data = year_data[mock_date_params.week]
     3             assert.is_not_nil(week_data, 'Week data should exist')
     1             local proj_data = week_data[project]
     3             assert.is_not_nil(proj_data, 'Project data should exist for ' .. project)
     1             local file_data = proj_data[file]
     3             assert.is_not_nil(file_data, 'File data should exist for ' .. file)
     1             local day_data = file_data.weekdays['Monday']
     3             assert.is_not_nil(day_data, 'Monday data should exist')
     4             assert.are.same(1, #day_data.items, 'Should have one item')
     4             assert.are.same(startTime, day_data.items[1].startTime)
     4             assert.are.same(stopTime, day_data.items[1].endTime)
     3             assert.is_near(1, day_data.items[1].diffInHours, 0.001)
               end)

     3         it("should default to 'default_project' and 'default_file' if not specified", function()
     1             local startTime = get_mock_time()
     1             local stopTime = get_mock_time(3600) -- 1 hour later

     1             time_init_module.TimeStart({ time = startTime, weekday = 'Monday' }) -- No project/file
     1             time_init_module.TimeStop({ time = stopTime, weekday = 'Monday' }) -- No project/file

     1             local data = get_data_from_json()
                   local day_data =
     1                 data.data[mock_date_params.year][mock_date_params.week]['default_project']['default_file'].weekdays['Monday']
     3             assert.is_not_nil(day_data, 'Data in default project/file for Monday should exist')
     4             assert.are.same(1, #day_data.items)
     4             assert.are.same(startTime, day_data.items[1].startTime)
     4             assert.are.same(stopTime, day_data.items[1].endTime)
               end)
           end)

     3     describe('addTime', function()
     3         it('should add time to a specific project/file', function()
     1             time_init_module.addTime({
                       time = 2.5,
                       weekday = 'Tuesday',
                       project = 'ProjectX',
                       file = 'file_alpha.md',
                   })
     1             local data = get_data_from_json()
                   local day_items =
     1                 data.data[mock_date_params.year][mock_date_params.week]['ProjectX']['file_alpha.md'].weekdays['Tuesday'].items
     4             assert.are.same(1, #day_items)
     3             assert.is_near(2.5, day_items[1].diffInHours, 0.001)
               end)

     3         it('should use default project/file if not specified', function()
     1             time_init_module.addTime({ time = 1.5, weekday = 'Wednesday' })
     1             local data = get_data_from_json()
                   local day_items =
     1                 data.data[mock_date_params.year][mock_date_params.week]['default_project']['default_file'].weekdays['Wednesday'].items
     4             assert.are.same(1, #day_items)
     3             assert.is_near(1.5, day_items[1].diffInHours, 0.001)
               end)
           end)

     3     describe('subtractTime', function()
               -- subtractTime also adds an entry, its name is a bit of a misnomer for its current implementation
     3         it('should add a time entry (like addTime) to a specific project/file', function()
     1             time_init_module.subtractTime({
                       time = 1,
                       weekday = 'Thursday',
                       project = 'ProjectY',
                       file = 'file_beta.txt',
                   })
     1             local data = get_data_from_json()
                   local day_items =
     1                 data.data[mock_date_params.year][mock_date_params.week]['ProjectY']['file_beta.txt'].weekdays['Thursday'].items
     4             assert.are.same(1, #day_items)
     3             assert.is_near(-1, day_items[1].diffInHours, 0.001) -- diffInHours should be negative for subtractTime
               end)
           end)

     3     describe('setTime', function()
     3         it('should set time for a specific project/file, clearing previous entries', function()
                   -- Add initial entry
     1             time_init_module.addTime({
                       time = 1,
                       weekday = 'Friday',
                       project = 'ProjectZ',
                       file = 'file_gamma.py',
                   })
     1             time_init_module.addTime({
                       time = 2,
                       weekday = 'Friday',
                       project = 'ProjectZ',
                       file = 'file_gamma.py',
                   })

                   -- Now setTime
     1             time_init_module.setTime({
                       time = 3.5,
                       weekday = 'Friday',
                       project = 'ProjectZ',
                       file = 'file_gamma.py',
                   })
     1             local data = get_data_from_json()
                   local day_items =
     1                 data.data[mock_date_params.year][mock_date_params.week]['ProjectZ']['file_gamma.py'].weekdays['Friday'].items
     4             assert.are.same(1, #day_items, 'setTime should result in a single entry for the day')
     3             assert.is_near(3.5, day_items[1].diffInHours, 0.001)
               end)
           end)

     3     describe('calculate', function()
     3         it('should correctly calculate summaries across projects, files, and weekdays', function()
                   -- Expected hours: Monday = 8
     1             time_init_module.addTime({
                       time = 2,
                       weekday = 'Monday',
                       project = 'Alpha',
                       file = 'main.lua',
                   }) -- Alpha/main.lua/Monday: 2hr. Overhour: 2-8 = -6
     1             time_init_module.addTime({
                       time = 3,
                       weekday = 'Monday',
                       project = 'Alpha',
                       file = 'utils.lua',
                   }) -- Alpha/utils.lua/Monday: 3hr. Overhour: 3-8 = -5
     1             time_init_module.addTime({
                       time = 4,
                       weekday = 'Tuesday',
                       project = 'Alpha',
                       file = 'main.lua',
                   }) -- Alpha/main.lua/Tuesday: 4hr. Overhour: 4-8 = -4
     1             time_init_module.addTime({
                       time = 1,
                       weekday = 'Monday',
                       project = 'Bravo',
                       file = 'init.lua',
                   }) -- Bravo/init.lua/Monday: 1hr. Overhour: 1-8 = -7

     2             time_init_module.calculate({
     1                 year = mock_date_params.year,
     1                 weeknumber = mock_date_params.week,
                   })
     1             local data = get_data_from_json()
     1             local week_summary = data.data[mock_date_params.year][mock_date_params.week].summary
                   local alpha_main_mon =
     1                 data.data[mock_date_params.year][mock_date_params.week]['Alpha']['main.lua'].weekdays['Monday'].summary
                   local alpha_utils_mon =
     1                 data.data[mock_date_params.year][mock_date_params.week]['Alpha']['utils.lua'].weekdays['Monday'].summary
                   local alpha_main_tue =
     1                 data.data[mock_date_params.year][mock_date_params.week]['Alpha']['main.lua'].weekdays['Tuesday'].summary
                   local bravo_init_mon =
     1                 data.data[mock_date_params.year][mock_date_params.week]['Bravo']['init.lua'].weekdays['Monday'].summary

     3             assert.is_near(2, alpha_main_mon.diffInHours, 0.001)
     3             assert.is_near(-6, alpha_main_mon.overhour, 0.001)

     3             assert.is_near(3, alpha_utils_mon.diffInHours, 0.001)
     3             assert.is_near(-5, alpha_utils_mon.overhour, 0.001)

     3             assert.is_near(4, alpha_main_tue.diffInHours, 0.001)
     3             assert.is_near(-4, alpha_main_tue.overhour, 0.001)

     3             assert.is_near(1, bravo_init_mon.diffInHours, 0.001)
     3             assert.is_near(-7, bravo_init_mon.overhour, 0.001)

                   -- Total overhour for the week: (-6) + (-5) + (-4) + (-7) = -22
     3             assert.is_near(
     1                 -22,
     1                 week_summary.overhour,
     1                 0.001,
     2                 'Week summary overhour incorrect. Got: ' .. inspect(week_summary.overhour)
                   )
               end)
           end)
       end)

==============================================================================
test/save_time_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep()
     1 helper.notify_dep()
     2 local maorunTime = require('maorun.time')
     2 local Path = require('plenary.path')
     2 local os_module = require('os')

       local tempPath

     2 before_each(function()
     5     tempPath = os_module.tmpname()
     5     maorunTime.setup({ path = tempPath })
       end)

     2 after_each(function()
     5     os_module.remove(tempPath)
       end)

     3 describe('saveTime', function()
           -- Note: os_module.date('%W') gives week number, os_module.date('%A') gives weekday name
           -- Note: saveTime is local, so we test its effects through exported functions like addTime.

     3     it('should correctly save a time entry via addTime', function()
               -- maorunTime.setup({ path = tempPath }) -- Already in before_each
     1         local year = os_module.date('%Y')
     1         local week_number_str = os_module.date('%W') -- Ensure week number is a string for table keys
     1         local weekday = 'Monday'
     1         local hours_to_add = 2

               -- addTime will call saveTime internally
     1         maorunTime.addTime({ time = hours_to_add, weekday = weekday })

     1         local data = maorunTime.calculate({ year = year, weeknumber = week_number_str })
               local item =
     1             data.content.data[year][week_number_str]['default_project']['default_file'].weekdays[weekday].items[1]

     3         assert.is_not_nil(item, 'Item should be saved')
     4         assert.are.same(hours_to_add, item.diffInHours)

     1         local expected_start_time = item.endTime - (hours_to_add * 3600)
     4         assert.are.same(expected_start_time, item.startTime)

     1         local start_readable_expected = os_module.date('%H:%M', expected_start_time)
     1         local end_readable_expected = os_module.date('%H:%M', item.endTime)

     4         assert.are.same(start_readable_expected, item.startReadable)
     4         assert.are.same(end_readable_expected, item.endReadable)
           end)

     3     it('should append multiple time entries for the same day via multiple addTime calls', function()
               -- maorunTime.setup({ path = tempPath }) -- Already in before_each
     1         local weekday = 'Tuesday'
     1         local hours_to_add1 = 3
     1         local hours_to_add2 = 2.5

     1         maorunTime.addTime({ time = hours_to_add1, weekday = weekday })
     1         maorunTime.addTime({ time = hours_to_add2, weekday = weekday })

               -- Calculate the year and week that addTime would have used for weekday
     1         local current_ts_for_test = os_module.time()
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })
               local items =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items

     4         assert.are.same(2, #items, 'Should have two items for the weekday')
     4         assert.are.same(hours_to_add1, items[1].diffInHours)
     4         assert.are.same(hours_to_add2, items[2].diffInHours)
           end)

     3     it('should correctly calculate diffInHours (positive)', function()
               -- maorunTime.setup({ path = tempPath }) -- Already in before_each
     1         local weekday = 'Wednesday'
               -- Let addTime determine startTime and endTime based on 23:00 end time.
     1         local hours_duration = 3.5
     1         maorunTime.addTime({ time = hours_duration, weekday = weekday })

               -- Calculate the year and week that addTime would have used for weekday
     1         local current_ts_for_test = os_module.time()
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })
               local item =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items[1]
     4         assert.are.same(hours_duration, item.diffInHours)
           end)

     3     it('should correctly save readable time formats (HH:MM)', function()
               -- maorunTime.setup({ path = tempPath }) -- Already in before_each
     1         local weekday = 'Thursday'
     1         local hours_to_add = 1

     1         maorunTime.addTime({ time = hours_to_add, weekday = weekday })

               -- Calculate the year and week that addTime would have used for weekday
     1         local current_ts_for_test = os_module.time()
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })
               local item =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items[1]

     3         assert.is_not_nil(item.startTime, 'startTime should be set')
     3         assert.is_not_nil(item.endTime, 'endTime should be set')

     1         local start_t_info = os_module.date('*t', item.startTime)
     1         local end_t_info = os_module.date('*t', item.endTime)

               local expected_start_readable =
     2             string.format('%02d:%02d', start_t_info.hour, start_t_info.min)
     2         local expected_end_readable = string.format('%02d:%02d', end_t_info.hour, end_t_info.min)

     4         assert.are.same(
     1             expected_start_readable,
     1             item.startReadable,
                   'startReadable format should be HH:MM'
     1         )
     4         assert.are.same(
     1             expected_end_readable,
     1             item.endReadable,
                   'endReadable format should be HH:MM'
     1         )
     4         assert.are.same(hours_to_add, item.diffInHours)
           end)

     3     it('should correctly save a time entry with negative diffInHours via subtractTime', function()
               -- maorunTime.setup({ path = tempPath }) -- Already in before_each
     1         local weekday = 'Friday'
     1         local hours_to_subtract = 2

     1         maorunTime.subtractTime({ time = hours_to_subtract, weekday = weekday })

               -- Calculate the year and week that subtractTime (via saveTime) would have used
     1         local current_ts_for_test = os_module.time()
     1         local currentWeekdayNumeric_for_test = os_module.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os_module.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os_module.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })
               local item =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items[1]

     3         assert.is_not_nil(item, 'Item should be saved')
     4         assert.are.same(-hours_to_subtract, item.diffInHours)

               -- In subtractTime, startTime is set to 23:00 of the target day,
               -- and endTime is startTime - duration.
               -- So, endTime should be item.startTime - (hours_to_subtract * 3600)
     1         local expected_end_time = item.startTime - (hours_to_subtract * 3600)
     4         assert.are.same(expected_end_time, item.endTime)

     1         local start_readable_expected = os_module.date('%H:%M', item.startTime)
     1         local end_readable_expected = os_module.date('%H:%M', item.endTime)

     4         assert.are.same(start_readable_expected, item.startReadable)
     4         assert.are.same(end_readable_expected, item.endReadable)
           end)
       end)

==============================================================================
test/subtract_time_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep()
     1 helper.notify_dep()

     2 local maorunTime = require('maorun.time')
     2 local os = require('os')
     2 local Path = require('plenary.path') -- Added for file manipulation
       local tempPath

       -- Copied from lua/maorun/time/init.lua for test purposes
     1 local wdayToEngName = {
           [1] = 'Sunday',
           [2] = 'Monday',
           [3] = 'Tuesday',
           [4] = 'Wednesday',
           [5] = 'Thursday',
           [6] = 'Friday',
           [7] = 'Saturday',
       }

     2 before_each(function()
     6     tempPath = os.tmpname()
           -- Default setup, tests can override if specific hoursPerWeekday are needed
     6     maorunTime.setup({ path = tempPath })
       end)

     2 after_each(function()
     6     os.remove(tempPath)
       end)

     3 describe('subtractTime', function()
     3     it('should subtract a whole number of hours from a specific weekday', function()
     1         local weekday = 'Monday'
     1         local hoursToSubtract = 3
     1         local defaultHoursForMonday = 8 -- Assuming default config

     1         maorunTime.subtractTime({ time = hoursToSubtract, weekday = weekday })
     1         local data = maorunTime.calculate()

     1         local year = os.date('%Y')
     1         local week = os.date('%W')

     3         assert.is_not_nil(
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[weekday],
                   'Weekday data should exist'
     1         )
     3         assert.is_not_nil(
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[weekday].items,
                   'Items should exist'
     1         )
     4         assert.are.same(
     1             1,
     1             #data.content.data[year][week]['default_project']['default_file'].weekdays[weekday].items,
                   'One item should be created'
     1         )

               local item =
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[weekday].items[1]
     2         assert(
     2             math.abs(item.diffInHours - -hoursToSubtract) < 0.001,
     1             'diffInHours should be approximately ' .. -hoursToSubtract
               )

               local weekdaySummary =
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[weekday].summary
     2         assert(
     2             math.abs(weekdaySummary.diffInHours - -hoursToSubtract) < 0.001,
     1             'Weekday summary diffInHours should be approximately ' .. -hoursToSubtract
               )
     2         assert(
     2             math.abs(weekdaySummary.overhour - (-hoursToSubtract - defaultHoursForMonday)) < 0.001,
     1             'Weekday summary overhour should be ' .. (-hoursToSubtract - defaultHoursForMonday)
               )

     1         local weekSummary = data.content.data[year][week].summary
     2         assert(
     2             math.abs(weekSummary.overhour - (-hoursToSubtract - defaultHoursForMonday)) < 0.001,
     1             'Week summary overhour should be ' .. (-hoursToSubtract - defaultHoursForMonday)
               )
           end)

     3     it('should subtract fractional hours from a specific weekday', function()
     1         local weekday = 'Tuesday'
     1         local hoursToSubtract = 2.5
     1         local defaultHoursForTuesday = 8 -- Assuming default config

     1         maorunTime.subtractTime({ time = hoursToSubtract, weekday = weekday })

               -- Calculate the year and week that subtractTime (via saveTime) would have used for weekday
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'Items should exist for Tuesday'
     1         )
     4         assert.are.same(
     1             1,
     1             #data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'One item should be created for Tuesday'
     1         )

               local item =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items[1]
     2         assert(
     2             math.abs(item.diffInHours - -hoursToSubtract) < 0.001,
     1             'diffInHours for Tuesday should be approximately ' .. -hoursToSubtract
               )

               local weekdaySummary =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].summary
     2         assert(
     2             math.abs(weekdaySummary.diffInHours - -hoursToSubtract) < 0.001,
     1             'Tuesday summary diffInHours should be approximately ' .. -hoursToSubtract
               )
     2         assert(
     2             math.abs(weekdaySummary.overhour - (-hoursToSubtract - defaultHoursForTuesday)) < 0.001,
     1             'Tuesday summary overhour should be ' .. (-hoursToSubtract - defaultHoursForTuesday)
               )

     1         local weekSummary = data.content.data[expected_year_key][expected_week_key].summary
     2         assert(
     2             math.abs(weekSummary.overhour - (-hoursToSubtract - defaultHoursForTuesday)) < 0.001,
                   'Week summary overhour should reflect Tuesday subtraction'
     1         )
           end)

     3     it('should subtract time from the current day if weekday is not provided', function()
     1         local hoursToSubtract = 1.5
     1         local currentWeekday = wdayToEngName[os.date('*t').wday]
               local defaultHoursForCurrentDay =
     2             maorunTime.setup({ path = tempPath }).content.hoursPerWeekday[currentWeekday]

     1         maorunTime.subtractTime({ time = hoursToSubtract }) -- No weekday argument
     1         local data = maorunTime.calculate()

     1         local year = os.date('%Y')
     1         local week = os.date('%W')

     3         assert.is_not_nil(
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[currentWeekday].items,
                   'Items should exist for current day'
     1         )
     4         assert.are.same(
     1             1,
     1             #data.content.data[year][week]['default_project']['default_file'].weekdays[currentWeekday].items,
                   'One item should be created for current day'
     1         )

               local item =
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[currentWeekday].items[1]
     2         assert(
     2             math.abs(item.diffInHours - -hoursToSubtract) < 0.001,
     1             'diffInHours for current day should be approximately ' .. -hoursToSubtract
               )

               local weekdaySummary =
     1             data.content.data[year][week]['default_project']['default_file'].weekdays[currentWeekday].summary
     2         assert(
     2             math.abs(weekdaySummary.diffInHours - -hoursToSubtract) < 0.001,
     1             'Current day summary diffInHours should be approximately ' .. -hoursToSubtract
               )
     2         assert(
     2             math.abs(weekdaySummary.overhour - (-hoursToSubtract - defaultHoursForCurrentDay))
     1                 < 0.001,
                   'Current day summary overhour calculation'
     1         )

     1         local weekSummary = data.content.data[year][week].summary
     2         assert(
     2             math.abs(weekSummary.overhour - (-hoursToSubtract - defaultHoursForCurrentDay)) < 0.001,
                   'Week summary overhour should reflect current day subtraction'
     1         )
           end)

     3     it('should correctly subtract time from a day with no prior entries', function()
     1         local weekday = 'Wednesday'
     1         local hoursToSubtract = 4
     1         local defaultHoursForWednesday = 8 -- Assuming default config

               -- Ensure no prior entries by re-initializing or checking count
               -- before_each already sets up a clean state with no entries

     1         maorunTime.subtractTime({ time = hoursToSubtract, weekday = weekday })

               -- Calculate the year and week that subtractTime (via saveTime) would have used for weekday
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'Items should exist for Wednesday'
     1         )
     4         assert.are.same(
     1             1,
     1             #data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'One item should be created for Wednesday'
     1         )

               local item =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items[1]
     2         assert(
     2             math.abs(item.diffInHours - -hoursToSubtract) < 0.001,
     1             'diffInHours for Wednesday should be approximately ' .. -hoursToSubtract
               )

               local weekdaySummary =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].summary
     2         assert(
     2             math.abs(weekdaySummary.diffInHours - -hoursToSubtract) < 0.001,
     1             'Wednesday summary diffInHours should be approximately ' .. -hoursToSubtract
               )
     2         assert(
     2             math.abs(weekdaySummary.overhour - (-hoursToSubtract - defaultHoursForWednesday))
     1                 < 0.001,
                   'Wednesday summary overhour calculation'
     1         )

     1         local weekSummary = data.content.data[expected_year_key][expected_week_key].summary
     2         assert(
     2             math.abs(weekSummary.overhour - (-hoursToSubtract - defaultHoursForWednesday)) < 0.001,
                   'Week summary overhour should reflect Wednesday subtraction'
     1         )
           end)

     3     it('should correctly update summaries after subtraction and recalculation', function()
     1         local weekday = 'Thursday'
     1         local initialHours = 5
     1         local hoursToSubtract = 2
     1         local defaultHoursForThursday = 8 -- Assuming default config

     1         maorunTime.addTime({ time = initialHours, weekday = weekday })
     1         maorunTime.subtractTime({ time = hoursToSubtract, weekday = weekday })

               -- Calculate the year and week that addTime/subtractTime (via saveTime) would have used for weekday
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'Items should exist for Thursday'
     1         )
     4         assert.are.same(
     1             2,
     1             #data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'Two items should exist for Thursday (add and subtract)'
     1         )

     1         local totalDiffInHours = initialHours - hoursToSubtract
               local weekdaySummary =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].summary
     2         assert(
     2             math.abs(weekdaySummary.diffInHours - totalDiffInHours) < 0.001,
     1             'Thursday summary diffInHours should be ' .. totalDiffInHours
               )
     2         assert(
     2             math.abs(weekdaySummary.overhour - (totalDiffInHours - defaultHoursForThursday)) < 0.001,
     1             'Thursday summary overhour should be ' .. (totalDiffInHours - defaultHoursForThursday)
               )

     1         local weekSummary = data.content.data[expected_year_key][expected_week_key].summary
     2         assert(
     2             math.abs(weekSummary.overhour - (totalDiffInHours - defaultHoursForThursday)) < 0.001,
                   'Week summary overhour should reflect combined Thursday operations'
     1         )
           end)

     3     it('should function correctly when time tracking is paused and resumed', function()
     1         local weekday = 'Friday'
     1         local hoursToSubtract = 1
     1         local defaultHoursForFriday = 8 -- Assuming default config

     1         maorunTime.TimePause()
     4         assert.is_true(maorunTime.isPaused(), 'Time tracking should be paused')

     1         maorunTime.subtractTime({ time = hoursToSubtract, weekday = weekday })

     1         maorunTime.TimeResume()
     4         assert.is_false(maorunTime.isPaused(), 'Time tracking should be resumed')

               -- Calculate the year and week that subtractTime (via saveTime) would have used for weekday
     1         local current_ts_for_test = os.time()
     1         local currentWeekdayNumeric_for_test = os.date('*t', current_ts_for_test).wday - 1
     1         local targetWeekdayNumeric_for_test = maorunTime.weekdays[weekday]
     1         local diffDays_for_test = currentWeekdayNumeric_for_test - targetWeekdayNumeric_for_test
     1         if diffDays_for_test < 0 then
     1             diffDays_for_test = diffDays_for_test + 7
               end
     1         local target_day_ref_ts_for_test = current_ts_for_test - (diffDays_for_test * 24 * 3600)

     1         local expected_year_key = os.date('%Y', target_day_ref_ts_for_test)
     1         local expected_week_key = os.date('%W', target_day_ref_ts_for_test)

               local data =
     1             maorunTime.calculate({ year = expected_year_key, weeknumber = expected_week_key })

               -- Check file content for paused state (optional, as isPaused() checks internal state)
     3         local file_content_raw = Path:new(tempPath):read()
     2         local file_content = vim.json.decode(file_content_raw)
     3         assert.is_false(
     1             file_content.paused,
                   'Paused state in data file should be false after resume'
     1         )

     3         assert.is_not_nil(
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'Items should exist for Friday'
     1         )
     4         assert.are.same(
     1             1,
     1             #data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items,
                   'One item should be created for Friday despite pause/resume'
     1         )

               local item =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].items[1]
     2         assert(
     2             math.abs(item.diffInHours - -hoursToSubtract) < 0.001,
     1             'diffInHours for Friday should be approximately ' .. -hoursToSubtract
               )

               local weekdaySummary =
     1             data.content.data[expected_year_key][expected_week_key]['default_project']['default_file'].weekdays[weekday].summary
     2         assert(
     2             math.abs(weekdaySummary.diffInHours - -hoursToSubtract) < 0.001,
     1             'Friday summary diffInHours should be approximately ' .. -hoursToSubtract
               )
     2         assert(
     2             math.abs(weekdaySummary.overhour - (-hoursToSubtract - defaultHoursForFriday)) < 0.001,
                   'Friday summary overhour calculation'
     1         )

     1         local weekSummary = data.content.data[expected_year_key][expected_week_key].summary
     2         assert(
     2             math.abs(weekSummary.overhour - (-hoursToSubtract - defaultHoursForFriday)) < 0.001,
                   'Week summary overhour should reflect Friday subtraction'
     1         )
           end)
       end)

==============================================================================
test/time_pause_resume_spec.lua
==============================================================================
     2 local time = require('maorun.time')

     3 describe('Time Pause and Resume', function()
           -- Clean up before each test to ensure a consistent state
     2     before_each(function()
               -- Reset the paused state to false before each test
               -- This assumes that the functions under test might alter a global or module-level state.
               -- If 'obj.content' is accessible and can be reset, do it here.
               -- For now, we'll rely on TimeResume() to reset the state if previously paused.
               -- and the init() function called by isPaused() to initialize the state.
               -- A more robust way would be to directly reset `obj.content.paused` if possible,
               -- or ensure 'init()' always resets to a known default for testing.

               -- Create a dummy time file for testing. This ensures that `init()` reads a known state.
               -- The structure of this JSON should match what `save(obj)` would write,
               -- meaning `paused` should be a top-level key in `obj.content`.
    12         local Path = require('plenary.path')
    12         local test_time_file_path = vim.fn.stdpath('data')
     6             .. Path.path.sep
     6             .. 'maorun-time-test.json'
               -- Initialize with paused = false and default hours, similar to how `init` and `save` would structure it.
     6         local initial_data = {
                   paused = false,
     6             hoursPerWeekday = { -- Add default or test-specific hours to mimic real data structure
                       Monday = 8,
                       Tuesday = 8,
                       Wednesday = 8,
                       Thursday = 8,
                       Friday = 8,
                       Saturday = 0,
                       Sunday = 0,
     6             },
     6             data = {}, -- Include the 'data' table to prevent errors if accessed
               }
    30         Path:new(test_time_file_path):write(vim.fn.json_encode(initial_data), 'w')

               -- Configure the time module to use this test file and some default hours.
               -- The hoursPerWeekday here will be merged by init if not present in the file,
               -- but it's good practice to have the file be self-contained if possible.
    12         time.setup({
     6             path = test_time_file_path,
     6             hoursPerWeekday = initial_data.hoursPerWeekday,
               })
           end)

     3     describe('isPaused()', function()
     2         it(
     1             'should return false before TimePause() is ever called (due to before_each setup)',
                   function()
     4                 assert.is_false(time.isPaused())
                   end
               )

     3         it('should return true after TimePause() is called', function()
     1             time.TimePause()
     4             assert.is_true(time.isPaused())
               end)

     3         it('should return false after TimePause() then TimeResume() is called', function()
     1             time.TimePause()
     1             time.TimeResume()
     4             assert.is_false(time.isPaused())
               end)
           end)

     3     describe('TimePause()', function()
     3         it('should cause isPaused() to return true', function()
     1             time.TimePause()
     4             assert.is_true(time.isPaused())
               end)
           end)

     3     describe('TimeResume()', function()
     3         it('should cause isPaused() to return false after TimePause()', function()
     1             time.TimePause() -- Ensure it's paused first
     1             time.TimeResume()
     4             assert.is_false(time.isPaused())
               end)

     3         it('should not error if called when not paused', function()
                   -- Ensure time is not paused
     2             if time.isPaused() then
*****0                 time.TimeResume()
                   end -- reset if needed
     4             assert.is_false(time.isPaused()) -- verify it's not paused

     2             local success, err = pcall(time.TimeResume)
     3             assert.is_true(
     1                 success,
     2                 'TimeResume() should not error if called when not paused. Error: ' .. tostring(err)
                   )
     3             assert.is_false(
     1                 time.isPaused(),
                       'isPaused() should still return false after TimeResume() when not paused.'
     1             )
               end)
           end)
       end)

==============================================================================
test/time_start_stop_spec.lua
==============================================================================
     2 local helper = require('test.helper')
     1 helper.plenary_dep()
     1 helper.notify_dep()

     2 local maorunTime = require('maorun.time')
     2 local Path = require('plenary.path')
     2 local os_module = require('os') -- Use a different name to avoid conflict with global os

       local tempPath

     2 before_each(function()
     7     tempPath = os_module.tmpname()
           -- Ensure the file is created for setup
     7     maorunTime.setup({ path = tempPath })
       end)

     2 after_each(function()
     7     os_module.remove(tempPath)
       end)

     3 describe('TimeStart', function()
     3     it('should record start time for the current day and time', function()
               -- Mock os.date and os.time
     1         local original_os_date = os_module.date
     1         local original_os_time = os_module.time

     1         local mock_time = 1678886400 -- Wednesday, March 15, 2023 12:00:00 PM GMT
     1         os_module.time = function()
     1             return mock_time
               end
     1         os_module.date = function(format, time)
    17             time = time or mock_time
    17             return original_os_date(format, time)
               end

     1         maorunTime.TimeStart({ time = mock_time }) -- Pass opts table
               local data =
     3             maorunTime.calculate({ year = os_module.date('%Y'), weeknumber = os_module.date('%W') })

     1         local current_weekday = os_module.date('%A')
     1         local year = os_module.date('%Y')
     1         local week_number = os_module.date('%W')

     3         assert.is_not_nil(
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1],
                   'Time entry not found for current day'
     1         )
     4         assert.are.same(
     1             mock_time,
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1].startTime
     1         )
     3         assert.is_nil(
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1].endTime
     1         )

               -- Restore original functions
     1         os_module.date = original_os_date
     1         os_module.time = original_os_time
           end)

     3     it('should record start time for a specific weekday and time', function()
     1         local target_weekday = 'Monday'
     1         local specific_time = 1678694400 -- Monday, March 13, 2023 08:00:00 AM GMT

               -- Mock os.date and os.time to control the "current" date if TimeStart uses it for year/week determination
     1         local original_os_date = os_module.date
     1         local original_os_time = os_module.time
     1         os_module.time = function()
*****0             return specific_time
               end -- Ensure os.time() returns the specific time
     1         os_module.date = function(format, time)
    11             time = time or specific_time -- Default to specific_time if no time is provided
    11             return original_os_date(format, time) -- Call original os.date with potentially mocked time
               end

     1         maorunTime.TimeStart({ weekday = target_weekday, time = specific_time }) -- Pass opts table

               -- Determine year and week number from the specific_time
     1         local year = original_os_date('%Y', specific_time)
     1         local week_number = original_os_date('%W', specific_time)

     1         local data = maorunTime.calculate({ year = year, weeknumber = week_number })

     3         assert.is_not_nil(
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[target_weekday].items[1],
                   'Time entry not found for target day'
     1         )
     4         assert.are.same(
     1             specific_time,
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[target_weekday].items[1].startTime
     1         )
     3         assert.is_nil(
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[target_weekday].items[1].endTime
     1         )

               -- Restore original functions
     1         os_module.date = original_os_date
     1         os_module.time = original_os_time
           end)

     3     it('should not add a new entry if an unstopped entry exists for the current day', function()
               -- Mock os.date and os.time
     1         local original_os_date = os_module.date
     1         local original_os_time = os_module.time

     1         local initial_time = 1678886400 -- Wednesday, March 15, 2023 12:00:00 PM GMT
     1         os_module.time = function()
     1             return initial_time
               end
     1         os_module.date = function(format, time)
    11             time = time or initial_time
    11             return original_os_date(format, time)
               end

               -- Start an initial entry
     1         maorunTime.TimeStart({ time = initial_time }) -- Pass opts table

     1         local year = os_module.date('%Y')
     1         local week_number = os_module.date('%W')
     1         local current_weekday = os_module.date('%A')

               -- Attempt to start another entry without stopping the first one
     1         local later_time = initial_time + 3600 -- One hour later
     1         os_module.time = function()
     1             return later_time
               end
     1         os_module.date = function(format, time) -- Ensure date also reflects this later time if needed
    11             time = time or later_time
    11             return original_os_date(format, time)
               end

     1         maorunTime.TimeStart({ time = later_time }) -- This call should be ignored, pass opts

     1         local data = maorunTime.calculate({ year = year, weeknumber = week_number })
     4         assert.are.same(
     1             1,
     1             #data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items,
                   'Should only have one entry'
     1         )
     4         assert.are.same(
     1             initial_time,
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1].startTime
     1         )
     3         assert.is_nil(
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1].endTime
     1         )

               -- Restore original functions
     1         os_module.date = original_os_date
     1         os_module.time = original_os_time
           end)
       end)

     3 describe('TimeStop', function()
     3     it('should record end time for the current day and time and calculate diffInHours', function()
     1         local original_os_date = os_module.date
     1         local original_os_time = os_module.time

     1         local start_time = 1678886400 -- Wednesday, March 15, 2023 12:00:00 PM GMT
     1         os_module.time = function()
     1             return start_time
               end
     1         os_module.date = function(format, time)
     8             time = time or start_time
     8             return original_os_date(format, time)
               end
     1         maorunTime.TimeStart({ time = start_time }) -- Pass opts table

     1         local stop_time = start_time + 3600 -- Stop 1 hour later
     1         os_module.time = function()
     1             return stop_time
               end
     1         os_module.date = function(format, time)
    14             time = time or stop_time
    14             return original_os_date(format, time)
               end
     1         maorunTime.TimeStop({ time = stop_time }) -- Pass opts table

     1         local year = original_os_date('%Y', start_time)
     1         local week_number = original_os_date('%W', start_time)
     1         local current_weekday = original_os_date('%A', start_time)
     1         local data = maorunTime.calculate({ year = year, weeknumber = week_number })
               local item =
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1]

     3         assert.is_not_nil(item, 'Time entry not found')
     4         assert.are.same(stop_time, item.endTime)
     4         assert.are.same(1, item.diffInHours) -- 3600 seconds = 1 hour

     1         os_module.date = original_os_date
     1         os_module.time = original_os_time
           end)

     2     it(
     1         'should record end time for a specific weekday and time and calculate diffInHours',
               function()
     1             local original_os_date = os_module.date
     1             local original_os_time = os_module.time

     1             local target_weekday = 'Monday'
     1             local start_time = 1678694400 -- Monday, March 13, 2023 08:00:00 AM GMT
     1             local stop_time = start_time + (2 * 3600) -- Stop 2 hours later

                   -- Mock time for TimeStart
     1             os_module.time = function()
*****0                 return start_time
                   end
     1             os_module.date = function(format, time)
     7                 time = time or start_time
     7                 return original_os_date(format, time)
                   end
     1             maorunTime.TimeStart({ weekday = target_weekday, time = start_time }) -- Pass opts table

                   -- Mock time for TimeStop
     1             os_module.time = function()
*****0                 return stop_time
                   end
     1             os_module.date = function(format, time)
    13                 time = time or stop_time
    13                 return original_os_date(format, time)
                   end
     1             maorunTime.TimeStop({ weekday = target_weekday, time = stop_time }) -- Pass opts table

     1             local year = original_os_date('%Y', start_time)
     1             local week_number = original_os_date('%W', start_time)
     1             local data = maorunTime.calculate({ year = year, weeknumber = week_number })
                   local item =
     1                 data.content.data[year][week_number]['default_project']['default_file'].weekdays[target_weekday].items[1]

     3             assert.is_not_nil(item, 'Time entry not found for target day')
     4             assert.are.same(stop_time, item.endTime)
     4             assert.are.same(2, item.diffInHours)

     1             os_module.date = original_os_date
     1             os_module.time = original_os_time
               end
           )

     3     it('should handle TimeStop call without a preceding TimeStart for the day', function()
     1         local original_os_date = os_module.date
     1         local original_os_time = os_module.time

     1         local stop_time = 1678886400 -- Wednesday, March 15, 2023 12:00:00 PM GMT
     1         os_module.time = function()
     1             return stop_time
               end
     1         os_module.date = function(format, time)
    13             time = time or stop_time
    13             return original_os_date(format, time)
               end

               -- No TimeStart call for this day
     1         maorunTime.TimeStop({ time = stop_time }) -- Attempt to stop, pass opts table

     1         local year = original_os_date('%Y', stop_time)
     1         local week_number = original_os_date('%W', stop_time)
     1         local current_weekday = original_os_date('%A', stop_time)
     1         local data = maorunTime.calculate({ year = year, weeknumber = week_number })

               -- Check that no item was created or that items list is empty/nil
     1         local weekday_data = data.content.data[year]
     1             and data.content.data[year][week_number]
     1             and data.content.data[year][week_number]['default_project']
     1             and data.content.data[year][week_number]['default_project']['default_file']
     1             and data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday]
     1         if weekday_data and weekday_data.items then
*****0             assert.are.same(
                       0,
*****0                 #weekday_data.items,
                       'No items should exist if TimeStart was not called'
                   )
               else
                   -- If weekday_data or items is nil, it also means no entry, which is correct
     3             assert.is_true(true)
               end
               -- We are also implicitly testing that no error occurred.
               -- Testing for notifications is complex and depends on the notification mock setup,
               -- which might be beyond simple unit test scope here. The lua/maorun/time/init.lua
               -- already has a notify call for this case.

     1         os_module.date = original_os_date
     1         os_module.time = original_os_time
           end)

     3     it('should not alter an already stopped entry', function()
     1         local original_os_date = os_module.date
     1         local original_os_time = os_module.time

     1         local start_time = 1678886400 -- Wednesday, March 15, 2023 12:00:00 PM GMT
     1         local first_stop_time = start_time + 3600 -- Stop 1 hour later
     1         local second_stop_time = first_stop_time + 1800 -- Attempt to stop again 30 mins later

               -- Initial Start
     1         os_module.time = function()
     1             return start_time
               end
     1         os_module.date = function(format, time)
     8             time = time or start_time
     8             return original_os_date(format, time)
               end
     1         maorunTime.TimeStart({ time = start_time }) -- Pass opts table

               -- First Stop
     1         os_module.time = function()
     1             return first_stop_time
               end
     1         os_module.date = function(format, time)
    10             time = time or first_stop_time
    10             return original_os_date(format, time)
               end
     1         maorunTime.TimeStop({ time = first_stop_time }) -- Pass opts table

               -- Attempt Second Stop
     1         os_module.time = function()
     1             return second_stop_time
               end
     1         os_module.date = function(format, time)
    13             time = time or second_stop_time
    13             return original_os_date(format, time)
               end
     1         maorunTime.TimeStop({ time = second_stop_time }) -- Pass opts table, this call should not change the existing entry

     1         local year = original_os_date('%Y', start_time)
     1         local week_number = original_os_date('%W', start_time)
     1         local current_weekday = original_os_date('%A', start_time)
     1         local data = maorunTime.calculate({ year = year, weeknumber = week_number })
               local item =
     1             data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items[1]

     3         assert.is_not_nil(item, 'Time entry not found')
     4         assert.are.same(first_stop_time, item.endTime, 'endTime should remain from the first stop')
     4         assert.are.same(1, item.diffInHours, 'diffInHours should remain from the first stop')
     4         assert.are.same(
     1             1,
     1             #data.content.data[year][week_number]['default_project']['default_file'].weekdays[current_weekday].items,
                   'Should still only have one entry'
     1         )

     1         os_module.date = original_os_date
     1         os_module.time = original_os_time
           end)
       end)

==============================================================================
Summary
==============================================================================

File                                                                                                             Hits Missed Coverage
-------------------------------------------------------------------------------------------------------------------------------------
/home/runner/.local/share/nvim/test/notify/lua/notify/animate/init.lua                                           3    0      100.00%
/home/runner/.local/share/nvim/test/notify/lua/notify/animate/spring.lua                                         5    26     16.13%
/home/runner/.local/share/nvim/test/notify/lua/notify/config/highlights.lua                                      8    0      100.00%
/home/runner/.local/share/nvim/test/notify/lua/notify/config/init.lua                                            17   68     20.00%
/home/runner/.local/share/nvim/test/notify/lua/notify/init.lua                                                   18   45     28.57%
/home/runner/.local/share/nvim/test/notify/lua/notify/instance.lua                                               8    109    6.84%
/home/runner/.local/share/nvim/test/notify/lua/notify/service/buffer/highlights.lua                              6    76     7.32%
/home/runner/.local/share/nvim/test/notify/lua/notify/service/buffer/init.lua                                    18   64     21.95%
/home/runner/.local/share/nvim/test/notify/lua/notify/service/init.lua                                           9    50     15.25%
/home/runner/.local/share/nvim/test/notify/lua/notify/service/notification.lua                                   6    16     27.27%
/home/runner/.local/share/nvim/test/notify/lua/notify/stages/init.lua                                            3    1      75.00%
/home/runner/.local/share/nvim/test/notify/lua/notify/stages/util.lua                                            10   92     9.80%
/home/runner/.local/share/nvim/test/notify/lua/notify/util/init.lua                                              18   57     24.00%
/home/runner/.local/share/nvim/test/notify/lua/notify/util/queue.lua                                             8    20     28.57%
/home/runner/.local/share/nvim/test/notify/lua/notify/windows/init.lua                                           19   169    10.11%
/home/runner/.local/share/nvim/test/plenary/lua/plenary/bit.lua                                                  1    126    0.79%
/home/runner/.local/share/nvim/test/plenary/lua/plenary/functional.lua                                           17   25     40.48%
/home/runner/.local/share/nvim/test/plenary/lua/plenary/path.lua                                                 146  344    29.80%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/block.lua                         70   25     73.68%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/context.lua                       47   35     57.32%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/core.lua                          76   115    39.79%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/environment.lua                   6    15     28.57%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/execute.lua                       19   21     47.50%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/init.lua                          23   56     29.11%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/languages/en.lua                  27   0      100.00%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/luajit.lua                        19   11     63.33%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/files/lua.lua             10   1      90.91%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/files/moonscript.lua      6    46     11.54%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/filter_loader.lua         35   48     42.17%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/output_handler_loader.lua 9    10     47.37%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/modules/test_file_loader.lua      44   10     81.48%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/TAP.lua            33   31     51.56%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/base.lua           63   36     63.64%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/vusted/default.lua 18   29     38.30%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/runner.lua                        57   76     42.86%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/status.lua                        15   2      88.24%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/busted/utils.lua                         11   10     52.38%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/inspect.lua                              57   105    35.19%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/assert.lua                      19   62     23.46%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/assertions.lua                  46   174    20.91%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/formatters/init.lua             20   114    14.93%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/match.lua                       1    31     3.12%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/modifiers.lua                   3    8      27.27%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/state.lua                       4    47     7.84%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/luassert/util.lua                        75   103    42.13%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/mediator.lua                             38   27     58.46%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/List.lua                              62   156    28.44%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/class.lua                             20   82     19.61%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/dir.lua                               65   188    25.69%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/path.lua                              36   222    13.95%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/tablex.lua                            27   377    6.68%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/types.lua                             5    57     8.06%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/pl/utils.lua                             9    292    2.99%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/say/init.lua                             13   15     46.43%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/.luarocks/share/lua/5.1/vusted/run.lua                           5    18     21.74%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/init.lua                                         348  68     83.65%
test/add_time_spec.lua                                                                                           122  0      100.00%
test/calculate_spec.lua                                                                                          343  16     95.54%
test/helper.lua                                                                                                  21   0      100.00%
test/plugin_spec.lua                                                                                             119  1      99.17%
test/project_file_tracking_spec.lua                                                                              153  4      97.45%
test/save_time_spec.lua                                                                                          117  0      100.00%
test/subtract_time_spec.lua                                                                                      234  0      100.00%
test/time_pause_resume_spec.lua                                                                                  45   1      97.83%
test/time_start_stop_spec.lua                                                                                    212  5      97.70%
-------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                            3127 4038   43.64%
