==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/init.lua
==============================================================================
   8 local Path = require('plenary.path')
   8 local os_sep = require('plenary.path').path.sep
   8 local notify = require('notify')

   8 local wdayToEngName = {
         [1] = 'Sunday',
         [2] = 'Monday',
         [3] = 'Tuesday',
         [4] = 'Wednesday',
         [5] = 'Thursday',
         [6] = 'Friday',
         [7] = 'Saturday',
     }

     local function save(obj)
 473     Path:new(obj.path):write(vim.fn.json_encode(obj.content), 'w')
     end

   8 local obj = {
         path = nil,
     }

   8 local defaultHoursPerWeekday = {
         Monday = 8,
         Tuesday = 8,
         Wednesday = 8,
         Thursday = 8,
         Friday = 8,
         Saturday = 0,
         Sunday = 0,
     }

   8 local weekdayNumberMap = {
         Sunday = 0,
         Monday = 1,
         Tuesday = 2,
         Wednesday = 3,
         Thursday = 4,
         Friday = 5,
         Saturday = 6,
     }

   8 local defaults = {
  16     path = vim.fn.stdpath('data') .. os_sep .. 'maorun-time.json',
   8     hoursPerWeekday = defaultHoursPerWeekday,
     }
   8 local config = defaults

     local function init(user_config)
 498     config = vim.tbl_deep_extend('force', defaults, user_config or {})
 249     if user_config.hoursPerWeekday ~= nil then
 206         config.hoursPerWeekday = user_config.hoursPerWeekday
         end
 249     obj.path = config.path
 249     local p = Path:new(obj.path)
 747     if not p:exists() then
  14         p:touch({ parents = true })
         end

 747     local data = Path:new(obj.path):read()
 249     if data ~= '' then
 129         obj.content = vim.json.decode(data)
         else
 120         obj.content = {}
         end
         -- Ensure hoursPerWeekday is initialized if not present (e.g. new file)
 249     if obj.content['hoursPerWeekday'] == nil then
 123         obj.content['hoursPerWeekday'] = config.hoursPerWeekday
         end

 249     if obj.content['data'] == nil then
 120         obj.content['data'] = {}
         end

 249     local year_str = os.date('%Y')
 249     local week_str = os.date('%W')
 249     local project_name = 'default_project' -- Hardcoded for now
 249     local file_name = 'default_file' -- Hardcoded for now

 249     if obj.content['data'][year_str] == nil then
 135         obj.content['data'][year_str] = {}
         end
 249     if obj.content['data'][year_str][week_str] == nil then
 135         obj.content['data'][year_str][week_str] = {}
         end
 249     if obj.content['data'][year_str][week_str][project_name] == nil then
 135         obj.content['data'][year_str][week_str][project_name] = {}
         end
 249     if obj.content['data'][year_str][week_str][project_name][file_name] == nil then
 135         obj.content['data'][year_str][week_str][project_name][file_name] = {
 135             weekdays = {}, -- Will store weekday -> {summary={}, items={...}}
                 -- The weekly summary (overhour) is not initialized here,
                 -- it will be handled by the calculate function.
 135         }
         end
 249     return obj
     end

     ---@param opts {weeknumber: string|osdate, year: string|osdate}|nil
     local function calculate(opts)
 184     opts = vim.tbl_deep_extend('keep', opts or {}, {
 180         year = os.date('%Y'),
 180         weeknumber = os.date('%W'),
  92     })

  92     local year_str = opts.year
  92     local week_str = opts.weeknumber

  92     if not obj.content['data'][year_str] or not obj.content['data'][year_str][week_str] then
             -- No data for this year/week, nothing to calculate
***0         return
         end

  92     local current_week_data = obj.content['data'][year_str][week_str]

         -- Initialize week summary if it doesn't exist under current_week_data.summary
  92     if current_week_data.summary == nil then
  40         current_week_data.summary = {}
         end

  92     local prevWeekOverhour = 0
         -- Ensure year_str data exists before trying to access previous week
  92     if obj.content['data'][year_str] then
  92         local prev_week_number_str = string.format('%02d', tonumber(week_str) - 1)
  92         if obj.content['data'][year_str][prev_week_number_str] then
   2             local prev_week_data = obj.content['data'][year_str][prev_week_number_str]
   2             if prev_week_data and prev_week_data.summary and prev_week_data.summary.overhour then
   2                 prevWeekOverhour = prev_week_data.summary.overhour
                 end
             end
         end

  92     current_week_data.summary.overhour = prevWeekOverhour -- Initialize with previous week's carry-over
         -- local total_time_in_week = 0 -- Can be used if we want to store total logged time for the week explicitly

         -- Iterate over projects in the current week
 290     for project_name, project_data in pairs(current_week_data) do
 198         if project_name ~= 'summary' then -- Skip the summary table itself
                 -- Iterate over files in the current project
 216             for file_name, file_data in pairs(project_data) do
 110                 if file_data.weekdays then
                         -- Iterate over weekdays in the current file
 204                     for weekday_name, day_data in pairs(file_data.weekdays) do
  94                         local time_in_weekday = 0
  94                         if day_data.items then
 199                             for _, item_entry in pairs(day_data.items) do
 105                                 if item_entry.diffInHours ~= nil then
 102                                     time_in_weekday = time_in_weekday + item_entry.diffInHours
                                     end
                                 end
                             end

                             -- Update summary for this specific day under project -> file -> weekday
  94                         if day_data.summary == nil then
   1                             day_data.summary = {}
                             end
  94                         day_data.summary.diffInHours = time_in_weekday

  94                         local expected_hours = obj.content['hoursPerWeekday'][weekday_name] or 0
  94                         day_data.summary.overhour = time_in_weekday - expected_hours

                             -- Accumulate this day's overhour to the overall week summary
  94                         current_week_data.summary.overhour = current_week_data.summary.overhour
  94                             + day_data.summary.overhour
                             -- total_time_in_week = total_time_in_week + time_in_weekday -- Accumulate total logged time
                         end
                     end
                 end
             end
         end
         -- If you want to store the total logged time for the week in the summary:
         -- current_week_data.summary.totalLoggedTime = total_time_in_week
     end

     local function TimePause()
  10     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
  10     obj.content.paused = true
  10     save(obj)
  20     notify({
             'Timetracking paused',
  10     }, 'info', { title = 'TimeTracking - Pause' })
     end

     local function TimeResume()
   7     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
   7     obj.content.paused = false
   7     save(obj)
  14     notify({
             'Timetracking resumed',
   7     }, 'info', { title = 'TimeTracking - Resume' })
     end
     local function isPaused()
  72     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
  72     return obj.content.paused
     end

     ---@param opts? { weekday?: string|osdate, time?: number, project?: string, file?: string }
     local function TimeStart(opts)
   9     opts = opts or {}
   9     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
  18     if isPaused() then
***0         return
         end

   9     local weekday = opts.weekday
   9     local time = opts.time
   9     local project = opts.project or 'default_project'
   9     local file = opts.file or 'default_file'

   9     if weekday == nil then
  15         local current_wday_numeric = os.date('*t', os.time()).wday
   5         weekday = wdayToEngName[current_wday_numeric]
         end
   9     if time == nil then
***0         time = os.time()
         end

   9     local year_str = os.date('%Y', time) -- Use time for year_str for consistency if time is provided
   9     local week_str = os.date('%W', time) -- Use time for week_str for consistency

         -- Ensure path exists (init might have only created for current os.date)
   9     if obj.content['data'][year_str] == nil then
***0         obj.content['data'][year_str] = {}
         end
   9     if obj.content['data'][year_str][week_str] == nil then
***0         obj.content['data'][year_str][week_str] = {}
         end
   9     if obj.content['data'][year_str][week_str][project] == nil then
   1         obj.content['data'][year_str][week_str][project] = {}
         end
   9     if obj.content['data'][year_str][week_str][project][file] == nil then
   1         obj.content['data'][year_str][week_str][project][file] = { weekdays = {} }
         end
   9     if obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] == nil then
   8         obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] = {
   8             summary = {},
   8             items = {},
   8         }
         end

   9     local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
   9     local canStart = true
  10     for _, item in pairs(dayItem.items) do
   1         canStart = canStart and (item.startTime ~= nil and item.endTime ~= nil)
         end
   9     if canStart then
   8         local timeReadable = os.date('*t', time)
  16         table.insert(dayItem.items, {
   8             startTime = time,
   8             startReadable = string.format('%02d:%02d', timeReadable.hour, timeReadable.min),
             })
         end
   9     save(obj)
     end

     ---@param opts? { weekday?: string|osdate, time?: number, project?: string, file?: string }
     local function TimeStop(opts)
   7     opts = opts or {}
   7     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
  14     if isPaused() then
***0         return
         end

   7     local weekday = opts.weekday
   7     local time = opts.time
   7     local project = opts.project or 'default_project'
   7     local file = opts.file or 'default_file'

   7     if weekday == nil then
  12         local current_wday_numeric = os.date('*t', os.time()).wday
   4         weekday = wdayToEngName[current_wday_numeric]
         end
   7     if time == nil then
***0         time = os.time()
         end

   7     local year_str = os.date('%Y', time)
   7     local week_str = os.date('%W', time)

         -- Check if the path to the day's items exists in the new structure
   7     local dayItem_path_exists = obj.content['data'][year_str]
   7         and obj.content['data'][year_str][week_str]
   7         and obj.content['data'][year_str][week_str][project]
   7         and obj.content['data'][year_str][week_str][project][file]
   7         and obj.content['data'][year_str][week_str][project][file]['weekdays']
   7         and obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
   7         and obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday].items

   7     if dayItem_path_exists then
   6         local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
  12         for _, item in pairs(dayItem.items) do
   6             if item.endTime == nil then
   5                 item.endTime = time
   5                 local timeReadable = os.date('*t', time)
   5                 item.endReadable = string.format('%02d:%02d', timeReadable.hour, timeReadable.min)
   5                 item.diffInHours = os.difftime(item.endTime, item.startTime) / 60 / 60
                 end
             end
         end

   7     calculate({ year = year_str, weeknumber = week_str }) -- Calculate regardless of whether items were stopped, to update summaries.
   7     save(obj)

   7     local heute_text = 'N/A'
   7     if dayItem_path_exists then
             -- Accessing dayItem here is safe because dayItem_path_exists is true
   6         local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
   6         if dayItem.summary and dayItem.summary.overhour then
   6             heute_text = string.format('%.2f', dayItem.summary.overhour)
             end
         end

   7     local gesamt_text = 'N/A'
         -- Check path for overall week summary - this might be inaccurate until 'calculate' is updated
         if
   7         obj.content['data'][year_str]
   7         and obj.content['data'][year_str][week_str]
   7         and obj.content['data'][year_str][week_str].summary -- This summary is at week level
   7         and obj.content['data'][year_str][week_str].summary.overhour
         then
***0         gesamt_text =
   7             string.format('%.2f', obj.content['data'][year_str][week_str].summary.overhour)
         end

  14     notify({
   7         'Heute: ' .. heute_text .. ' Stunden',
   7         'Gesamt: ' .. gesamt_text .. ' Stunden',
   7     }, 'info', { title = 'TimeTracking - Stop' })
     end

     -- calculate an average over the hoursPerWeekday
     local function calculateAverage()
   2     local sum = 0
   2     local count = 0
  14     for _, value in pairs(config.hoursPerWeekday) do
  12         sum = sum + value
  12         count = count + 1
         end
   2     return sum / count
     end

     local function saveTime(startTime, endTime, weekday, clearDay, project, file, isSubtraction)
  42     project = project or 'default_project'
  42     file = file or 'default_file'
  42     isSubtraction = isSubtraction or false -- Default to false if not provided
  42     local year_str = os.date('%Y', startTime) -- Use startTime to determine year/week
  42     local week_str = os.date('%W', startTime)

         -- Ensure path exists
  42     if obj.content['data'][year_str] == nil then
***0         obj.content['data'][year_str] = {}
         end
  42     if obj.content['data'][year_str][week_str] == nil then
***0         obj.content['data'][year_str][week_str] = {}
         end
  42     if obj.content['data'][year_str][week_str][project] == nil then
   5         obj.content['data'][year_str][week_str][project] = {}
         end
  42     if obj.content['data'][year_str][week_str][project][file] == nil then
   6         obj.content['data'][year_str][week_str][project][file] = { weekdays = {} }
         end
  42     if obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] == nil then
  34         obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday] = {
  34             summary = {},
  34             items = {},
  34         }
         end

         -- Handle clearDay logic - if true, existing items for the day are cleared.
         -- The original saveTime had a complex `clearDay` check in the first 'if'.
         -- Assuming if clearDay is passed as non-nil (and not 'nope'), it means we should clear.
         -- The addTime function passes clearDay as 'yes' or nil. 'nope' was for subtractTime.
         -- For simplicity here, if clearDay is true (boolean), we clear.
         -- The addTime/setTime logic will need to ensure clearDay is passed appropriately.
         -- The original logic for clearDay was: `if clearDay == nil and ... == nil then init day`.
         -- This seems more about init than clearing. The actual clearing is done by `clearDay()` func.
         -- Let's stick to the new structure path first. The `clearDay` param in `saveTime` might be redundant
         -- if `clearDay()` function is used before `addTime` in `setTime`.
         -- For now, `clearDay` in `saveTime` doesn't actively clear, it's more for path init.

  42     local dayItem = obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
  42     local timeReadableStart = os.date('*t', startTime)
  42     local item = {
  42         startTime = startTime,
  42         startReadable = string.format('%02d:%02d', timeReadableStart.hour, timeReadableStart.min),
  42         endTime = endTime,
         }
  42     local timeReadableEnd = os.date('*t', endTime)
  42     item.endReadable = string.format('%02d:%02d', timeReadableEnd.hour, timeReadableEnd.min)

  42     item.diffInHours = os.difftime(item.endTime, item.startTime) / 60 / 60
  42     if isSubtraction then
   9         item.diffInHours = -item.diffInHours
         end

  42     table.insert(dayItem.items, item)
  42     calculate({ year = year_str, weeknumber = week_str })
  42     save(obj)

  84     notify({
  42         'Heute: ' .. string.format('%.2f', dayItem.summary.overhour) .. ' Stunden',
             'Gesamt: '
  42             .. string.format('%.2f', obj.content['data'][year_str][week_str].summary.overhour)
  42             .. ' Stunden',
  42     }, 'info', { title = 'TimeTracking - SaveTime' }) -- Changed title for clarity
     end

     -- adds time into the current week
     ---@param opts { time: number, weekday: string|osdate, clearDay?: string, project?: string, file?: string }
     local function addTime(opts)
  33     local time = opts.time
  33     local weekday = opts.weekday
  33     local clearDay = opts.clearDay -- This is 'yes' or nil from setTime/setIllDay, or 'nope'
  33     local project = opts.project or 'default_project'
  33     local file = opts.file or 'default_file'

         -- The original clearDay logic: if nil, it's 'nope'; if 'yes', it's nil for saveTime's old check.
         -- This is confusing. Let's simplify: `clearDay` in `addTime` means "should the day be cleared before adding".
         -- `setTime` calls `clearDay()` then `addTime()`. So `addTime` itself doesn't need to handle clearing.
         -- The `clearDay` parameter passed to `saveTime` from here will be the original `opts.clearDay` value.
         -- saveTime's responsibility is just to save, path creation is fine.

  33     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })

  33     local current_mocked_ts = os.time() -- This will be GMT if tests mock os.time correctly
  33     local current_mocked_t_info = os.date('*t', current_mocked_ts) -- GMT components

         -- Calculate GMT midnight for the current mocked day
***0     local current_day_gmt_midnight_ts = current_mocked_ts
***0         - (
  33             current_mocked_t_info.hour * 3600
  33             + current_mocked_t_info.min * 60
  33             + current_mocked_t_info.sec
  33         )

  33     local targetWeekdayName = opts.weekday
  33     if targetWeekdayName == nil then
   1         targetWeekdayName = wdayToEngName[current_mocked_t_info.wday]
         end

         -- Determine Target Weekday and its GMT Midnight
         -- Note: os.date('*t').wday is 1 for Sunday, ..., 7 for Saturday
  33     local weekday_name_to_num_1_7 = {
             Sunday = 1,
             Monday = 2,
             Tuesday = 3,
             Wednesday = 4,
             Thursday = 5,
             Friday = 6,
             Saturday = 7,
         }
  33     local current_wday_numeric_1_7 = current_mocked_t_info.wday
  33     local target_wday_numeric_1_7 = weekday_name_to_num_1_7[targetWeekdayName]

  33     if target_wday_numeric_1_7 == nil then
             -- Fallback for unrecognized weekday string, though ideally should not happen
             -- if opts.weekday is validated or comes from wdayToEngName
***0         notify(
                 "Warning: Unrecognized weekday '"
***0                 .. tostring(targetWeekdayName)
***0                 .. "' in addTime. Defaulting to current day.",
                 'warn'
             )
***0         target_wday_numeric_1_7 = current_wday_numeric_1_7
         end

  33     local day_offset = target_wday_numeric_1_7 - current_wday_numeric_1_7
  33     local target_day_gmt_midnight_ts = current_day_gmt_midnight_ts + (day_offset * 24 * 3600)

         -- Calculate duration in total seconds
  33     local total_seconds_duration = math.floor(opts.time * 3600)

         -- Calculate startTime_ts and endTime_ts using GMT arithmetic
  33     local add_endTime_ts = target_day_gmt_midnight_ts + (23 * 3600) -- 23:00:00 GMT on target day
  33     local add_startTime_ts = add_endTime_ts - total_seconds_duration

  33     local startTime = add_startTime_ts
  33     local endTime = add_endTime_ts

  33     local paused = isPaused()
  33     if paused then
   1         TimeResume()
         end

         -- Pass project and file to saveTime
  33     saveTime(startTime, endTime, targetWeekdayName, clearDay, project, file, false)

  33     if paused then
   1         TimePause()
         end
  33     return obj
     end

     -- subtracts time from the current week
     ---@param opts { time: number, weekday: string|osdate, project?: string, file?: string }
     local function subtractTime(opts)
   9     local time = opts.time
   9     local weekday = opts.weekday
   9     local project = opts.project or 'default_project'
   9     local file = opts.file or 'default_file'

   9     init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })

   9     local current_mocked_ts = os.time() -- This will be GMT if tests mock os.time correctly
   9     local current_mocked_t_info = os.date('*t', current_mocked_ts) -- GMT components

         -- Calculate GMT midnight for the current mocked day
***0     local current_day_gmt_midnight_ts = current_mocked_ts
***0         - (
   9             current_mocked_t_info.hour * 3600
   9             + current_mocked_t_info.min * 60
   9             + current_mocked_t_info.sec
   9         )

   9     local targetWeekdayName = opts.weekday
   9     if targetWeekdayName == nil then
   1         targetWeekdayName = wdayToEngName[current_mocked_t_info.wday]
         end

         -- Determine Target Weekday and its GMT Midnight
         -- Note: os.date('*t').wday is 1 for Sunday, ..., 7 for Saturday
   9     local weekday_name_to_num_1_7 = {
             Sunday = 1,
             Monday = 2,
             Tuesday = 3,
             Wednesday = 4,
             Thursday = 5,
             Friday = 6,
             Saturday = 7,
         }
   9     local current_wday_numeric_1_7 = current_mocked_t_info.wday
   9     local target_wday_numeric_1_7 = weekday_name_to_num_1_7[targetWeekdayName]

   9     if target_wday_numeric_1_7 == nil then
             -- Fallback for unrecognized weekday string
***0         notify(
                 "Warning: Unrecognized weekday '"
***0                 .. tostring(targetWeekdayName)
***0                 .. "' in subtractTime. Defaulting to current day.",
                 'warn'
             )
***0         target_wday_numeric_1_7 = current_wday_numeric_1_7
         end

   9     local day_offset = target_wday_numeric_1_7 - current_wday_numeric_1_7
   9     local target_day_gmt_midnight_ts = current_day_gmt_midnight_ts + (day_offset * 24 * 3600)

         -- Calculate duration in total seconds
   9     local total_seconds_duration = math.floor(opts.time * 3600)

         -- Calculate startTime_to_save and endTime_to_save using GMT arithmetic
   9     local sub_day_end_reference_ts = target_day_gmt_midnight_ts + (23 * 3600) -- 23:00:00 GMT on target day
   9     local sub_startTime_to_save = sub_day_end_reference_ts - total_seconds_duration
   9     local sub_endTime_to_save = sub_day_end_reference_ts

   9     local startTime = sub_startTime_to_save
   9     local endTime = sub_endTime_to_save

   9     local paused = isPaused()
   9     if paused then
   1         TimeResume()
         end

         -- Pass project, file. 'nope' for clearDay indicates not to clear.
   9     saveTime(startTime, endTime, targetWeekdayName, 'nope', project, file, true)

   9     if paused then
   1         TimePause()
         end

   9     return obj
     end

     local function setIllDay(weekday)
   4     addTime({
   4         time = calculateAverage(),
   2         weekday = weekday,
             clearDay = 'yes',
         })
   2     return obj
     end

     local function clearDay(weekday, project, file)
   1     project = project or 'default_project'
   1     file = file or 'default_file'
   1     local year_str = os.date('%Y')
   1     local week_str = os.date('%W')

         if
   1         obj.content['data'][year_str]
   1         and obj.content['data'][year_str][week_str]
   1         and obj.content['data'][year_str][week_str][project]
   1         and obj.content['data'][year_str][week_str][project][file]
   1         and obj.content['data'][year_str][week_str][project][file]['weekdays']
   1         and obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday]
         then
             local dayItems =
   1             obj.content['data'][year_str][week_str][project][file]['weekdays'][weekday].items
   1         if dayItems then
   3             for key, _ in pairs(dayItems) do
   2                 dayItems[key] = nil
                 end
             end
         end
   1     calculate({ year = year_str, weeknumber = week_str }) -- Recalculate for the current/affected week
   1     save(obj)
     end

     ---@param opts { time: number, weekday: string|osdate, project?: string, file?: string }
     local function setTime(opts)
   1     opts = opts or {}
   1     local project = opts.project or 'default_project'
   1     local file = opts.file or 'default_file'

   1     clearDay(opts.weekday, project, file) -- Pass project and file to clearDay
   2     addTime({
   1         time = opts.time,
   1         weekday = opts.weekday,
             clearDay = 'yes', -- 'yes' indicates to saveTime that items might have been cleared
   1         project = project,
   1         file = file,
         })
     end

   8 local timeGroup = vim.api.nvim_create_augroup('Maorun-Time', {})
  16 vim.api.nvim_create_autocmd({ 'FocusGained', 'BufEnter', 'VimEnter' }, {
   8     group = timeGroup,
         desc = 'Start Timetracking on VimEnter or BufEnter (if second vim was leaved)',
         callback = function()
***0         TimeStart()
         end,
     })
  16 vim.api.nvim_create_autocmd('VimLeave', {
   8     group = timeGroup,
         desc = 'End Timetracking on VimLeave',
         callback = function()
***0         TimeStop()
         end,
     })

     ---@param opts { hours?: boolean, weekday?: boolean, project?: boolean, file?: boolean }
     ---@param callback fun(hours:number, weekday: string, project:string, file:string) the function to call
     local function select(opts, callback)
***0     opts = vim.tbl_deep_extend('force', { -- Use 'force' to ensure defaults are applied
             hours = true,
             weekday = true,
             project = true,
             file = true,
***0     }, opts or {})

***0     local selected_project = 'default_project'
***0     local selected_file = 'default_file'

         local function get_file_input()
***0         if opts.file then
***0             vim.ui.input({ prompt = 'File name? (default: default_file) ' }, function(input)
***0                 selected_file = (input and input ~= '') and input or 'default_file'
***0                 get_weekday_selection() -- Proceed to weekday selection
                 end)
             else
***0             get_weekday_selection() -- Skip file input
             end
         end

         local function get_project_input()
***0         if opts.project then
***0             vim.ui.input({ prompt = 'Project name? (default: default_project) ' }, function(input)
***0                 selected_project = (input and input ~= '') and input or 'default_project'
***0                 get_file_input() -- Proceed to file input
                 end)
             else
***0             get_file_input() -- Skip project input
             end
         end

***0     local selections = {}
***0     local selectionNumbers = {}
***0     for _, value in pairs(weekdayNumberMap) do
***0         if not selectionNumbers[value] then
***0             selectionNumbers[value] = 1
***0             selections[#selections + 1] = _
             end
         end

         ---@param weekday string
         local function selectHours(weekday_param)
***0         if opts.hours then
***0             vim.ui.input({
                     prompt = 'How many hours? ',
                 }, function(input)
***0                 local n = tonumber(input)
***0                 if n == nil or input == nil or input == '' then
***0                     return
                     end
***0                 callback(n, weekday_param, selected_project, selected_file)
                 end)
             else
                 -- If hours are not required, pass a default or handle appropriately
***0             callback(0, weekday_param, selected_project, selected_file) -- Assuming 0 hours if not prompted
             end
         end

         local function get_weekday_selection()
***0         if opts.weekday then
***0             if pcall(require, 'telescope') then
***0                 local telescopeSelect = require('maorun.time.weekday_select')
***0                 telescopeSelect({
                         prompt_title = 'Which day?',
                         list = selections,
                         action = function(selected_weekday)
***0                         selectHours(selected_weekday)
                         end,
                     })
                 else
***0                 vim.ui.select(selections, {
                         prompt = 'Which day? ',
                     }, function(selected_weekday)
***0                     selectHours(selected_weekday)
                     end)
                 end
             else
                 -- If weekday is not required, pass a default or handle appropriately
                 -- This case might need clarification: what weekday to use if not selected?
                 -- For now, assuming it means no time entry if weekday selection is skipped.
                 -- Or, pass a default like current day, but callback expects a weekday.
                 -- Let's assume callback is only made if weekday is selected.
                 -- If opts.weekday is false, the chain stops or uses a predefined weekday.
                 -- For now, if weekday is false, we directly call callback with defaults (e.g. for project/file only ops)
                 -- callback(0, nil, selected_project, selected_file) -- This line is problematic if weekday is essential
                 -- Safest is to ensure weekday selection happens if callback needs it.
                 -- The current design implies `select` is primarily for operations that involve weekday and hours.
                 -- If only project/file are needed for some future op, `select` might need more changes.
                 -- Given the context of addTime, substractTime, setTime, weekday and hours are essential.
             end
         end

         -- Start the chain of inputs
***0     get_project_input()
     end

   8 Time = {
         add = function()
***0         select(
                 {},
                 function(hours, weekday, project, file) -- Add project and file to callback params
***0                 addTime({ time = hours, weekday = weekday, project = project, file = file })
                 end
             )
         end,
   8     addTime = addTime,
         subtract = function()
***0         select({}, function(hours, weekday, project, file) -- Add project and file
***0             subtractTime({ time = hours, weekday = weekday, project = project, file = file })
             end)
         end,
   8     subtractTime = subtractTime,
   8     clearDay = clearDay, -- clearDay now takes project and file, but this public Time.clearDay would need them.
         -- This might require another vim.ui.select or direct args. For now, it's an issue.
         -- TODO: Adjust public Time.clearDay or make it internal / part of setTime only.
   8     TimePause = TimePause,
   8     TimeResume = TimeResume,
   8     TimeStop = TimeStop,
         set = function()
***0         select({}, function(hours, weekday, project, file) -- Add project and file
***0             setTime({ time = hours, weekday = weekday, project = project, file = file })
             end)
         end,
   8     setTime = setTime,
   8     setIllDay = setIllDay,
   8     setHoliday = setIllDay,
         calculate = function(opts) -- Accept opts
***0         init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
***0         calculate(opts)
***0         save(obj)
***0         return obj
         end,
   8 }

   8 return {
   8     setup = init,
   8     TimeStart = TimeStart,
   8     TimeStop = TimeStop,
   8     TimePause = TimePause,
   8     TimeResume = TimeResume,
   8     setIllDay = setIllDay,
   8     setHoliday = setIllDay,
   8     addTime = addTime,
   8     subtractTime = subtractTime,
   8     setTime = setTime,
   8     clearDay = clearDay,
   8     isPaused = isPaused,
         calculate = function(opts) -- Accept opts
  42         init({ path = obj.path, hoursPerWeekday = obj.content['hoursPerWeekday'] })
  42         calculate(opts)
  42         save(obj)
  42         return obj
         end,

   8     weekdays = weekdayNumberMap,
   8 }

==============================================================================
Summary
==============================================================================

File                                                                     Hits Missed Coverage
---------------------------------------------------------------------------------------------
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/init.lua 339  69     83.09%
---------------------------------------------------------------------------------------------
Total                                                                    339  69     83.09%
