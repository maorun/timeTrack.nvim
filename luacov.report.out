==============================================================================
/home/runner/nvim-nightly/share/nvim/runtime/lua/vim/ui.lua
==============================================================================
   1 local M = {}

     --- Prompts the user to pick from a list of items, allowing arbitrary (potentially asynchronous)
     --- work until `on_choice`.
     ---
     --- Example:
     ---
     --- ```lua
     --- vim.ui.select({ 'tabs', 'spaces' }, {
     ---     prompt = 'Select tabs or spaces:',
     ---     format_item = function(item)
     ---         return "I'd like to choose " .. item
     ---     end,
     --- }, function(choice)
     ---     if choice == 'spaces' then
     ---         vim.o.expandtab = true
     ---     else
     ---         vim.o.expandtab = false
     ---     end
     --- end)
     --- ```
     ---
     ---@generic T
     ---@param items T[] Arbitrary items
     ---@param opts table Additional options
     ---     - prompt (string|nil)
     ---               Text of the prompt. Defaults to `Select one of:`
     ---     - format_item (function item -> text)
     ---               Function to format an
     ---               individual item from `items`. Defaults to `tostring`.
     ---     - kind (string|nil)
     ---               Arbitrary hint string indicating the item shape.
     ---               Plugins reimplementing `vim.ui.select` may wish to
     ---               use this to infer the structure or semantics of
     ---               `items`, or the context in which select() was called.
     ---@param on_choice fun(item: T|nil, idx: integer|nil)
     ---               Called once the user made a choice.
     ---               `idx` is the 1-based index of `item` within `items`.
     ---               `nil` if the user aborted the dialog.
   1 function M.select(items, opts, on_choice)
***0   vim.validate('items', items, 'table')
***0   vim.validate('on_choice', on_choice, 'function')
***0   opts = opts or {}
***0   local choices = { opts.prompt or 'Select one of:' }
***0   local format_item = opts.format_item or tostring
***0   for i, item in
***0     ipairs(items --[[@as any[] ]])
       do
***0     table.insert(choices, string.format('%d: %s', i, format_item(item)))
       end
***0   local choice = vim.fn.inputlist(choices)
***0   if choice < 1 or choice > #items then
***0     on_choice(nil, nil)
       else
***0     on_choice(items[choice], choice)
       end
     end

     --- Prompts the user for input, allowing arbitrary (potentially asynchronous) work until
     --- `on_confirm`.
     ---
     --- Example:
     ---
     --- ```lua
     --- vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)
     ---     vim.o.shiftwidth = tonumber(input)
     --- end)
     --- ```
     ---
     ---@param opts table? Additional options. See |input()|
     ---     - prompt (string|nil)
     ---               Text of the prompt
     ---     - default (string|nil)
     ---               Default reply to the input
     ---     - completion (string|nil)
     ---               Specifies type of completion supported
     ---               for input. Supported types are the same
     ---               that can be supplied to a user-defined
     ---               command using the "-complete=" argument.
     ---               See |:command-completion|
     ---     - highlight (function)
     ---               Function that will be used for highlighting
     ---               user inputs.
     ---@param on_confirm function ((input|nil) -> ())
     ---               Called once the user confirms or abort the input.
     ---               `input` is what the user typed (it might be
     ---               an empty string if nothing was entered), or
     ---               `nil` if the user aborted the dialog.
   1 function M.input(opts, on_confirm)
***0   vim.validate('opts', opts, 'table', true)
***0   vim.validate('on_confirm', on_confirm, 'function')

***0   opts = (opts and not vim.tbl_isempty(opts)) and opts or vim.empty_dict()

       -- Note that vim.fn.input({}) returns an empty string when cancelled.
       -- vim.ui.input() should distinguish aborting from entering an empty string.
***0   local _canceled = vim.NIL
***0   opts = vim.tbl_extend('keep', opts, { cancelreturn = _canceled })

***0   local ok, input = pcall(vim.fn.input, opts)
***0   if not ok or input == _canceled then
***0     on_confirm(nil)
       else
***0     on_confirm(input)
       end
     end

     --- Opens `path` with the system default handler (macOS `open`, Windows `explorer.exe`, Linux
     --- `xdg-open`, â€¦), or returns (but does not show) an error message on failure.
     ---
     --- Can also be invoked with `:Open`. [:Open]()
     ---
     --- Expands "~/" and environment variables in filesystem paths.
     ---
     --- Examples:
     ---
     --- ```lua
     --- -- Asynchronous.
     --- vim.ui.open("https://neovim.io/")
     --- vim.ui.open("~/path/to/file")
     --- -- Use the "osurl" command to handle the path or URL.
     --- vim.ui.open("gh#neovim/neovim!29490", { cmd = { 'osurl' } })
     --- -- Synchronous (wait until the process exits).
     --- local cmd, err = vim.ui.open("$VIMRUNTIME")
     --- if cmd then
     ---   cmd:wait()
     --- end
     --- ```
     ---
     ---@param path string Path or URL to open
     ---@param opt? { cmd?: string[] } Options
     ---     - cmd string[]|nil Command used to open the path or URL.
     ---
     ---@return vim.SystemObj|nil # Command object, or nil if not found.
     ---@return nil|string # Error message on failure, or nil on success.
     ---
     ---@see |vim.system()|
   1 function M.open(path, opt)
***0   vim.validate('path', path, 'string')
***0   local is_uri = path:match('%w+:')
***0   if not is_uri then
***0     path = vim.fs.normalize(path)
       end

***0   opt = opt or {}
       local cmd ---@type string[]
***0   local job_opt = { text = true, detach = true } --- @type vim.SystemOpts

***0   if opt.cmd then
***0     cmd = vim.list_extend(opt.cmd --[[@as string[] ]], { path })
***0   elseif vim.fn.has('mac') == 1 then
***0     cmd = { 'open', path }
***0   elseif vim.fn.has('win32') == 1 then
***0     if vim.fn.executable('rundll32') == 1 then
***0       cmd = { 'rundll32', 'url.dll,FileProtocolHandler', path }
         else
***0       return nil, 'vim.ui.open: rundll32 not found'
         end
***0   elseif vim.fn.executable('xdg-open') == 1 then
***0     cmd = { 'xdg-open', path }
***0     job_opt.stdout = false
***0     job_opt.stderr = false
***0   elseif vim.fn.executable('wslview') == 1 then
***0     cmd = { 'wslview', path }
***0   elseif vim.fn.executable('explorer.exe') == 1 then
***0     cmd = { 'explorer.exe', path }
***0   elseif vim.fn.executable('lemonade') == 1 then
***0     cmd = { 'lemonade', 'open', path }
       else
***0     return nil, 'vim.ui.open: no handler found (tried: wslview, explorer.exe, xdg-open, lemonade)'
       end

***0   return vim.system(cmd, job_opt), nil
     end

     --- Returns all URLs at cursor, if any.
     --- @return string[]
   1 function M._get_urls()
***0   local urls = {} ---@type string[]

***0   local bufnr = vim.api.nvim_get_current_buf()
***0   local cursor = vim.api.nvim_win_get_cursor(0)
***0   local row = cursor[1] - 1
***0   local col = cursor[2]
***0   local extmarks = vim.api.nvim_buf_get_extmarks(bufnr, -1, { row, col }, { row, col }, {
         details = true,
         type = 'highlight',
         overlap = true,
       })
***0   for _, v in ipairs(extmarks) do
***0     local details = v[4]
***0     if details and details.url then
***0       urls[#urls + 1] = details.url
         end
       end

***0   local highlighter = vim.treesitter.highlighter.active[bufnr]
***0   if highlighter then
***0     local range = { row, col, row, col }
***0     local ltree = highlighter.tree:language_for_range(range)
***0     local lang = ltree:lang()
***0     local query = vim.treesitter.query.get(lang, 'highlights')
***0     if query then
***0       local tree = assert(ltree:tree_for_range(range))
***0       for _, match, metadata in query:iter_matches(tree:root(), bufnr, row, row + 1) do
***0         for id, nodes in pairs(match) do
***0           for _, node in ipairs(nodes) do
***0             if vim.treesitter.node_contains(node, range) then
***0               local url = metadata[id] and metadata[id].url
***0               if url and match[url] then
***0                 for _, n in
***0                   ipairs(match[url] --[[@as TSNode[] ]])
                     do
***0                   urls[#urls + 1] =
***0                     vim.treesitter.get_node_text(n, bufnr, { metadata = metadata[url] })
                     end
                   end
                 end
               end
             end
           end
         end
       end

***0   if #urls == 0 then
         -- If all else fails, use the filename under the cursor
***0     table.insert(
           urls,
***0       vim._with({ go = { isfname = vim.o.isfname .. ',@-@' } }, function()
***0         return vim.fn.expand('<cfile>')
           end)
         )
       end

***0   return urls
     end

   1 return M

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/autocmds.lua
==============================================================================
   8 local core = require('maorun.time.core')
   8 local utils = require('maorun.time.utils') -- For get_project_and_file_info

   8 local M = {}

   8 function M.setup_autocmds()
  62     local timeGroup = vim.api.nvim_create_augroup('Maorun-Time', { clear = true })

 124     vim.api.nvim_create_autocmd('VimEnter', {
  62         group = timeGroup,
             desc = 'Start Timetracking on VimEnter for the initial buffer',
             callback = function()
***0             local current_buf = vim.api.nvim_get_current_buf()
***0             local info = utils.get_project_and_file_info(current_buf)
***0             if info then
***0                 core.TimeStart({ project = info.project, file = info.file })
                 else
***0                 core.TimeStart() -- Use defaults if no info
                 end
             end,
         })

 124     vim.api.nvim_create_autocmd('BufEnter', {
  62         group = timeGroup,
             desc = 'Start Timetracking when entering a buffer',
             callback = function(args)
                 -- Prevent execution if buffer name is empty (e.g. new empty buffer)
                 -- or if it's a special buffer like Telescope prompt
***0             local bufname = vim.api.nvim_buf_get_name(args.buf)
***0             if bufname == '' or vim.bo[args.buf].buftype ~= '' then
***0                 return
                 end

***0             local info = utils.get_project_and_file_info(args.buf)
***0             if info then
***0                 core.TimeStart({ project = info.project, file = info.file })
                 else
                     -- It's possible that even with a valid bufname, info is nil
                     -- if get_project_and_file_info can't determine project/file.
                     -- In this case, using defaults is reasonable.
***0                 core.TimeStart()
                 end
             end,
         })

 124     vim.api.nvim_create_autocmd('FocusGained', {
  62         group = timeGroup,
             desc = 'Start Timetracking when Neovim gains focus',
             callback = function()
***0             local current_buf = vim.api.nvim_get_current_buf()
***0             local bufname = vim.api.nvim_buf_get_name(current_buf)
                 -- Similar check for empty or special buffers
***0             if bufname == '' or vim.bo[current_buf].buftype ~= '' then
***0                 return
                 end

***0             local info = utils.get_project_and_file_info(current_buf)
***0             if info then
***0                 core.TimeStart({ project = info.project, file = info.file })
                 else
***0                 core.TimeStart()
                 end
             end,
         })

 124     vim.api.nvim_create_autocmd('BufLeave', {
  62         group = timeGroup,
             desc = 'Stop Timetracking for the buffer being left',
             callback = function(args)
                 -- Prevent execution if buffer name is empty or special buffer
***0             local bufname = vim.api.nvim_buf_get_name(args.buf)
***0             if bufname == '' or vim.bo[args.buf].buftype ~= '' then
***0                 return
                 end

***0             local info = utils.get_project_and_file_info(args.buf)
***0             if info then
***0                 core.TimeStop({ project = info.project, file = info.file })
                 else
***0                 core.TimeStop()
                 end
             end,
         })

 124     vim.api.nvim_create_autocmd('VimLeave', {
  62         group = timeGroup,
             desc = 'End Timetracking on VimLeave (general stop)',
             callback = function()
***0             core.TimeStop()
             end,
         })
     end

   8 return M

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/config.lua
==============================================================================
  10 local os_sep = require('plenary.path').path.sep

  10 local M = {}

  10 M.wdayToEngName = {
         [1] = 'Sunday',
         [2] = 'Monday',
         [3] = 'Tuesday',
         [4] = 'Wednesday',
         [5] = 'Thursday',
         [6] = 'Friday',
         [7] = 'Saturday',
  10 }

  10 M.defaultHoursPerWeekday = {
         Monday = 8,
         Tuesday = 8,
         Wednesday = 8,
         Thursday = 8,
         Friday = 8,
         Saturday = 0,
         Sunday = 0,
  10 }

  10 M.weekdayNumberMap = {
         Sunday = 0,
         Monday = 1,
         Tuesday = 2,
         Wednesday = 3,
         Thursday = 4,
         Friday = 5,
         Saturday = 6,
  10 }

  10 M.obj = {
         path = nil,
  10     content = {}, -- Initialize content as an empty table
  10 }

  10 M.defaults = {
  20     path = vim.fn.stdpath('data') .. os_sep .. 'maorun-time.json',
  10     hoursPerWeekday = M.defaultHoursPerWeekday,
  10 }

     -- This 'config' table will be populated by the init function later
     -- For now, it can be initialized with defaults, or left empty
     -- and the main init.lua or core.lua will handle merging user_config with defaults.
     -- Let's initialize it with defaults for now.
  10 M.config = vim.deepcopy(M.defaults) -- Use deepcopy to avoid modifying defaults unintentionally

  10 return M

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/core.lua
==============================================================================
   9 local Path = require('plenary.path')
   9 local notify = require('notify')
   9 local config_module = require('maorun.time.config')
   9 local utils = require('maorun.time.utils')

   9 local M = {}

   9 function M.init(user_config)
  79     config_module.config =
 158         vim.tbl_deep_extend('force', vim.deepcopy(config_module.defaults), user_config or {})
  79     if user_config and user_config.hoursPerWeekday ~= nil then
  34         config_module.config.hoursPerWeekday = user_config.hoursPerWeekday
         end
  79     config_module.obj.path = config_module.config.path
  79     local p = Path:new(config_module.obj.path)
 237     if not p:exists() then
  14         p:touch({ parents = true })
         end

 237     local data = Path:new(config_module.obj.path):read()
  79     if data ~= '' then
  22         config_module.obj.content = vim.json.decode(data)
         else
  57         config_module.obj.content = {}
         end
         -- Ensure hoursPerWeekday is initialized if not present (e.g. new file)
  79     if config_module.obj.content['hoursPerWeekday'] == nil then
  59         config_module.obj.content['hoursPerWeekday'] = config_module.config.hoursPerWeekday
         end
         -- Ensure paused flag is initialized
  79     if config_module.obj.content['paused'] == nil then
  58         config_module.obj.content['paused'] = false
         end

  79     if config_module.obj.content['data'] == nil then
  57         config_module.obj.content['data'] = {}
         end

         -- Ensure the basic structure for current time (if needed for some initialization logic)
  79     local year_str = os.date('%Y')
  79     local week_str = os.date('%W')
         -- Get current weekday name
 132     local current_wday_numeric = os.date('*t', os.time()).wday -- No longer needed here
  79     local weekday_name = config_module.wdayToEngName[current_wday_numeric] -- No longer needed here

  79     local project_name = 'default_project' -- No longer needed here
  79     local file_name = 'default_file' -- No longer needed here

         -- Initialize year if not exists
  79     if config_module.obj.content['data'][year_str] == nil then
  69         config_module.obj.content['data'][year_str] = {}
         end
         -- Initialize week if not exists
  79     if config_module.obj.content['data'][year_str][week_str] == nil then
  69         config_module.obj.content['data'][year_str][week_str] = {}
         end
         -- Initialize weekday if not exists
  79     if config_module.obj.content['data'][year_str][week_str][weekday_name] == nil then
  70         config_module.obj.content['data'][year_str][week_str][weekday_name] = {}
         end
         -- Initialize project if not exists
  79     if config_module.obj.content['data'][year_str][week_str][weekday_name][project_name] == nil then
  70         config_module.obj.content['data'][year_str][week_str][weekday_name][project_name] = {}
         end
         -- Initialize file with empty items and summary (previously was weekdays = {})
         if
  79         config_module.obj.content['data'][year_str][week_str][weekday_name][project_name][file_name]
  79         == nil
         then
  70         config_module.obj.content['data'][year_str][week_str][weekday_name][project_name][file_name] =
                 {
  70                 items = {},
  70                 summary = {},
  70             }
         end
  79     return config_module.obj
     end

   9 function M.calculate(opts)
 170     opts = vim.tbl_deep_extend('keep', opts or {}, {
 166         year = os.date('%Y'),
 166         weeknumber = os.date('%W'),
  85     })

  85     local year_str = opts.year
  85     local week_str = opts.weeknumber

         if
  85         not config_module.obj.content['data'][year_str]
  83         or not config_module.obj.content['data'][year_str][week_str]
         then
   2         return
         end

  83     local current_week_data = config_module.obj.content['data'][year_str][week_str]

  83     if current_week_data.summary == nil then
  39         current_week_data.summary = {}
         end

  83     local prevWeekOverhour = 0
         -- Previous week overhour calculation (remains unchanged)
  83     if config_module.obj.content['data'][year_str] then
  83         local prev_week_number_str = string.format('%02d', tonumber(week_str) - 1)
  83         if config_module.obj.content['data'][year_str][prev_week_number_str] then
   2             local prev_week_data = config_module.obj.content['data'][year_str][prev_week_number_str]
   2             if prev_week_data and prev_week_data.summary and prev_week_data.summary.overhour then
   2                 prevWeekOverhour = prev_week_data.summary.overhour
                 end
             end
         end

  83     current_week_data.summary.overhour = prevWeekOverhour -- Initialize with previous week's overhour

 278     for weekday_name, weekday_data in pairs(current_week_data) do
 195         if weekday_name ~= 'summary' then -- Assuming 'summary' is not a valid weekday name
                 -- Initialize daily summary for the weekday
 112             if weekday_data.summary == nil then
  51                 weekday_data.summary = { diffInHours = 0, overhour = 0 } -- diffInHours will accumulate
                 else -- Ensure it's reset/initialized correctly for recalculation
  61                 weekday_data.summary.diffInHours = 0
  61                 weekday_data.summary.overhour = 0
                 end

 112             local total_hours_for_weekday = 0

 338             for project_name, project_data in pairs(weekday_data) do
 226                 if project_name ~= 'summary' then -- Check project_name
 232                     for file_name, file_data in pairs(project_data) do
 118                         if file_name ~= 'summary' then -- Check file_name
 118                             local time_in_file = 0
 118                             if file_data.items then
 223                                 for _, item_entry in pairs(file_data.items) do
 105                                     if item_entry.diffInHours ~= nil then
 102                                         time_in_file = time_in_file + item_entry.diffInHours
                                         end
                                     end
                                 end

 118                             if file_data.summary == nil then
***0                                 file_data.summary = {}
                                 end
 118                             file_data.summary.diffInHours = time_in_file
 118                             file_data.summary.overhour = nil -- Explicitly remove/nil it

 118                             total_hours_for_weekday = total_hours_for_weekday + time_in_file
                             end -- end if file_name ~= 'summary'
                         end -- end for file_name
                     end -- end if project_name ~= 'summary'
                 end -- end for project_name

                 -- Now calculate the summary for the entire weekday
 112             weekday_data.summary.diffInHours = total_hours_for_weekday
 112             local expected_hours_for_weekday = config_module.obj.content['hoursPerWeekday'][weekday_name]
 112                 or 0
 112             weekday_data.summary.overhour = total_hours_for_weekday - expected_hours_for_weekday

                 -- Add this weekday's overhour to the total week's overhour
 112             current_week_data.summary.overhour = current_week_data.summary.overhour
 112                 + weekday_data.summary.overhour
             end
         end
     end

   9 function M.TimePause()
  20     M.init({
  10         path = config_module.obj.path,
  10         hoursPerWeekday = config_module.obj.content['hoursPerWeekday'],
         })
  10     config_module.obj.content.paused = true
  10     utils.save()
  20     notify({
             'Timetracking paused',
  10     }, 'info', { title = 'TimeTracking - Pause' })
     end

   9 function M.TimeResume()
  14     M.init({
   7         path = config_module.obj.path,
   7         hoursPerWeekday = config_module.obj.content['hoursPerWeekday'],
         })
   7     config_module.obj.content.paused = false
   7     utils.save()
  14     notify({
             'Timetracking resumed',
   7     }, 'info', { title = 'TimeTracking - Resume' })
     end

   9 function M.isPaused()
         -- Ensure data is loaded before checking pause state, especially if called early.
         -- However, frequent re-init might be inefficient.
         -- Assuming init has been called once at setup.
         -- If not, this might need to call M.init or rely on it being called.
         -- Return the paused state. If not initialized, defaults to false (not paused).
  72     return config_module.obj.content and config_module.obj.content.paused == true
     end

     ---@param opts? { weekday?: string|osdate, time?: number, project?: string, file?: string }
   9 function M.TimeStart(opts)
   9     opts = opts or {}
         -- Similar to isPaused, ensure init has run.
         -- M.init({ path = config_module.obj.path, hoursPerWeekday = config_module.obj.content['hoursPerWeekday'] })
  18     if M.isPaused() then
***0         return
         end

   9     local weekday = opts.weekday
   9     local time = opts.time
   9     local project = opts.project or 'default_project'
   9     local file = opts.file or 'default_file'

   9     if weekday == nil then
  15         local current_wday_numeric = os.date('*t', os.time()).wday
   5         weekday = config_module.wdayToEngName[current_wday_numeric]
         end
   9     if time == nil then
***0         time = os.time()
         end

   9     local year_str = os.date('%Y', time)
   9     local week_str = os.date('%W', time)

   9     if config_module.obj.content['data'][year_str] == nil then
   8         config_module.obj.content['data'][year_str] = {}
         end
   9     if config_module.obj.content['data'][year_str][week_str] == nil then
   8         config_module.obj.content['data'][year_str][week_str] = {}
         end
         -- New structure: year -> week -> weekday -> project -> file
   9     if config_module.obj.content['data'][year_str][week_str][weekday] == nil then
   8         config_module.obj.content['data'][year_str][week_str][weekday] = {}
         end
   9     if config_module.obj.content['data'][year_str][week_str][weekday][project] == nil then
   8         config_module.obj.content['data'][year_str][week_str][weekday][project] = {}
         end
   9     if config_module.obj.content['data'][year_str][week_str][weekday][project][file] == nil then
   8         config_module.obj.content['data'][year_str][week_str][weekday][project][file] = {
   8             summary = {},
   8             items = {},
   8         }
         end

         local file_data_for_day =
   9         config_module.obj.content['data'][year_str][week_str][weekday][project][file]
   9     local canStart = true
  10     for _, item in pairs(file_data_for_day.items) do
   1         canStart = canStart and (item.startTime ~= nil and item.endTime ~= nil)
         end
   9     if canStart then
   8         local timeReadable = os.date('*t', time)
  16         table.insert(file_data_for_day.items, {
   8             startTime = time,
   8             startReadable = string.format('%02d:%02d', timeReadable.hour, timeReadable.min),
             })
         end
   9     utils.save()
     end

     ---@param opts? { weekday?: string|osdate, time?: number, project?: string, file?: string }
   9 function M.TimeStop(opts)
   7     opts = opts or {}
         -- M.init({ path = config_module.obj.path, hoursPerWeekday = config_module.obj.content['hoursPerWeekday'] })
  14     if M.isPaused() then
***0         return
         end

   7     local weekday = opts.weekday
   7     local time = opts.time
   7     local project = opts.project or 'default_project'
   7     local file = opts.file or 'default_file'

   7     if weekday == nil then
  12         local current_wday_numeric = os.date('*t', os.time()).wday
   4         weekday = config_module.wdayToEngName[current_wday_numeric]
         end
   7     if time == nil then
***0         time = os.time()
         end

   7     local year_str = os.date('%Y', time)
   7     local week_str = os.date('%W', time)

         -- New structure: year -> week -> weekday -> project -> file
   7     local file_data_path_exists = config_module.obj.content['data'][year_str]
   7         and config_module.obj.content['data'][year_str][week_str]
   6         and config_module.obj.content['data'][year_str][week_str][weekday]
   6         and config_module.obj.content['data'][year_str][week_str][weekday][project]
   6         and config_module.obj.content['data'][year_str][week_str][weekday][project][file]
   6         and config_module.obj.content['data'][year_str][week_str][weekday][project][file].items

   7     if file_data_path_exists then
             local file_data_for_day =
   6             config_module.obj.content['data'][year_str][week_str][weekday][project][file]
  12         for _, item in pairs(file_data_for_day.items) do
   6             if item.endTime == nil then
   5                 item.endTime = time
   5                 local timeReadable = os.date('*t', time)
   5                 item.endReadable = string.format('%02d:%02d', timeReadable.hour, timeReadable.min)
   5                 item.diffInHours = os.difftime(item.endTime, item.startTime) / 60 / 60
                 end
             end
         end

   7     M.calculate({ year = year_str, weeknumber = week_str })
   7     utils.save()
     end

   9 function M.saveTime(startTime, endTime, weekday, _clearDay, project, file, isSubtraction) -- _clearDay param might be unused now
  42     project = project or 'default_project'
  42     file = file or 'default_file'
  42     isSubtraction = isSubtraction or false
  42     local year_str = os.date('%Y', startTime)
  42     local week_str = os.date('%W', startTime)

  42     if config_module.obj.content['data'][year_str] == nil then
  14         config_module.obj.content['data'][year_str] = {}
         end
  42     if config_module.obj.content['data'][year_str][week_str] == nil then
  14         config_module.obj.content['data'][year_str][week_str] = {}
         end
         -- New structure: year -> week -> weekday -> project -> file
  42     if config_module.obj.content['data'][year_str][week_str][weekday] == nil then
  25         config_module.obj.content['data'][year_str][week_str][weekday] = {}
         end
  42     if config_module.obj.content['data'][year_str][week_str][weekday][project] == nil then
  26         config_module.obj.content['data'][year_str][week_str][weekday][project] = {}
         end
  42     if config_module.obj.content['data'][year_str][week_str][weekday][project][file] == nil then
  27         config_module.obj.content['data'][year_str][week_str][weekday][project][file] = {
  27             summary = {},
  27             items = {},
  27         }
         end

         local file_data_for_day =
  42         config_module.obj.content['data'][year_str][week_str][weekday][project][file]
  42     local timeReadableStart = os.date('*t', startTime)
  42     local item = {
  42         startTime = startTime,
  42         startReadable = string.format('%02d:%02d', timeReadableStart.hour, timeReadableStart.min),
  42         endTime = endTime,
         }
  42     local timeReadableEnd = os.date('*t', endTime)
  42     item.endReadable = string.format('%02d:%02d', timeReadableEnd.hour, timeReadableEnd.min)

  42     item.diffInHours = os.difftime(item.endTime, item.startTime) / 60 / 60
  42     if isSubtraction then
   9         item.diffInHours = -item.diffInHours
         end

  42     table.insert(file_data_for_day.items, item)
  42     M.calculate({ year = year_str, weeknumber = week_str })
  42     utils.save()
     end

     ---@param opts { time: number, weekday: string|osdate, clearDay?: string, project?: string, file?: string }
   9 function M.addTime(opts)
  33     local clearDay_param = opts.clearDay -- Store original clearDay for potential future use, though saveTime ignores it now
  33     local project = opts.project or 'default_project'
  33     local file = opts.file or 'default_file'

         -- M.init({ path = config_module.obj.path, hoursPerWeekday = config_module.obj.content['hoursPerWeekday'] })

  33     local current_mocked_ts = os.time()
  33     local current_mocked_t_info = os.date('*t', current_mocked_ts)

***0     local current_day_gmt_midnight_ts = current_mocked_ts
***0         - (
  33             current_mocked_t_info.hour * 3600
  33             + current_mocked_t_info.min * 60
  33             + current_mocked_t_info.sec
  33         )

  33     local targetWeekdayName = opts.weekday
  33     if targetWeekdayName == nil then
   1         targetWeekdayName = config_module.wdayToEngName[current_mocked_t_info.wday]
         end

  33     local weekday_name_to_num_1_7 = {
             Sunday = 1,
             Monday = 2,
             Tuesday = 3,
             Wednesday = 4,
             Thursday = 5,
             Friday = 6,
             Saturday = 7,
         }
  33     local current_wday_numeric_1_7 = current_mocked_t_info.wday
  33     local target_wday_numeric_1_7 = weekday_name_to_num_1_7[targetWeekdayName]

  33     if target_wday_numeric_1_7 == nil then
***0         notify(
                 "Warning: Unrecognized weekday '"
***0                 .. tostring(targetWeekdayName)
***0                 .. "' in addTime. Defaulting to current day.",
                 'warn'
             )
***0         target_wday_numeric_1_7 = current_wday_numeric_1_7
***0         targetWeekdayName = config_module.wdayToEngName[current_wday_numeric_1_7] -- Correct targetWeekdayName
         end

  33     local day_offset = target_wday_numeric_1_7 - current_wday_numeric_1_7
  33     local target_day_gmt_midnight_ts = current_day_gmt_midnight_ts + (day_offset * 24 * 3600)

  33     local total_seconds_duration = math.floor(opts.time * 3600)
  33     local add_endTime_ts = target_day_gmt_midnight_ts + (23 * 3600)
  33     local add_startTime_ts = add_endTime_ts - total_seconds_duration

  33     local paused_state = M.isPaused()
  33     if paused_state then
   1         M.TimeResume()
         end

  66     M.saveTime(
  33         add_startTime_ts,
  33         add_endTime_ts,
  33         targetWeekdayName,
  33         clearDay_param,
  33         project,
  33         file,
             false
  33     )

  33     if paused_state then
   1         M.TimePause()
         end
  33     return config_module.obj
     end

     ---@param opts { time: number, weekday: string|osdate, project?: string, file?: string }
   9 function M.subtractTime(opts)
   9     local project = opts.project or 'default_project'
   9     local file = opts.file or 'default_file'

         -- M.init({ path = config_module.obj.path, hoursPerWeekday = config_module.obj.content['hoursPerWeekday'] })

   9     local current_mocked_ts = os.time()
   9     local current_mocked_t_info = os.date('*t', current_mocked_ts)

***0     local current_day_gmt_midnight_ts = current_mocked_ts
***0         - (
   9             current_mocked_t_info.hour * 3600
   9             + current_mocked_t_info.min * 60
   9             + current_mocked_t_info.sec
   9         )

   9     local targetWeekdayName = opts.weekday
   9     if targetWeekdayName == nil then
   1         targetWeekdayName = config_module.wdayToEngName[current_mocked_t_info.wday]
         end

   9     local weekday_name_to_num_1_7 = {
             Sunday = 1,
             Monday = 2,
             Tuesday = 3,
             Wednesday = 4,
             Thursday = 5,
             Friday = 6,
             Saturday = 7,
         }
   9     local current_wday_numeric_1_7 = current_mocked_t_info.wday
   9     local target_wday_numeric_1_7 = weekday_name_to_num_1_7[targetWeekdayName]

   9     if target_wday_numeric_1_7 == nil then
***0         notify(
                 "Warning: Unrecognized weekday '"
***0                 .. tostring(targetWeekdayName)
***0                 .. "' in subtractTime. Defaulting to current day.",
                 'warn'
             )
***0         target_wday_numeric_1_7 = current_wday_numeric_1_7
***0         targetWeekdayName = config_module.wdayToEngName[current_wday_numeric_1_7] -- Correct targetWeekdayName
         end

   9     local day_offset = target_wday_numeric_1_7 - current_wday_numeric_1_7
   9     local target_day_gmt_midnight_ts = current_day_gmt_midnight_ts + (day_offset * 24 * 3600)

   9     local total_seconds_duration = math.floor(opts.time * 3600)
   9     local sub_day_end_reference_ts = target_day_gmt_midnight_ts + (23 * 3600)
   9     local sub_startTime_to_save = sub_day_end_reference_ts - total_seconds_duration
   9     local sub_endTime_to_save = sub_day_end_reference_ts

   9     local paused_state = M.isPaused()
   9     if paused_state then
   1         M.TimeResume()
         end

  18     M.saveTime(
   9         sub_startTime_to_save,
   9         sub_endTime_to_save,
   9         targetWeekdayName,
   9         'nope',
   9         project,
   9         file,
             true
   9     )

   9     if paused_state then
   1         M.TimePause()
         end
   9     return config_module.obj
     end

   9 function M.setIllDay(weekday_param, project, file) -- Added project and file params
   4     M.addTime({
   4         time = utils.calculateAverage(),
   2         weekday = weekday_param,
             clearDay = 'yes', -- This implies clearing should happen before adding.
   2         project = project,
   2         file = file,
         })
   2     return config_module.obj
     end

   9 function M.clearDay(weekday_param, project, file)
   1     project = project or 'default_project'
   1     file = file or 'default_file'
   1     local year_str = os.date('%Y')
   1     local week_str = os.date('%W')

         -- New structure: year -> week -> weekday -> project -> file
         if
   1         config_module.obj.content['data'][year_str]
   1         and config_module.obj.content['data'][year_str][week_str]
   1         and config_module.obj.content['data'][year_str][week_str][weekday_param]
   1         and config_module.obj.content['data'][year_str][week_str][weekday_param][project]
   1         and config_module.obj.content['data'][year_str][week_str][weekday_param][project][file]
         then
             local file_data_for_day =
   1             config_module.obj.content['data'][year_str][week_str][weekday_param][project][file]
   1         if file_data_for_day.items then
   1             file_data_for_day.items = {} -- Clear items by assigning an empty table
             end
             -- Optionally reset summary for the day as well
             -- file_data_for_day.summary = {}
         end
   1     M.calculate({ year = year_str, weeknumber = week_str })
   1     utils.save()
     end

     ---@param opts { time: number, weekday: string|osdate, project?: string, file?: string }
   9 function M.setTime(opts)
   1     opts = opts or {}
   1     local project = opts.project or 'default_project'
   1     local file = opts.file or 'default_file'

   1     M.clearDay(opts.weekday, project, file)
   2     M.addTime({
   1         time = opts.time,
   1         weekday = opts.weekday,
             clearDay = 'yes',
   1         project = project,
   1         file = file,
         })
     end

   9 function M.get_config()
   2     return config_module.obj
     end

   9 return M

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/init.lua
==============================================================================
     -- Main init.lua for maorun.time

     -- Require the new modules
   8 local config_module = require('maorun.time.config')
   8 local core = require('maorun.time.core')
   8 local utils = require('maorun.time.utils') -- Though utils might be mostly used by core
   8 local autocmds = require('maorun.time.autocmds')
   8 local ui = require('maorun.time.ui')

     -- The main module table that will be returned
   8 local M = {}

     -- Setup function to initialize the plugin
     ---@param user_config table|nil User configuration to override defaults
   8 function M.setup(user_config)
         -- Initialize core components (loads data, sets up config_module.obj and config_module.config)
  62     local config_obj = core.init(user_config) -- Store the returned object
         -- Setup autocommands
  62     autocmds.setup_autocmds()
         -- The global Time table is not strictly necessary if all interactions happen via returned module,
         -- but keeping it for compatibility if it was used globally before.
         -- Otherwise, commands should be set up to call M.add(), M.subtract(), etc.
  62     Time = {
             add = function()
***0             ui.select(
                     {}, -- Default opts: ask for hours, weekday, project, file
                     function(hours, weekday, project, file)
***0                     core.addTime({ time = hours, weekday = weekday, project = project, file = file })
                     end
                 )
             end,
  62         addTime = core.addTime,
             subtract = function()
***0             ui.select(
                     {}, -- Default opts
                     function(hours, weekday, project, file)
***0                     core.subtractTime({
                             time = hours,
                             weekday = weekday,
                             project = project,
                             file = file,
                         })
                     end
                 )
             end,
  62         subtractTime = core.subtractTime,
             clearDay = function(weekday, project, file) -- Requires explicit params now
                 -- This public clearDay needs a way to get weekday, project, file.
                 -- Option 1: Use ui.select, asking only for what's needed.
                 -- Option 2: Require user to pass them directly.
                 -- For now, assume direct pass or user handles getting them.
                 -- If called from command, command needs to parse args.
***0             if not weekday then
                     -- TODO: Maybe prompt for weekday if not provided, or use current day?
                     -- For now, let's make it clear it needs parameters.
***0                 print('Error: Time.clearDay requires weekday, project, and file parameters.')
                     -- Example of how to prompt if desired:
                     -- ui.select({hours=false}, function(_, wd, pr, fl) core.clearDay(wd, pr, fl) end)
***0                 return
                 end
***0             core.clearDay(weekday, project, file)
             end,
  62         TimePause = core.TimePause,
  62         TimeResume = core.TimeResume,
             TimeStop = function()
***0             core.TimeStop()

***0             local notify = require('notify')

***0             local startTime = os.time()
***0             local year_str = os.date('%Y', startTime)
***0             local week_str = os.date('%W', startTime)

***0             notify({
                     'Gesamt: '
***0                     .. string.format(
                             '%.2f',
***0                         config_module.obj.content['data'][year_str][week_str].summary.overhour
                         )
***0                     .. ' Stunden',
***0             }, 'info', { title = 'TimeTracking - Stop' })
             end,
             set = function()
***0             ui.select(
                     {}, -- Default opts
                     function(hours, weekday, project, file)
***0                     core.setTime({ time = hours, weekday = weekday, project = project, file = file })
                     end
                 )
             end,
  62         setTime = core.setTime,
             setIllDay = function(weekday, project, file) -- Matching core.setIllDay signature change
                 -- Similar to clearDay, this needs parameters.
                 -- If weekday is nil, we might prompt for it.
***0             if not weekday then
***0                 ui.select({ hours = false, project = true, file = true }, function(_, wd, pr, fl)
***0                     core.setIllDay(wd, pr, fl)
                     end)
                 else
***0                 core.setIllDay(weekday, project, file) -- Pass through if provided
                 end
             end,
             setHoliday = function(weekday, project, file) -- Alias for setIllDay
***0             if not weekday then
***0                 ui.select({ hours = false, project = true, file = true }, function(_, wd, pr, fl)
***0                     core.setIllDay(wd, pr, fl)
                     end)
                 else
***0                 core.setIllDay(weekday, project, file) -- Pass through if provided
                 end
             end,
             calculate = function(opts)
                 -- The core.calculate function doesn't save automatically.
                 -- The original init.lua's calculate did save.
                 -- Decide if this public calculate should also save.
                 -- For consistency with original, let's add init and save.
***0             core.init({
                     path = config_module.obj.path,
                     hoursPerWeekday = config_module.obj.content['hoursPerWeekday'],
                 })
***0             core.calculate(opts)
***0             utils.save() -- Assuming utils.save uses the shared config_module.obj
***0             return config_module.obj -- Return the data object
             end,
  62     }
  62     return config_obj -- Return the config_obj obtained from core.init
     end

     -- Functions returned by the module for direct use (e.g., by other plugins or specific keymaps)
   8 M.TimeStart = core.TimeStart
   8 M.TimeStop = core.TimeStop
   8 M.TimePause = core.TimePause
   8 M.TimeResume = core.TimeResume
   8 M.setIllDay = core.setIllDay
   8 M.setHoliday = core.setIllDay -- Alias
   8 M.addTime = core.addTime
   8 M.subtractTime = core.subtractTime
   8 M.setTime = core.setTime
   8 M.clearDay = core.clearDay
   8 M.isPaused = core.isPaused
     M.calculate = function(opts) -- Match the public Time.calculate behavior
         -- core.init({
         --     path = config_module.obj.path,
         --     hoursPerWeekday = config_module.obj.content['hoursPerWeekday'],
         -- }) -- THIS CALL IS REMOVED/COMMENTED OUT
  35     core.calculate(opts)
  35     utils.save()
  35     return config_module.obj
     end
   8 M.weekdays = config_module.weekdayNumberMap -- Expose weekday map
   8 M.get_config = core.get_config -- Expose the get_config function

   8 return M

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/ui.lua
==============================================================================
   9 local core = require('maorun.time.core')
   9 local config_module = require('maorun.time.config') -- For weekdayNumberMap

   9 local M = {}

     ---@param opts { hours?: boolean, weekday?: boolean, project?: boolean, file?: boolean }
     ---@param callback fun(hours:number, weekday: string, project:string, file:string) the function to call
   9 function M.select(opts, callback)
  24     opts = vim.tbl_deep_extend('force', {
             hours = true,
             weekday = true,
             project = true,
             file = true,
  24     }, opts or {})

  12     local selected_project = 'default_project'
  12     local selected_file = 'default_file'

         local function get_file_input()
  12         if opts.file then
  20             vim.ui.input({ prompt = 'File name? (default: default_file) ' }, function(input)
  10                 selected_file = (input and input ~= '') and input or 'default_file'
  10                 get_weekday_selection()
                 end)
             else
   2             get_weekday_selection()
             end
         end

         local function get_project_input()
  12         if opts.project then
  20             vim.ui.input({ prompt = 'Project name? (default: default_project) ' }, function(input)
  10                 selected_project = (input and input ~= '') and input or 'default_project'
  10                 get_file_input()
                 end)
             else
   2             get_file_input()
             end
         end

  12     local selections = {}
  12     local selectionNumbers = {}
         -- Sort weekdayNumberMap by value to ensure consistent order for vim.ui.select
  12     local sorted_weekdays = {}
  96     for day, num in pairs(config_module.weekdayNumberMap) do
  84         table.insert(sorted_weekdays, { name = day, value = num })
         end
  24     table.sort(sorted_weekdays, function(a, b)
 204         return a.value < b.value
         end)

  96     for _, day_info in ipairs(sorted_weekdays) do
  84         if not selectionNumbers[day_info.value] then -- This check might be redundant if weekdayNumberMap has unique values
  84             selectionNumbers[day_info.value] = 1
  84             selections[#selections + 1] = day_info.name
             end
         end

         ---@param weekday_param string
         local function selectHours(weekday_param)
***0         if opts.hours then
***0             vim.ui.input({
                     prompt = 'How many hours? ',
                 }, function(input)
***0                 local n = tonumber(input)
***0                 if n == nil or input == nil or input == '' then
***0                     notify('Invalid number of hours provided.', 'warn', { title = 'TimeTracking' })
***0                     return
                     end
***0                 callback(n, weekday_param, selected_project, selected_file)
                 end)
             else
***0             callback(0, weekday_param, selected_project, selected_file) -- Assuming 0 hours if not prompted
             end
         end

         local function get_weekday_selection()
***0         if opts.weekday then
***0             if pcall(require, 'telescope') and require('maorun.time.weekday_select') then
***0                 local telescopeSelect = require('maorun.time.weekday_select')
***0                 telescopeSelect({
                         prompt_title = 'Which day?',
                         list = selections, -- Use the sorted selections
                         action = function(selected_weekday)
***0                         if selected_weekday then -- Ensure a selection was made
***0                             selectHours(selected_weekday)
                             else
***0                             notify('No weekday selected.', 'info', { title = 'TimeTracking' })
                             end
                         end,
                     })
                 else
***0                 vim.ui.select(selections, { -- Use the sorted selections
                         prompt = 'Which day? ',
                     }, function(selected_weekday)
***0                     if selected_weekday then -- Ensure a selection was made
***0                         selectHours(selected_weekday)
                         else
***0                         notify('No weekday selected.', 'info', { title = 'TimeTracking' })
                         end
                     end)
                 end
             else
                 -- This case needs careful handling. If weekday is false, what should happen?
                 -- The original code didn't seem to have a clear path if opts.weekday was false
                 -- and callback requires a weekday.
                 -- For now, let's assume if opts.weekday is false, the operation is not time-specific
                 -- and we call back with a nil weekday, or a sensible default.
                 -- However, the callback signature expects a weekday string.
                 -- Option 1: Error or notify that weekday is required.
                 -- Option 2: Use a default (e.g., current day).
                 -- Option 3: Modify callback or have different select functions.
                 -- Given current callback, let's notify and not proceed if weekday is essential but skipped.
***0             if opts.hours then -- If hours are also expected, it's likely a time entry operation.
***0                 notify(
                         "Weekday selection was skipped, but it's required for this operation.",
                         'warn',
***0                     { title = 'TimeTracking' }
                     )
***0                 return
                 else
                     -- If only project/file are relevant and weekday/hours are not.
                     -- This path is not used by current Time.add/subtract/set.
***0                 callback(0, nil, selected_project, selected_file)
                 end
             end
         end

  12     get_project_input()
     end

   9 return M

==============================================================================
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/utils.lua
==============================================================================
  21 local Path = require('plenary.path')
  21 local config_module = require('maorun.time.config') -- Adjusted path

  21 local M = {}

  21 function M.save()
 448     Path:new(config_module.obj.path):write(vim.fn.json_encode(config_module.obj.content), 'w')
     end

  21 function M.get_project_and_file_info(buffer_path_or_bufnr)
         local filepath_str
  10     if type(buffer_path_or_bufnr) == 'number' then
   6         filepath_str = vim.api.nvim_buf_get_name(buffer_path_or_bufnr)
   7     elseif type(buffer_path_or_bufnr) == 'string' then
   6         filepath_str = buffer_path_or_bufnr
         else
   1         return nil -- Invalid input type
         end

   9     if filepath_str == nil or filepath_str == '' then
   3         return nil
         end

   6     local file_path_obj = Path:new(filepath_str)
   6     if not file_path_obj then -- Ensure Path object was created
***0         return nil
         end

   6     local file_name = file_path_obj.filename
   6     if file_name == nil or file_name == '' then
   1         return nil -- No valid file name (e.g. a directory path was passed)
         end

   5     local project_name = nil
   5     local current_dir = file_path_obj:parent()
   5     local last_sensible_parent = file_path_obj:parent() -- Initialize with the first parent

         -- Loop upwards to find .git directory
  11     while current_dir do
  30         if current_dir:joinpath('.git'):exists() then
   2             project_name = current_dir.filename
   2             break
             end
  16         if current_dir:is_root() then
   2             break
             end
   6         last_sensible_parent = current_dir -- Update before going higher
  12         current_dir = current_dir:parent()
         end

   5     if project_name == nil then
             -- Fallback logic using last_sensible_parent
   3         if last_sensible_parent then
   6             if last_sensible_parent:is_root() then
   1                 project_name = '_root_'
   2             elseif last_sensible_parent.filename and last_sensible_parent.filename ~= '' then
   1                 project_name = last_sensible_parent.filename
                 else
   1                 project_name = 'default_project'
                 end
             else
***0             project_name = 'default_project'
             end
         end

   5     if project_name == '' then
***0         project_name = '_root_'
         end

         -- Ensure file_name is not nil or empty before returning
   5     if file_name and file_name ~= '' then
   5         return { project = project_name, file = file_name }
         else
             -- This case should ideally be caught earlier, but as a safeguard:
***0         return nil
         end
     end

     -- calculate an average over the hoursPerWeekday
  21 function M.calculateAverage()
   6     local sum = 0
   6     local count = 0
  31     for _, value in pairs(config_module.config.hoursPerWeekday) do
  25         sum = sum + value
  25         count = count + 1
         end
   6     if count == 0 then
   1         return 0
         end -- Avoid division by zero
   5     return sum / count
     end

  21 return M

==============================================================================
Summary
==============================================================================

File                                                                         Hits Missed Coverage
-------------------------------------------------------------------------------------------------
/home/runner/nvim-nightly/share/nvim/runtime/lua/vim/ui.lua                  6    80     6.98%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/autocmds.lua 16   28     36.36%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/config.lua   17   0      100.00%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/core.lua     315  19     94.31%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/init.lua     34   32     51.52%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/ui.lua       31   24     56.36%
/home/runner/work/timeTrack.nvim/timeTrack.nvim/lua/maorun/time/utils.lua    49   4      92.45%
-------------------------------------------------------------------------------------------------
Total                                                                        468  187    71.45%
